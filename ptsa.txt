metrics_by_group = []
for g in forecast_df['Business Group'].unique():
    df_g = forecast_df[forecast_df['Business Group'] == g]

    results = {"Business Group": g}

    # Define pairs: (actual_col, forecast_col, label)
    methods = [
        ("Act Vol Attr. Month %", "Fut Vol Attr. Month %_sma", "SMA"),
        ("Act Vol Attr. Month %", "Fut Vol Attr. Month %_ema", "EMA"),
        ("Act Vol Attr. Month %", "Fut Vol Attr. Month %_median", "MEDIAN"),
        ("Act Vol Attr. Month %", "Fut Vol Attr. Month %_wilder", "WILDER"),
        ("Act Vol Attr. Month %", "Fut Vol Attr. Month %_zlema", "ZLEMA"),
        ("Act Vol Attr. Month %", "Fut Vol Attr. Month %_dema", "DEMA"),
        ("Act Vol Attr. Month %", "Fut Vol Attr. Month %_t3", "T3"),
        ("Act Vol Attr. Month %", "Fut Vol Attr. Month %_kalman", "KALMAN"),
    ]

    for actual_col, forecast_col, label in methods:
        mask = (~df_g[actual_col].isna()) & (~df_g[forecast_col].isna())
        if mask.any():
            mae = mean_absolute_error(df_g.loc[mask, actual_col], df_g.loc[mask, forecast_col])
            rmse = mean_squared_error(df_g.loc[mask, actual_col], df_g.loc[mask, forecast_col], squared=False)
        else:
            mae, rmse = np.nan, np.nan
        results[f"MAE_{label}"] = mae
        results[f"RMSE_{label}"] = rmse

    metrics_by_group.append(results)

metrics_df = pd.DataFrame(metrics_by_group)
print(metrics_df)
























import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# -----------------------
# PARAMETERS
# -----------------------
BASE_MONTH_HC = 229568
FORECAST_START = "2025-04-01"
FORECAST_END   = "2025-12-01"
DIVIDE_BY_100  = True
ROLL_WINDOW = 3
# -----------------------

# --------------------------------
# EXTRA MOVING AVERAGE FUNCTIONS
# --------------------------------
def zlema(series, period):
    lag = (period - 1) // 2
    shifted = series.shift(lag, fill_value=series.iloc[0])
    adjusted = series + (series - shifted)
    return adjusted.ewm(span=period, adjust=False).mean()

def dema(series, period):
    ema1 = series.ewm(span=period, adjust=False).mean()
    ema2 = ema1.ewm(span=period, adjust=False).mean()
    return 2 * ema1 - ema2

def t3(series, period, v=0.7):
    # conservative implementation for small series
    e1 = series.ewm(span=period, adjust=False).mean()
    e2 = e1.ewm(span=period, adjust=False).mean()
    e3 = e2.ewm(span=period, adjust=False).mean()
    e4 = e3.ewm(span=period, adjust=False).mean()
    e5 = e4.ewm(span=period, adjust=False).mean()
    e6 = e5.ewm(span=period, adjust=False).mean()

    c1 = -v**3
    c2 = 3*v**2 + 3*v**3
    c3 = -6*v**2 - 3*v - 3*v**3
    c4 = 1 + 3*v + v**3 + 3*v**2

    return c1*e6 + c2*e5 + c3*e4 + c4*e3

def kalman_filter(series, process_var=1e-5, measurement_var=0.01):
    # simple 1D Kalman filter
    n = len(series)
    if n == 0:
        return pd.Series(dtype=float)
    xhat = np.zeros(n)
    P = np.zeros(n)
    # handle potential nan at start
    first_valid_idx = 0
    while first_valid_idx < n and pd.isna(series.iloc[first_valid_idx]):
        first_valid_idx += 1
    if first_valid_idx == n:
        # all NaN -> return series of NaN
        return pd.Series([np.nan]*n, index=series.index)
    xhat[first_valid_idx] = series.iloc[first_valid_idx]
    P[first_valid_idx] = 1.0
    # fill earlier values with initial (so output aligns)
    for i in range(0, first_valid_idx):
        xhat[i] = xhat[first_valid_idx]
        P[i] = P[first_valid_idx]

    for k in range(first_valid_idx+1, n):
        # Predict
        xhat_pred = xhat[k-1]
        P_pred = P[k-1] + process_var

        # Update (handle nan measurements)
        if pd.isna(series.iloc[k]):
            xhat[k] = xhat_pred
            P[k] = P_pred
        else:
            K = P_pred / (P_pred + measurement_var)
            xhat[k] = xhat_pred + K * (series.iloc[k] - xhat_pred)
            P[k] = (1 - K) * P_pred

    return pd.Series(xhat, index=series.index)

# -----------------------
# Prepare df
# -----------------------
# ensure MONTH is month-start timestamp (same as your original)
df['MONTH'] = pd.to_datetime(df['MONTH']).dt.to_period('M').dt.to_timestamp()
df['YEAR']  = df['MONTH'].dt.year

forecast_index = pd.date_range(start=FORECAST_START, end=FORECAST_END, freq="MS")
groups = df['BUSINESS_GROUPS_TA'].unique()

all_rows = []

for g in groups:
    grp = df[df['BUSINESS_GROUPS_TA'] == g].copy().set_index('MONTH').sort_index()

    # smoothing: SMA, EMA, Rolling Median, Wilder (alpha = 1/N)
    grp['SMA3'] = grp['MONTHLY_ATTRITION_RATE'].rolling(window=ROLL_WINDOW).mean()
    grp['EMA3'] = grp['MONTHLY_ATTRITION_RATE'].ewm(span=ROLL_WINDOW, adjust=False).mean()
    grp['MED3'] = grp['MONTHLY_ATTRITION_RATE'].rolling(window=ROLL_WINDOW).median()
    alpha_wilder = 1.0 / ROLL_WINDOW
    grp['WILDER3'] = grp['MONTHLY_ATTRITION_RATE'].ewm(alpha=alpha_wilder, adjust=False).mean()

    # advanced: ZLEMA, DEMA, T3, Kalman
    grp['ZLEMA3'] = zlema(grp['MONTHLY_ATTRITION_RATE'], ROLL_WINDOW)
    grp['DEMA3']  = dema(grp['MONTHLY_ATTRITION_RATE'], ROLL_WINDOW)
    grp['T3_3']   = t3(grp['MONTHLY_ATTRITION_RATE'], ROLL_WINDOW)
    grp['KALMAN'] = kalman_filter(grp['MONTHLY_ATTRITION_RATE'])

    # last-available fallback utility
    def last_valid(col):
        if (col in grp.columns) and (not grp[col].empty):
            v = grp[col].iloc[-1]
            if not pd.isna(v):
                return v
        if (not grp['MONTHLY_ATTRITION_RATE'].empty):
            return grp['MONTHLY_ATTRITION_RATE'].iloc[-1]
        return np.nan

    last_sma = last_valid('SMA3')
    last_ema = last_valid('EMA3')
    last_med = last_valid('MED3')
    last_wil = last_valid('WILDER3')
    last_zlema = last_valid('ZLEMA3')
    last_dema  = last_valid('DEMA3')
    last_t3    = last_valid('T3_3')
    last_kal   = last_valid('KALMAN')

    # last known headcount BEFORE forecast start (safe fallbacks)
    pre_forecast_hc_series = grp[grp.index < pd.to_datetime(FORECAST_START)]['HEADCOUNT']
    if not pre_forecast_hc_series.empty:
        last_known_hc = pre_forecast_hc_series.iloc[-1]
    else:
        last_known_hc = grp['HEADCOUNT'].iloc[-1] if (not grp['HEADCOUNT'].empty) else BASE_MONTH_HC

    # build rows for every forecast_index month (keeps actuals if present)
    for fut_ts in forecast_index:
        # actuals if present
        if fut_ts in grp.index:
            act_rate  = grp.at[fut_ts, 'MONTHLY_ATTRITION_RATE'] if 'MONTHLY_ATTRITION_RATE' in grp.columns else np.nan
            act_exits = grp.at[fut_ts, 'VOLUNTARY_EXITS'] if 'VOLUNTARY_EXITS' in grp.columns else np.nan
            act_hc    = grp.at[fut_ts, 'HEADCOUNT'] if 'HEADCOUNT' in grp.columns else np.nan
        else:
            act_rate  = np.nan
            act_exits = np.nan
            act_hc    = np.nan

        def get_smoothed(col, last_val):
            if (fut_ts in grp.index) and (col in grp.columns) and (not pd.isna(grp.at[fut_ts, col])):
                return grp.at[fut_ts, col]
            return last_val

        fut_rate_sma   = get_smoothed('SMA3', last_sma)
        fut_rate_ema   = get_smoothed('EMA3', last_ema)
        fut_rate_med   = get_smoothed('MED3', last_med)
        fut_rate_wil   = get_smoothed('WILDER3', last_wil)
        fut_rate_zlema = get_smoothed('ZLEMA3', last_zlema)
        fut_rate_dema  = get_smoothed('DEMA3', last_dema)
        fut_rate_t3    = get_smoothed('T3_3', last_t3)
        fut_rate_kal   = get_smoothed('KALMAN', last_kal)

        def to_count(rate):
            if pd.isna(rate):
                return np.nan
            return (rate / 100.0 * last_known_hc) if DIVIDE_BY_100 else (rate * last_known_hc)

        fut_count_sma   = to_count(fut_rate_sma)
        fut_count_ema   = to_count(fut_rate_ema)
        fut_count_med   = to_count(fut_rate_med)
        fut_count_wil   = to_count(fut_rate_wil)
        fut_count_zlema = to_count(fut_rate_zlema)
        fut_count_dema  = to_count(fut_rate_dema)
        fut_count_t3    = to_count(fut_rate_t3)
        fut_count_kal   = to_count(fut_rate_kal)

        row = {
            "Future Month": fut_ts,
            "Business Group": g,
            "Fut Vol Attr. Month %_sma": round(fut_rate_sma, 4) if not pd.isna(fut_rate_sma) else np.nan,
            "Fut Vol Attr. Month %_ema": round(fut_rate_ema, 4) if not pd.isna(fut_rate_ema) else np.nan,
            "Fut Vol Attr. Month %_med": round(fut_rate_med, 4) if not pd.isna(fut_rate_med) else np.nan,
            "Fut Vol Attr. Month %_wilder": round(fut_rate_wil, 4) if not pd.isna(fut_rate_wil) else np.nan,
            "Fut Vol Attr. Month %_zlema": round(fut_rate_zlema, 4) if not pd.isna(fut_rate_zlema) else np.nan,
            "Fut Vol Attr. Month %_dema": round(fut_rate_dema, 4) if not pd.isna(fut_rate_dema) else np.nan,
            "Fut Vol Attr. Month %_t3": round(fut_rate_t3, 4) if not pd.isna(fut_rate_t3) else np.nan,
            "Fut Vol Attr. Month %_kalman": round(fut_rate_kal, 4) if not pd.isna(fut_rate_kal) else np.nan,
            "Base Month HC": int(last_known_hc) if not pd.isna(last_known_hc) else np.nan,
            "Fut Vol. Attr Count_sma": int(round(fut_count_sma)) if (not pd.isna(fut_count_sma)) else np.nan,
            "Fut Vol. Attr Count_ema": int(round(fut_count_ema)) if (not pd.isna(fut_count_ema)) else np.nan,
            "Fut Vol. Attr Count_med": int(round(fut_count_med)) if (not pd.isna(fut_count_med)) else np.nan,
            "Fut Vol. Attr Count_wilder": int(round(fut_count_wil)) if (not pd.isna(fut_count_wil)) else np.nan,
            "Fut Vol. Attr Count_zlema": int(round(fut_count_zlema)) if (not pd.isna(fut_count_zlema)) else np.nan,
            "Fut Vol. Attr Count_dema": int(round(fut_count_dema)) if (not pd.isna(fut_count_dema)) else np.nan,
            "Fut Vol. Attr Count_t3": int(round(fut_count_t3)) if (not pd.isna(fut_count_t3)) else np.nan,
            "Fut Vol. Attr Count_kalman": int(round(fut_count_kal)) if (not pd.isna(fut_count_kal)) else np.nan,
            "Act Vol Attr. Month %": round(act_rate,4) if not pd.isna(act_rate) else np.nan,
            "Act Vol Attr Count": int(act_exits) if not pd.isna(act_exits) else np.nan,
            "Actual Headcount": int(act_hc) if not pd.isna(act_hc) else np.nan,
        }
        all_rows.append(row)

# Combined forecast DataFrame
forecast_df = pd.DataFrame(all_rows)

# -----------------------
# PLOTTING (per-group)
# -----------------------
actual_df = df[['MONTH','BUSINESS_GROUPS_TA','MONTHLY_ATTRITION_RATE']].rename(
    columns={'MONTH':'Future Month','BUSINESS_GROUPS_TA':'Business Group','MONTHLY_ATTRITION_RATE':'Attrition Rate'})
actual_df['Type'] = 'Actual'

def make_forecast_subset(col, label):
    tmp = forecast_df[['Future Month','Business Group',col]].rename(columns={col:'Attrition Rate'})
    tmp['Type'] = label
    return tmp

forecast_sma    = make_forecast_subset('Fut Vol Attr. Month %_sma','Forecast_SMA')
forecast_ema    = make_forecast_subset('Fut Vol Attr. Month %_ema','Forecast_EMA')
forecast_med    = make_forecast_subset('Fut Vol Attr. Month %_med','Forecast_MED')
forecast_wilder = make_forecast_subset('Fut Vol Attr. Month %_wilder','Forecast_WILDER')
forecast_zlema  = make_forecast_subset('Fut Vol Attr. Month %_zlema','Forecast_ZLEMA')
forecast_dema   = make_forecast_subset('Fut Vol Attr. Month %_dema','Forecast_DEMA')
forecast_t3     = make_forecast_subset('Fut Vol Attr. Month %_t3','Forecast_T3')
forecast_kal    = make_forecast_subset('Fut Vol Attr. Month %_kalman','Forecast_KALMAN')

plot_df = pd.concat([
    actual_df, forecast_sma, forecast_ema, forecast_med, forecast_wilder,
    forecast_zlema, forecast_dema, forecast_t3, forecast_kal
], ignore_index=True)
plot_df['Future Month'] = pd.to_datetime(plot_df['Future Month'])

plt.figure(figsize=(16,8))
forecast_start_dt = pd.to_datetime(FORECAST_START)

colors = {
    'Actual': 'black',
    'Forecast_SMA': 'blue',
    'Forecast_EMA': 'green',
    'Forecast_MED': 'orange',
    'Forecast_WILDER': 'purple',
    'Forecast_ZLEMA': 'red',
    'Forecast_DEMA': 'brown',
    'Forecast_T3': 'cyan',
    'Forecast_KALMAN': 'magenta'
}

for g in groups:
    sub = plot_df[plot_df['Business Group'] == g].sort_values('Future Month')

    for typ in colors.keys():
        data = sub[sub['Type'] == typ]
        if data.empty:
            continue
        # historical (solid)
        hist = data[data['Future Month'] < forecast_start_dt]
        if not hist.empty:
            plt.plot(hist['Future Month'], hist['Attrition Rate'], color=colors[typ], label=f"{g} {typ} (Hist)")
        # forecast (dotted)
        fore = data[data['Future Month'] >= forecast_start_dt]
        if not fore.empty:
            plt.plot(fore['Future Month'], fore['Attrition Rate'], linestyle=':', color=colors[typ], label=f"{g} {typ} (Forecast)")

plt.axvline(forecast_start_dt, color='gray', linestyle=':', linewidth=1)
plt.title("Attrition Rate â€” Actual vs SMA/EMA/Median/Wilder/ZLEMA/DEMA/T3/Kalman")
plt.xlabel("Month")
plt.ylabel("Attrition Rate (%)")
plt.legend(ncol=2, fontsize='small')
plt.grid(True)
plt.tight_layout()
plt.show()

# -----------------------
# OVERALL TOTALS
# -----------------------
actual_tot = df.groupby('MONTH').apply(
    lambda d: pd.Series({
        'total_exits': (d['MONTHLY_ATTRITION_RATE'] / 100.0 * d['HEADCOUNT']).sum(),
        'total_hc'   : d['HEADCOUNT'].sum()
    })
).reset_index().rename(columns={'MONTH':'Future Month'})
actual_tot['overall_rate'] = actual_tot['total_exits'] / actual_tot['total_hc'] * 100.0
actual_tot['Type'] = 'Actual_Total'
actual_tot = actual_tot[['Future Month','overall_rate','Type']].rename(columns={'overall_rate':'Rate'})

def make_total(forecast_df, count_col, type_name):
    tmp = forecast_df.groupby('Future Month').agg({
        count_col: 'sum',
        'Base Month HC': 'sum'
    }).reset_index()
    tmp['Rate'] = (tmp[count_col] / tmp['Base Month HC']) * 100.0
    tmp['Type'] = type_name
    return tmp[['Future Month','Rate','Type']]

forecast_tot_sma    = make_total(forecast_df,'Fut Vol. Attr Count_sma','Forecast_Total_SMA')
forecast_tot_ema    = make_total(forecast_df,'Fut Vol. Attr Count_ema','Forecast_Total_EMA')
forecast_tot_med    = make_total(forecast_df,'Fut Vol. Attr Count_med','Forecast_Total_MED')
forecast_tot_wilder = make_total(forecast_df,'Fut Vol. Attr Count_wilder','Forecast_Total_WILDER')
forecast_tot_zlema  = make_total(forecast_df,'Fut Vol. Attr Count_zlema','Forecast_Total_ZLEMA')
forecast_tot_dema   = make_total(forecast_df,'Fut Vol. Attr Count_dema','Forecast_Total_DEMA')
forecast_tot_t3     = make_total(forecast_df,'Fut Vol. Attr Count_t3','Forecast_Total_T3')
forecast_tot_kal    = make_total(forecast_df,'Fut Vol. Attr Count_kalman','Forecast_Total_KALMAN')

tot_plot = pd.concat([
    actual_tot, forecast_tot_sma, forecast_tot_ema, forecast_tot_med, forecast_tot_wilder,
    forecast_tot_zlema, forecast_tot_dema, forecast_tot_t3, forecast_tot_kal
], ignore_index=True)
tot_plot['Future Month'] = pd.to_datetime(tot_plot['Future Month'])
tot_plot['ForecastFlag'] = tot_plot['Future Month'] >= forecast_start_dt

plt.figure(figsize=(12,6))

def draw_total_line(type_name, color, label):
    hist = tot_plot[(tot_plot['Type']==type_name) & (~tot_plot['ForecastFlag'])].sort_values('Future Month')
    fore = tot_plot[(tot_plot['Type']==type_name) & (tot_plot['ForecastFlag'])].sort_values('Future Month')
    if not hist.empty:
        plt.plot(hist['Future Month'], hist['Rate'], color=color, label=f"{label} (Hist)", linewidth=2)
    if not fore.empty:
        plt.plot(fore['Future Month'], fore['Rate'], color=color, linestyle=':', label=f"{label} (Forecast)", linewidth=2)

draw_total_line('Actual_Total','black','Overall Actual')
draw_total_line('Forecast_Total_SMA','blue','Overall SMA')
draw_total_line('Forecast_Total_EMA','green','Overall EMA')
draw_total_line('Forecast_Total_MED','orange','Overall MEDIAN')
draw_total_line('Forecast_Total_WILDER','purple','Overall WILDER')
draw_total_line('Forecast_Total_ZLEMA','red','Overall ZLEMA')
draw_total_line('Forecast_Total_DEMA','brown','Overall DEMA')
draw_total_line('Forecast_Total_T3','cyan','Overall T3')
draw_total_line('Forecast_Total_KALMAN','magenta','Overall KALMAN')

plt.axvline(forecast_start_dt, color='gray', linestyle=':', linewidth=1)
plt.title("Overall Attrition Rate (weighted) â€” Actual vs SMA/EMA/Median/Wilder/ZLEMA/DEMA/T3/Kalman")
plt.xlabel("Month")
plt.ylabel("Attrition Rate (%)")
plt.legend(ncol=2)
plt.grid(True)
plt.tight_layout()
plt.show()

















































import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import mean_absolute_error, mean_squared_error

# ----------------------
# 1) Compute Metrics
# ----------------------
# Historical part (before forecast start)
eval_df = forecast_df[forecast_df['Future Month'] < pd.to_datetime(FORECAST_START)].copy()

metrics = []
for g in eval_df['Business Group'].unique():
    sub = eval_df[eval_df['Business Group']==g]
    actual = sub['Act Vol Attr. Month %']  # actual rates
    sma = sub['Fut Vol Attr. Month %_sma']
    ema = sub['Fut Vol Attr. Month %_ema']
    med = sub.get('Fut Vol Attr. Month %_med', pd.Series(np.nan, index=sub.index))
    wil = sub.get('Fut Vol Attr. Month %_wilder', pd.Series(np.nan, index=sub.index))

    for name, pred in [('SMA',sma),('EMA',ema),('MEDIAN',med),('WILDER',wil)]:
        mask = ~np.isnan(actual) & ~np.isnan(pred)
        if mask.sum() == 0:
            continue
        mae = mean_absolute_error(actual[mask], pred[mask])
        rmse = mean_squared_error(actual[mask], pred[mask], squared=False)
        mape = np.mean(np.abs((actual[mask]-pred[mask])/(actual[mask]+1e-8)))*100
        metrics.append({
            'Business Group': g,
            'Method': name,
            'MAE': mae,
            'RMSE': rmse,
            'MAPE%': mape
        })

metrics_df = pd.DataFrame(metrics)

# overall average per method (across groups)
overall_metrics = metrics_df.groupby('Method')[['MAE','RMSE','MAPE%']].mean().reset_index()

print("\nðŸ”¹ Per Business Group Metrics:")
print(metrics_df)
print("\nðŸ”¹ Overall Average Metrics Across Groups:")
print(overall_metrics)

# ----------------------
# 2) Overall Metrics Bar Charts
# ----------------------
methods = overall_metrics['Method']
mae = overall_metrics['MAE']
rmse = overall_metrics['RMSE']
mape = overall_metrics['MAPE%']

plt.figure(figsize=(14,4))
plt.subplot(1,3,1)
plt.bar(methods, mae, color=['#4daf4a','#377eb8','#ff7f00','#984ea3'])
plt.title("Mean Absolute Error (MAE)")
plt.ylabel("Error")

plt.subplot(1,3,2)
plt.bar(methods, rmse, color=['#4daf4a','#377eb8','#ff7f00','#984ea3'])
plt.title("Root Mean Squared Error (RMSE)")
plt.ylabel("Error")

plt.subplot(1,3,3)
plt.bar(methods, mape, color=['#4daf4a','#377eb8','#ff7f00','#984ea3'])
plt.title("Mean Absolute Percentage Error (MAPE%)")
plt.ylabel("Error (%)")

plt.suptitle("Overall Metrics Comparison of Moving Averages", fontsize=14)
plt.tight_layout(rect=[0,0,1,0.95])
plt.show()

# ----------------------
# 3) Heatmaps per Business Group
# ----------------------
def plot_heatmap(pivot_df, title):
    fig, ax = plt.subplots(figsize=(10, max(4,len(pivot_df)*0.4)))
    cax = ax.imshow(pivot_df.values, cmap='viridis', aspect='auto')
    ax.set_xticks(np.arange(len(pivot_df.columns)))
    ax.set_xticklabels(pivot_df.columns)
    ax.set_yticks(np.arange(len(pivot_df.index)))
    ax.set_yticklabels(pivot_df.index)
    plt.setp(ax.get_xticklabels(), rotation=45, ha='right', rotation_mode='anchor')
    for i in range(len(pivot_df.index)):
        for j in range(len(pivot_df.columns)):
            val = pivot_df.iloc[i, j]
            if not pd.isna(val):
                ax.text(j, i, f"{val:.2f}", ha='center', va='center', color='white', fontsize=8)
    ax.set_title(title)
    fig.colorbar(cax, ax=ax, orientation='vertical', label='Error')
    plt.tight_layout()
    plt.show()

# Prepare pivot tables
pivot_mae = metrics_df.pivot(index='Business Group', columns='Method', values='MAE')
pivot_rmse = metrics_df.pivot(index='Business Group', columns='Method', values='RMSE')
pivot_mape = metrics_df.pivot(index='Business Group', columns='Method', values='MAPE%')

# Plot heatmaps
plot_heatmap(pivot_mae, "MAE by Business Group and Method")
plot_heatmap(pivot_rmse, "RMSE by Business Group and Method")
plot_heatmap(pivot_mape, "MAPE% by Business Group and Method")

# optional: also print pivot tables to inspect numbers
print("\nðŸ”¹ MAE by Business Group and Method:")
print(pivot_mae)
print("\nðŸ”¹ RMSE by Business Group and Method:")
print(pivot_rmse)
print("\nðŸ”¹ MAPE% by Business Group and Method:")
print(pivot_mape)

















































import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# -----------------------
# PARAMETERS
# -----------------------
BASE_MONTH_HC = 229568
FORECAST_START = "2025-04-01"
FORECAST_END   = "2025-12-01"
DIVIDE_BY_100  = True
ROLL_WINDOW = 3
# -----------------------

# Prepare df
df['MONTH'] = pd.to_datetime(df['MONTH']).dt.to_period('M').dt.to_timestamp()
df['YEAR']  = df['MONTH'].dt.year

forecast_index = pd.date_range(start=FORECAST_START, end=FORECAST_END, freq="MS")
groups = df['BUSINESS_GROUPS_TA'].unique()

all_rows = []

for g in groups:
    grp = df[df['BUSINESS_GROUPS_TA'] == g].copy().set_index('MONTH').sort_index()

    # smoothing: SMA, EMA, Rolling Median, Wilder (alpha = 1/N)
    grp['SMA3'] = grp['MONTHLY_ATTRITION_RATE'].rolling(window=ROLL_WINDOW).mean()
    grp['EMA3'] = grp['MONTHLY_ATTRITION_RATE'].ewm(span=ROLL_WINDOW, adjust=False).mean()
    grp['MED3'] = grp['MONTHLY_ATTRITION_RATE'].rolling(window=ROLL_WINDOW).median()
    alpha_wilder = 1.0 / ROLL_WINDOW
    grp['WILDER3'] = grp['MONTHLY_ATTRITION_RATE'].ewm(alpha=alpha_wilder, adjust=False).mean()

    # last-available fallback utility
    def last_valid(col):
        if (col in grp.columns) and (not grp[col].empty):
            v = grp[col].iloc[-1]
            if not pd.isna(v):
                return v
        # fallback to last observed raw rate
        if (not grp['MONTHLY_ATTRITION_RATE'].empty):
            return grp['MONTHLY_ATTRITION_RATE'].iloc[-1]
        return np.nan

    last_sma = last_valid('SMA3')
    last_ema = last_valid('EMA3')
    last_med = last_valid('MED3')
    last_wil = last_valid('WILDER3')

    # last known headcount BEFORE forecast start (safe fallbacks)
    pre_forecast_hc_series = grp[grp.index < pd.to_datetime(FORECAST_START)]['HEADCOUNT']
    if not pre_forecast_hc_series.empty:
        last_known_hc = pre_forecast_hc_series.iloc[-1]
    else:
        last_known_hc = grp['HEADCOUNT'].iloc[-1] if (not grp['HEADCOUNT'].empty) else BASE_MONTH_HC

    # build rows for every forecast_index month (keeps actuals if present)
    for fut_ts in forecast_index:
        # actuals if present in original group
        if fut_ts in grp.index:
            act_rate  = grp.at[fut_ts, 'MONTHLY_ATTRITION_RATE'] if 'MONTHLY_ATTRITION_RATE' in grp.columns else np.nan
            act_exits = grp.at[fut_ts, 'VOLUNTARY_EXITS'] if 'VOLUNTARY_EXITS' in grp.columns else np.nan
            act_hc    = grp.at[fut_ts, 'HEADCOUNT'] if 'HEADCOUNT' in grp.columns else np.nan
        else:
            act_rate  = np.nan
            act_exits = np.nan
            act_hc    = np.nan

        # get smoothed value at that date if exists else use last_valid
        def get_smoothed(col, last_val):
            if (fut_ts in grp.index) and (col in grp.columns) and (not pd.isna(grp.at[fut_ts, col])):
                return grp.at[fut_ts, col]
            return last_val

        fut_rate_sma = get_smoothed('SMA3', last_sma)
        fut_rate_ema = get_smoothed('EMA3', last_ema)
        fut_rate_med = get_smoothed('MED3', last_med)
        fut_rate_wil = get_smoothed('WILDER3', last_wil)

        # compute counts safely
        def to_count(rate):
            if pd.isna(rate):
                return np.nan
            return (rate / 100.0 * last_known_hc) if DIVIDE_BY_100 else (rate * last_known_hc)

        fut_count_sma = to_count(fut_rate_sma)
        fut_count_ema = to_count(fut_rate_ema)
        fut_count_med = to_count(fut_rate_med)
        fut_count_wil = to_count(fut_rate_wil)

        # --- ROW: using the exact naming you had previously ---
        row = {
            "Future Month": fut_ts,                       # timestamp (month start)
            "Business Group": g,
            "Fut Vol Attr. Month %_sma": round(fut_rate_sma, 4) if not pd.isna(fut_rate_sma) else np.nan,
            "Fut Vol Attr. Month %_ema": round(fut_rate_ema, 4) if not pd.isna(fut_rate_ema) else np.nan,
            "Fut Vol Attr. Month %_med": round(fut_rate_med, 4) if not pd.isna(fut_rate_med) else np.nan,
            "Fut Vol Attr. Month %_wilder": round(fut_rate_wil, 4) if not pd.isna(fut_rate_wil) else np.nan,
            "Base Month HC": int(last_known_hc) if not pd.isna(last_known_hc) else np.nan,
            "Fut Vol. Attr Count_sma": int(round(fut_count_sma)) if (not pd.isna(fut_count_sma)) else np.nan,
            "Fut Vol. Attr Count_ema": int(round(fut_count_ema)) if (not pd.isna(fut_count_ema)) else np.nan,
            "Fut Vol. Attr Count_med": int(round(fut_count_med)) if (not pd.isna(fut_count_med)) else np.nan,
            "Fut Vol. Attr Count_wilder": int(round(fut_count_wil)) if (not pd.isna(fut_count_wil)) else np.nan,
            # actuals (kept exact naming)
            "Act Vol Attr. Month %": round(act_rate,4) if not pd.isna(act_rate) else np.nan,
            "Act Vol Attr Count": int(act_exits) if not pd.isna(act_exits) else np.nan,
            "Actual Headcount": int(act_hc) if not pd.isna(act_hc) else np.nan,
        }
        all_rows.append(row)

# Combined forecast DataFrame (names preserved)
forecast_df = pd.DataFrame(all_rows)

# -----------------------
# PLOTTING (per-group) - solid before forecast, dotted for forecast window
# -----------------------
# Prepare actual series (rename to match forecast column structure)
actual_df = df[['MONTH','BUSINESS_GROUPS_TA','MONTHLY_ATTRITION_RATE']].rename(
    columns={'MONTH':'Future Month','BUSINESS_GROUPS_TA':'Business Group','MONTHLY_ATTRITION_RATE':'Attrition Rate'})
actual_df['Type'] = 'Actual'

# helper to make forecast subsets (keeps naming consistent)
def make_forecast_subset(col, label):
    tmp = forecast_df[['Future Month','Business Group',col]].rename(columns={col:'Attrition Rate'})
    tmp['Type'] = label
    return tmp

forecast_sma = make_forecast_subset('Fut Vol Attr. Month %_sma','Forecast_SMA')
forecast_ema = make_forecast_subset('Fut Vol Attr. Month %_ema','Forecast_EMA')
forecast_med = make_forecast_subset('Fut Vol Attr. Month %_med','Forecast_MED')
forecast_wilder = make_forecast_subset('Fut Vol Attr. Month %_wilder','Forecast_WILDER')

plot_df = pd.concat([actual_df, forecast_sma, forecast_ema, forecast_med, forecast_wilder], ignore_index=True)
plot_df['Future Month'] = pd.to_datetime(plot_df['Future Month'])

# plotting per-group
plt.figure(figsize=(16,8))
forecast_start_dt = pd.to_datetime(FORECAST_START)

colors = {
    'Actual': 'black',
    'Forecast_SMA': 'blue',
    'Forecast_EMA': 'green',
    'Forecast_MED': 'orange',
    'Forecast_WILDER': 'purple'
}

for g in groups:
    sub = plot_df[plot_df['Business Group'] == g].sort_values('Future Month')

    for typ in ['Actual','Forecast_SMA','Forecast_EMA','Forecast_MED','Forecast_WILDER']:
        data = sub[sub['Type'] == typ]
        if data.empty:
            continue
        # historical (solid)
        hist = data[data['Future Month'] < forecast_start_dt]
        if not hist.empty:
            plt.plot(hist['Future Month'], hist['Attrition Rate'], color=colors[typ], label=f"{g} {typ} (Hist)")
        # forecast (dotted)
        fore = data[data['Future Month'] >= forecast_start_dt]
        if not fore.empty:
            plt.plot(fore['Future Month'], fore['Attrition Rate'], linestyle=':', color=colors[typ], label=f"{g} {typ} (Forecast)")

plt.axvline(forecast_start_dt, color='gray', linestyle=':', linewidth=1)
plt.title("Attrition Rate â€” Actual vs SMA/EMA/Median/Wilder (solid=hist, dotted=forecast)")
plt.xlabel("Month")
plt.ylabel("Attrition Rate (%)")
plt.legend(ncol=2, fontsize='small')
plt.grid(True)
plt.tight_layout()
plt.show()

# -----------------------
# OVERALL AGGREGATED TOTALS (weighted by headcount), preserving original naming & style
# -----------------------
# Actual overall (weighted)
actual_tot = df.groupby('MONTH').apply(
    lambda d: pd.Series({
        'total_exits': (d['MONTHLY_ATTRITION_RATE'] / 100.0 * d['HEADCOUNT']).sum(),
        'total_hc'   : d['HEADCOUNT'].sum()
    })
).reset_index().rename(columns={'MONTH':'Future Month'})
actual_tot['overall_rate'] = actual_tot['total_exits'] / actual_tot['total_hc'] * 100.0
actual_tot['Type'] = 'Actual_Total'
actual_tot = actual_tot[['Future Month','overall_rate','Type']].rename(columns={'overall_rate':'Rate'})

# Forecast totals aggregating the forecast_df counts (uses Base Month HC for denominator)
forecast_tot_sma = forecast_df.groupby('Future Month').agg({
    'Fut Vol. Attr Count_sma': 'sum',
    'Base Month HC': 'sum'
}).reset_index()
forecast_tot_sma['Rate_sma'] = (forecast_tot_sma['Fut Vol. Attr Count_sma'] / forecast_tot_sma['Base Month HC']) * 100.0
forecast_tot_sma['Type'] = 'Forecast_Total_SMA'
forecast_tot_sma = forecast_tot_sma[['Future Month','Rate_sma','Type']].rename(columns={'Rate_sma':'Rate'})

forecast_tot_ema = forecast_df.groupby('Future Month').agg({
    'Fut Vol. Attr Count_ema': 'sum',
    'Base Month HC': 'sum'
}).reset_index()
forecast_tot_ema['Rate_ema'] = (forecast_tot_ema['Fut Vol. Attr Count_ema'] / forecast_tot_ema['Base Month HC']) * 100.0
forecast_tot_ema['Type'] = 'Forecast_Total_EMA'
forecast_tot_ema = forecast_tot_ema[['Future Month','Rate_ema','Type']].rename(columns={'Rate_ema':'Rate'})

forecast_tot_med = forecast_df.groupby('Future Month').agg({
    'Fut Vol. Attr Count_med': 'sum',
    'Base Month HC': 'sum'
}).reset_index()
forecast_tot_med['Rate_med'] = (forecast_tot_med['Fut Vol. Attr Count_med'] / forecast_tot_med['Base Month HC']) * 100.0
forecast_tot_med['Type'] = 'Forecast_Total_MED'
forecast_tot_med = forecast_tot_med[['Future Month','Rate_med','Type']].rename(columns={'Rate_med':'Rate'})

forecast_tot_wilder = forecast_df.groupby('Future Month').agg({
    'Fut Vol. Attr Count_wilder': 'sum',
    'Base Month HC': 'sum'
}).reset_index()
forecast_tot_wilder['Rate_wilder'] = (forecast_tot_wilder['Fut Vol. Attr Count_wilder'] / forecast_tot_wilder['Base Month HC']) * 100.0
forecast_tot_wilder['Type'] = 'Forecast_Total_WILDER'
forecast_tot_wilder = forecast_tot_wilder[['Future Month','Rate_wilder','Type']].rename(columns={'Rate_wilder':'Rate'})

# combine totals and plot
tot_plot = pd.concat([actual_tot, forecast_tot_sma, forecast_tot_ema, forecast_tot_med, forecast_tot_wilder], ignore_index=True)
tot_plot['Future Month'] = pd.to_datetime(tot_plot['Future Month'])
tot_plot['ForecastFlag'] = tot_plot['Future Month'] >= forecast_start_dt

plt.figure(figsize=(12,6))

def draw_total_line(type_name, color, label):
    hist = tot_plot[(tot_plot['Type']==type_name) & (~tot_plot['ForecastFlag'])].sort_values('Future Month')
    fore = tot_plot[(tot_plot['Type']==type_name) & (tot_plot['ForecastFlag'])].sort_values('Future Month')
    if not hist.empty:
        plt.plot(hist['Future Month'], hist['Rate'], color=color, label=f"{label} (Hist)", linewidth=2)
    if not fore.empty:
        plt.plot(fore['Future Month'], fore['Rate'], color=color, linestyle=':', label=f"{label} (Forecast)", linewidth=2)

draw_total_line('Actual_Total','black','Overall Actual')
draw_total_line('Forecast_Total_SMA','blue','Overall SMA')
draw_total_line('Forecast_Total_EMA','green','Overall EMA')
draw_total_line('Forecast_Total_MED','orange','Overall MEDIAN')
draw_total_line('Forecast_Total_WILDER','purple','Overall WILDER')

plt.axvline(forecast_start_dt, color='gray', linestyle=':', linewidth=1)
plt.title("Overall Attrition Rate (weighted) â€” Actual vs SMA/EMA/Median/Wilder")
plt.xlabel("Month")
plt.ylabel("Attrition Rate (%)")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()










































from sklearn.metrics import mean_absolute_error, mean_squared_error
import numpy as np

# ensure datetime
forecast_df['Future Month'] = pd.to_datetime(forecast_df['Future Month'])

# take only rows where actual and forecasts both exist
mask_sma = (~forecast_df['Act Vol Attr. Month %'].isna()) & (~forecast_df['Fut Vol Attr. Month %_sma'].isna())
mask_ema = (~forecast_df['Act Vol Attr. Month %'].isna()) & (~forecast_df['Fut Vol Attr. Month %_ema'].isna())

# actuals and predictions
actual_sma = forecast_df.loc[mask_sma, 'Act Vol Attr. Month %']
pred_sma = forecast_df.loc[mask_sma, 'Fut Vol Attr. Month %_sma']

actual_ema = forecast_df.loc[mask_ema, 'Act Vol Attr. Month %']
pred_ema = forecast_df.loc[mask_ema, 'Fut Vol Attr. Month %_ema']



mae_sma = mean_absolute_error(actual_sma, pred_sma)
rmse_sma = mean_squared_error(actual_sma, pred_sma, squared=False)  # RMSE
mape_sma = np.mean(np.abs((actual_sma - pred_sma) / actual_sma)) * 100

print("SMA Forecast Performance:")
print(f"MAE  : {mae_sma:.4f}")
print(f"RMSE : {rmse_sma:.4f}")
print(f"MAPE : {mape_sma:.2f}%")



mae_ema = mean_absolute_error(actual_ema, pred_ema)
rmse_ema = mean_squared_error(actual_ema, pred_ema, squared=False)  # RMSE
mape_ema = np.mean(np.abs((actual_ema - pred_ema) / actual_ema)) * 100

print("EMA Forecast Performance:")
print(f"MAE  : {mae_ema:.4f}")
print(f"RMSE : {rmse_ema:.4f}")
print(f"MAPE : {mape_ema:.2f}%")


metrics_by_group = []
for g in forecast_df['Business Group'].unique():
    df_g = forecast_df[forecast_df['Business Group']==g]
    mask_sma = (~df_g['Act Vol Attr. Month %'].isna()) & (~df_g['Fut Vol Attr. Month %_sma'].isna())
    mask_ema = (~df_g['Act Vol Attr. Month %'].isna()) & (~df_g['Fut Vol Attr. Month %_ema'].isna())
    if mask_sma.any():
        mae_sma = mean_absolute_error(df_g.loc[mask_sma,'Act Vol Attr. Month %'], df_g.loc[mask_sma,'Fut Vol Attr. Month %_sma'])
        rmse_sma = mean_squared_error(df_g.loc[mask_sma,'Act Vol Attr. Month %'], df_g.loc[mask_sma,'Fut Vol Attr. Month %_sma'], squared=False)
    else:
        mae_sma, rmse_sma = np.nan, np.nan
    if mask_ema.any():
        mae_ema = mean_absolute_error(df_g.loc[mask_ema,'Act Vol Attr. Month %'], df_g.loc[mask_ema,'Fut Vol Attr. Month %_ema'])
        rmse_ema = mean_squared_error(df_g.loc[mask_ema,'Act Vol Attr. Month %'], df_g.loc[mask_ema,'Fut Vol Attr. Month %_ema'], squared=False)
    else:
        mae_ema, rmse_ema = np.nan, np.nan
    metrics_by_group.append([g, mae_sma, rmse_sma, mae_ema, rmse_ema])

metrics_df = pd.DataFrame(metrics_by_group, columns=['Business Group','MAE_SMA','RMSE_SMA','MAE_EMA','RMSE_EMA'])
print(metrics_df)




import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

FORECAST_START = pd.to_datetime("2025-04-01")
FORECAST_END   = pd.to_datetime("2025-12-01")

# Assuming forecast_df already built
plot_df = pd.melt(
    forecast_df,
    id_vars=['Future Month','Business Group'],
    value_vars=['Act Vol Attr. Month %',
                'Fut Vol Attr. Month %_sma',
                'Fut Vol Attr. Month %_ema'],
    var_name='Metric', value_name='Value'
)

metric_map = {
    'Act Vol Attr. Month %': 'Actual',
    'Fut Vol Attr. Month %_sma': 'SMA Forecast',
    'Fut Vol Attr. Month %_ema': 'EMA Forecast'
}
plot_df['Metric'] = plot_df['Metric'].map(metric_map)
plot_df['Future Month'] = pd.to_datetime(plot_df['Future Month'])

# add Period column
plot_df['Period'] = np.where(plot_df['Future Month'] < FORECAST_START, 'Historical','Forecast')



plt.ion()  # interactive mode ON

groups = plot_df['Business Group'].unique()
colors = {'Actual':'black', 'SMA Forecast':'blue', 'EMA Forecast':'green'}

plt.figure(figsize=(16,8))

for g in groups:
    sub = plot_df[plot_df['Business Group']==g]
    for metric in ['Actual','SMA Forecast','EMA Forecast']:
        s_hist = sub[(sub['Metric']==metric) & (sub['Period']=='Historical')].sort_values('Future Month')
        s_fore = sub[(sub['Metric']==metric) & (sub['Period']=='Forecast')].sort_values('Future Month')

        # plot solid line for historical
        if not s_hist.empty:
            plt.plot(s_hist['Future Month'], s_hist['Value'],
                     label=f"{g} {metric} (Hist)", 
                     color=colors[metric], linestyle='-')

        # plot dotted line for forecast
        if not s_fore.empty:
            plt.plot(s_fore['Future Month'], s_fore['Value'],
                     label=f"{g} {metric} (Forecast)", 
                     color=colors[metric], linestyle=':')

plt.axvline(FORECAST_START, color='gray', linestyle='--', linewidth=1)
plt.title("Attrition Rate â€” Actual vs SMA & EMA (solid = past, dotted = forecast)")
plt.xlabel("Month")
plt.ylabel("Attrition Rate (%)")
plt.legend(ncol=3, fontsize='small')
plt.grid(True)
plt.tight_layout()
plt.show()



from sklearn.metrics import mean_absolute_error, mean_squared_error

# Compute metrics per group
metrics_list = []
for g in groups:
    sub = forecast_df[forecast_df['Business Group']==g]
    # actual vs sma
    mask = ~sub['Act Vol Attr. Month %'].isna() & ~sub['Fut Vol Attr. Month %_sma'].isna()
    mae_sma = mean_absolute_error(sub.loc[mask,'Act Vol Attr. Month %'], sub.loc[mask,'Fut Vol Attr. Month %_sma'])
    rmse_sma = np.sqrt(mean_squared_error(sub.loc[mask,'Act Vol Attr. Month %'], sub.loc[mask,'Fut Vol Attr. Month %_sma']))

    # actual vs ema
    mask2 = ~sub['Act Vol Attr. Month %'].isna() & ~sub['Fut Vol Attr. Month %_ema'].isna()
    mae_ema = mean_absolute_error(sub.loc[mask2,'Act Vol Attr. Month %'], sub.loc[mask2,'Fut Vol Attr. Month %_ema'])
    rmse_ema = np.sqrt(mean_squared_error(sub.loc[mask2,'Act Vol Attr. Month %'], sub.loc[mask2,'Fut Vol Attr. Month %_ema']))

    metrics_list.append([g,mae_sma,rmse_sma,mae_ema,rmse_ema])

metrics_df = pd.DataFrame(metrics_list, columns=['Business Group','MAE_SMA','RMSE_SMA','MAE_EMA','RMSE_EMA'])



x = np.arange(len(metrics_df))
width = 0.2

plt.figure(figsize=(12,6))
plt.bar(x - width, metrics_df['MAE_SMA'], width, label='MAE SMA', color='blue', alpha=0.6)
plt.bar(x,         metrics_df['MAE_EMA'], width, label='MAE EMA', color='green', alpha=0.6)
plt.bar(x + width, metrics_df['RMSE_SMA'], width, label='RMSE SMA', color='blue', alpha=0.3)
plt.bar(x + 2*width, metrics_df['RMSE_EMA'], width, label='RMSE EMA', color='green', alpha=0.3)

plt.xticks(x + width/2, metrics_df['Business Group'], rotation=45)
plt.title("Error Metrics by Business Group")
plt.ylabel("Error Value")
plt.legend()
plt.tight_layout()
plt.show()




























# ----------------------------
# 1. CREATE FULL GRID (MONTH Ã— BUSINESS GROUP)
# ----------------------------
# all months you want to cover
months = pd.date_range(start=FORECAST_START, end=FORECAST_END, freq='MS')  # MS = Month Start

# all business groups from your df
business_groups = df['BUSINESS_GROUPS_TA'].unique()

# create full index
full_index = pd.MultiIndex.from_product(
    [months, business_groups],
    names=['Future Month', 'Business Group']
)

full_df = pd.DataFrame(index=full_index).reset_index()  # DataFrame with Future Month + Business Group




# ensure your forecast_df Future Month is datetime
forecast_df['Future Month'] = pd.to_datetime(forecast_df['Future Month'])

# merge full grid with forecast_df
forecast_df = pd.merge(
    full_df,
    forecast_df,
    on=['Future Month','Business Group'],
    how='left'
)
























# =========================
# 1. CALCULATE SMA & EMA FOR FULL DATASET
# =========================
# we assume df contains all months including pre-forecast
df_sorted = df.sort_values(['BUSINESS_GROUPS_TA','MONTH'])

# SMA & EMA on full series (including historical)
df_sorted['SMA_3'] = df_sorted.groupby('BUSINESS_GROUPS_TA')['MONTHLY_ATTRITION_RATE']\
    .transform(lambda x: x.rolling(window=3, min_periods=1).mean())
df_sorted['EMA_3'] = df_sorted.groupby('BUSINESS_GROUPS_TA')['MONTHLY_ATTRITION_RATE']\
    .transform(lambda x: x.ewm(span=3, adjust=False).mean())

# Build historical SMA/EMA dataframe
hist_sma = df_sorted[['MONTH','BUSINESS_GROUPS_TA','SMA_3']].rename(
    columns={'MONTH':'Future Month','BUSINESS_GROUPS_TA':'Business Group','SMA_3':'Attrition Rate'})
hist_sma['Type'] = 'Forecast_SMA'

hist_ema = df_sorted[['MONTH','BUSINESS_GROUPS_TA','EMA_3']].rename(
    columns={'MONTH':'Future Month','BUSINESS_GROUPS_TA':'Business Group','EMA_3':'Attrition Rate'})
hist_ema['Type'] = 'Forecast_EMA'

# Actual
actual_df = df_sorted[['MONTH','BUSINESS_GROUPS_TA','MONTHLY_ATTRITION_RATE']].rename(
    columns={'MONTH':'Future Month','BUSINESS_GROUPS_TA':'Business Group','MONTHLY_ATTRITION_RATE':'Attrition Rate'})
actual_df['Type'] = 'Actual'

# Combine all
plot_df = pd.concat([actual_df, hist_sma, hist_ema], ignore_index=True)
plot_df['Future Month'] = pd.to_datetime(plot_df['Future Month'])

# Flag forecast months
plot_df['ForecastFlag'] = (plot_df['Future Month'] >= pd.to_datetime(FORECAST_START))

# =========================
# 2. PLOT PER-GROUP
# =========================
plt.figure(figsize=(16,8))
for g in groups:
    sub = plot_df[plot_df['Business Group'] == g].sort_values('Future Month')

    # function to draw hist and forecast
    def draw_line(sub, type_name, color, label):
        hist = sub[(sub['Type']==type_name) & (~sub['ForecastFlag'])]
        fore = sub[(sub['Type']==type_name) & (sub['ForecastFlag'])]
        if not hist.empty:
            plt.plot(hist['Future Month'], hist['Attrition Rate'],
                     color=color, label=f"{g} {label} Hist")
        if not fore.empty:
            plt.plot(fore['Future Month'], fore['Attrition Rate'],
                     color=color, linestyle=':', label=f"{g} {label} Forecast")

    draw_line(sub,'Actual','black','Actual')
    draw_line(sub,'Forecast_SMA','blue','SMA')
    draw_line(sub,'Forecast_EMA','green','EMA')

plt.axvline(pd.to_datetime(FORECAST_START), color='gray', linestyle=':', linewidth=1)
plt.title("Attrition Rate â€” Actual vs SMA vs EMA (solid=hist, dotted=forecast)")
plt.xlabel("Month")
plt.ylabel("Attrition Rate (%)")
plt.legend(ncol=2, fontsize='small')
plt.grid(True)
plt.tight_layout()
plt.show()
























# -----------------------
# CREATE PLOT_DF WITH FORECAST FLAG
# -----------------------
plot_df = pd.concat([actual_df, forecast_sma, forecast_ema], ignore_index=True)
plot_df['Future Month'] = pd.to_datetime(plot_df['Future Month'])
plot_df['ForecastFlag'] = plot_df['Future Month'] >= pd.to_datetime(FORECAST_START)

plt.figure(figsize=(16,8))
for g in groups:
    sub = plot_df[plot_df['Business Group'] == g].sort_values('Future Month')

    # ---- ACTUAL ----
    a_hist = sub[(sub['Type'] == 'Actual') & (~sub['ForecastFlag'])]
    a_fore = sub[(sub['Type'] == 'Actual') & (sub['ForecastFlag'])]

    if not a_hist.empty:
        plt.plot(a_hist['Future Month'], a_hist['Attrition Rate'],
                 color='black', label=f"{g} Actual (Hist)")
    if not a_fore.empty:
        plt.plot(a_fore['Future Month'], a_fore['Attrition Rate'],
                 color='black', linestyle=':', label=f"{g} Actual (Forecast)")

    # ---- SMA ----
    s_hist = sub[(sub['Type'] == 'Forecast_SMA') & (~sub['ForecastFlag'])]
    s_fore = sub[(sub['Type'] == 'Forecast_SMA') & (sub['ForecastFlag'])]

    if not s_hist.empty:
        plt.plot(s_hist['Future Month'], s_hist['Attrition Rate'],
                 color='blue', label=f"{g} SMA (Hist)")
    if not s_fore.empty:
        plt.plot(s_fore['Future Month'], s_fore['Attrition Rate'],
                 color='blue', linestyle=':', label=f"{g} SMA (Forecast)")

    # ---- EMA ----
    e_hist = sub[(sub['Type'] == 'Forecast_EMA') & (~sub['ForecastFlag'])]
    e_fore = sub[(sub['Type'] == 'Forecast_EMA') & (sub['ForecastFlag'])]

    if not e_hist.empty:
        plt.plot(e_hist['Future Month'], e_hist['Attrition Rate'],
                 color='green', label=f"{g} EMA (Hist)")
    if not e_fore.empty:
        plt.plot(e_fore['Future Month'], e_fore['Attrition Rate'],
                 color='green', linestyle=':', label=f"{g} EMA (Forecast)")

plt.axvline(pd.to_datetime(FORECAST_START), color='gray', linestyle=':', linewidth=1)
plt.title("Attrition Rate â€” Actual vs SMA vs EMA (solid=hist, dotted=forecast)")
plt.xlabel("Month")
plt.ylabel("Attrition Rate (%)")
plt.legend(ncol=2, fontsize='small')
plt.grid(True)
plt.tight_layout()
plt.show()


# -----------------------
# OVERALL TOTALS WITH FORECAST FLAG
# -----------------------
tot_plot['ForecastFlag'] = tot_plot['Future Month'] >= pd.to_datetime(FORECAST_START)

plt.figure(figsize=(12,5))

# --- Actual Total ---
act_hist = tot_plot[(tot_plot['Type']=='Actual_Total') & (~tot_plot['ForecastFlag'])]
act_fore = tot_plot[(tot_plot['Type']=='Actual_Total') & (tot_plot['ForecastFlag'])]

if not act_hist.empty:
    plt.plot(act_hist['Future Month'], act_hist['Rate'],
             color='black', label='Overall Actual (Hist)', linewidth=2)
if not act_fore.empty:
    plt.plot(act_fore['Future Month'], act_fore['Rate'],
             color='black', linestyle=':', label='Overall Actual (Forecast)', linewidth=2)

# --- SMA Total ---
sma_hist = tot_plot[(tot_plot['Type']=='Forecast_Total_SMA') & (~tot_plot['ForecastFlag'])]
sma_fore = tot_plot[(tot_plot['Type']=='Forecast_Total_SMA') & (tot_plot['ForecastFlag'])]

if not sma_hist.empty:
    plt.plot(sma_hist['Future Month'], sma_hist['Rate'],
             color='blue', label='Overall SMA (Hist)', linewidth=2)
if not sma_fore.empty:
    plt.plot(sma_fore['Future Month'], sma_fore['Rate'],
             color='blue', linestyle=':', label='Overall SMA (Forecast)', linewidth=2)

# --- EMA Total ---
ema_hist = tot_plot[(tot_plot['Type']=='Forecast_Total_EMA') & (~tot_plot['ForecastFlag'])]
ema_fore = tot_plot[(tot_plot['Type']=='Forecast_Total_EMA') & (tot_plot['ForecastFlag'])]

if not ema_hist.empty:
    plt.plot(ema_hist['Future Month'], ema_hist['Rate'],
             color='green', label='Overall EMA (Hist)', linewidth=2)
if not ema_fore.empty:
    plt.plot(ema_fore['Future Month'], ema_fore['Rate'],
             color='green', linestyle=':', label='Overall EMA (Forecast)', linewidth=2)

plt.axvline(pd.to_datetime(FORECAST_START), color='gray', linestyle=':', linewidth=1)
plt.title("Overall Attrition Rate (weighted) â€” Actual vs SMA vs EMA (solid=hist, dotted=forecast)")
plt.xlabel("Month")
plt.ylabel("Attrition Rate (%)")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

































import matplotlib.pyplot as plt
import pandas as pd

# Set forecast start and end
FORECAST_START = pd.to_datetime("2025-04-01")
FORECAST_END   = pd.to_datetime("2025-12-01")

# ----- Create forecast flag -----
plot_df['ForecastFlag'] = plot_df['Future Month'] >= FORECAST_START

plt.figure(figsize=(15,7))

for g in plot_df['Business Group'].unique():
    sub = plot_df[plot_df['Business Group'] == g]
    
    # --- Actual ---
    actual = sub[sub['Type'] == 'Actual']
    plt.plot(actual['Future Month'], actual['Attrition Rate'],
             label=f"{g} Actual", color='black')   # solid line
    
    # --- SMA ---
    sma_hist = sub[(sub['Type'] == 'SMA') & (sub['ForecastFlag'] == False)]
    sma_fore = sub[(sub['Type'] == 'SMA') & (sub['ForecastFlag'] == True)]
    
    plt.plot(sma_hist['Future Month'], sma_hist['Attrition Rate'],
             label=f"{g} SMA (Hist)", color='blue')  # solid
    plt.plot(sma_fore['Future Month'], sma_fore['Attrition Rate'],
             linestyle=':', color='blue', label=f"{g} SMA (Forecast)")  # dotted
    
    # --- EMA ---
    ema_hist = sub[(sub['Type'] == 'EMA') & (sub['ForecastFlag'] == False)]
    ema_fore = sub[(sub['Type'] == 'EMA') & (sub['ForecastFlag'] == True)]
    
    plt.plot(ema_hist['Future Month'], ema_hist['Attrition Rate'],
             label=f"{g} EMA (Hist)", color='green')  # solid
    plt.plot(ema_fore['Future Month'], ema_fore['Attrition Rate'],
             linestyle=':', color='green', label=f"{g} EMA (Forecast)")  # dotted

# vertical line at forecast start
plt.axvline(FORECAST_START, color='gray', linestyle='--', label='Forecast Start')

plt.title("Attrition Rate: Actual vs SMA vs EMA (solid = past, dotted = forecast)")
plt.xlabel("Month")
plt.ylabel("Attrition Rate %")
plt.legend()
plt.grid()
plt.show()


















import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# -----------------------
# PARAMETERS (edit if needed)
# -----------------------
BASE_MONTH_HC = 229568            # fallback if group HC missing
FORECAST_START = "2025-04-01"
FORECAST_END   = "2025-12-01"
DIVIDE_BY_100  = True            # attrition rates are in % (True) or fraction (False)
ROLL_WINDOW = 3                  # SMA/EMA window length
# -----------------------

# ---- Prepare df (match what I saw in your screenshots) ----
# ensure MONTH is month-start timestamps (so comparisons with forecast_index work)
df['MONTH'] = pd.to_datetime(df['MONTH']).dt.to_period('M').dt.to_timestamp()
df['YEAR']  = df['MONTH'].dt.year

forecast_index = pd.date_range(start=FORECAST_START, end=FORECAST_END, freq="MS")
groups = df['BUSINESS_GROUPS_TA'].unique()

all_rows = []

for g in groups:
    grp = df[df['BUSINESS_GROUPS_TA'] == g].copy().set_index('MONTH').sort_index()

    # compute SMA and EMA exactly as requested
    grp['SMA3'] = grp['MONTHLY_ATTRITION_RATE'].rolling(window=ROLL_WINDOW).mean()
    grp['EMA3'] = grp['MONTHLY_ATTRITION_RATE'].ewm(span=ROLL_WINDOW, adjust=False).mean()

    # last available SMA/EMA values (fallbacks if NaN)
    last_sma = grp['SMA3'].iloc[-1] if not grp['SMA3'].empty else np.nan
    last_ema = grp['EMA3'].iloc[-1] if not grp['EMA3'].empty else np.nan

    # fallback if last_sma or last_ema is NaN (not enough history): use last observed rate
    last_observed_rate = grp['MONTHLY_ATTRITION_RATE'].iloc[-1] if not grp['MONTHLY_ATTRITION_RATE'].empty else np.nan
    if pd.isna(last_sma):
        last_sma = last_observed_rate
    if pd.isna(last_ema):
        last_ema = last_observed_rate

    # last known headcount BEFORE forecast start (matches screenshot logic)
    pre_forecast_hc_series = grp[grp.index < pd.to_datetime(FORECAST_START)]['HEADCOUNT']
    if not pre_forecast_hc_series.empty:
        last_known_hc = pre_forecast_hc_series.iloc[-1]
    else:
        # safe fallbacks (grp last hc or global base)
        last_known_hc = grp['HEADCOUNT'].iloc[-1] if (not grp['HEADCOUNT'].empty) else BASE_MONTH_HC

    # build rows for each forecast month (keeping original behavior: still include actuals if present)
    for fut_ts in forecast_index:
        # --- actuals (if available in grp) - EXACTLY like your screenshot ---
        if fut_ts in grp.index:
            act_rate  = grp.at[fut_ts, 'MONTHLY_ATTRITION_RATE'] if 'MONTHLY_ATTRITION_RATE' in grp.columns else np.nan
            act_exits = grp.at[fut_ts, 'VOLUNTARY_EXITS'] if 'VOLUNTARY_EXITS' in grp.columns else np.nan
            act_hc    = grp.at[fut_ts, 'HEADCOUNT'] if 'HEADCOUNT' in grp.columns else np.nan
        else:
            act_rate  = np.nan
            act_exits = np.nan
            act_hc    = np.nan

        # --- Forecast rates (SMA/EMA). If the fut_ts is historical and SMA/EMA exists for that date,
        #     use SMA/EMA value at that fut_ts; otherwise use last_sma/last_ema (the usual forecast).
        if (fut_ts in grp.index) and ('SMA3' in grp.columns) and (not pd.isna(grp.at[fut_ts, 'SMA3'])):
            fut_rate_sma = grp.at[fut_ts, 'SMA3']
        else:
            fut_rate_sma = last_sma

        if (fut_ts in grp.index) and ('EMA3' in grp.columns) and (not pd.isna(grp.at[fut_ts, 'EMA3'])):
            fut_rate_ema = grp.at[fut_ts, 'EMA3']
        else:
            fut_rate_ema = last_ema

        # compute counts (handle NaNs safely)
        if pd.isna(fut_rate_sma):
            fut_count_sma = np.nan
        else:
            fut_count_sma = (fut_rate_sma / 100.0 * last_known_hc) if DIVIDE_BY_100 else (fut_rate_sma * last_known_hc)

        if pd.isna(fut_rate_ema):
            fut_count_ema = np.nan
        else:
            fut_count_ema = (fut_rate_ema / 100.0 * last_known_hc) if DIVIDE_BY_100 else (fut_rate_ema * last_known_hc)

        # Build row (Future Month kept as Timestamp for easier plotting)
        row = {
            "Future Month": fut_ts,                       # timestamp (month start)
            "Business Group": g,
            "Fut Vol Attr. Month %_sma": round(fut_rate_sma, 4) if not pd.isna(fut_rate_sma) else np.nan,
            "Fut Vol Attr. Month %_ema": round(fut_rate_ema, 4) if not pd.isna(fut_rate_ema) else np.nan,
            "Base Month HC": int(last_known_hc) if not pd.isna(last_known_hc) else np.nan,
            "Fut Vol. Attr Count_sma": int(round(fut_count_sma)) if (not pd.isna(fut_count_sma)) else np.nan,
            "Fut Vol. Attr Count_ema": int(round(fut_count_ema)) if (not pd.isna(fut_count_ema)) else np.nan,
            # actuals (keep same logic / formatting as your original)
            "Act Vol Attr. Month %": round(act_rate,4) if not pd.isna(act_rate) else np.nan,
            "Act Vol Attr Count": int(act_exits) if not pd.isna(act_exits) else np.nan,
            "Actual Headcount": int(act_hc) if not pd.isna(act_hc) else np.nan,
        }
        all_rows.append(row)

# Combined forecast DataFrame (SMA & EMA separate)
forecast_df = pd.DataFrame(all_rows)

# -----------------------
# PLOTTING
# 1) Per-group plot: actual (solid) vs SMA (dashed) vs EMA (dashdot)
# 2) Overall total (aggregated across groups) with forecast dashed
# -----------------------

# Prepare actual series (rename to match forecast column structure)
actual_df = df[['MONTH','BUSINESS_GROUPS_TA','MONTHLY_ATTRITION_RATE']].rename(
    columns={'MONTH':'Future Month','BUSINESS_GROUPS_TA':'Business Group','MONTHLY_ATTRITION_RATE':'Attrition Rate'})
actual_df['Type'] = 'Actual'

# prepare forecast sma/ema for plotting
forecast_sma = forecast_df[['Future Month','Business Group','Fut Vol Attr. Month %_sma']].rename(
    columns={'Fut Vol Attr. Month %_sma':'Attrition Rate'})
forecast_sma['Type'] = 'Forecast_SMA'

forecast_ema = forecast_df[['Future Month','Business Group','Fut Vol Attr. Month %_ema']].rename(
    columns={'Fut Vol Attr. Month %_ema':'Attrition Rate'})
forecast_ema['Type'] = 'Forecast_EMA'

plot_df = pd.concat([actual_df, forecast_sma, forecast_ema], ignore_index=True)
plot_df['Future Month'] = pd.to_datetime(plot_df['Future Month'])  # ensure datetime dtype

# Per-group plot (may be many groups; you can filter groups if too crowded)
plt.figure(figsize=(16,8))
for g in groups:
    sub = plot_df[plot_df['Business Group'] == g]
    # Actual
    a = sub[sub['Type'] == 'Actual'].sort_values('Future Month')
    if not a.empty:
        plt.plot(a['Future Month'], a['Attrition Rate'], label=f"{g} Actual")
    # SMA forecast
    s = sub[sub['Type'] == 'Forecast_SMA'].sort_values('Future Month')
    if not s.empty:
        plt.plot(s['Future Month'], s['Attrition Rate'], linestyle='--', label=f"{g} SMA Forecast")
    # EMA forecast
    e = sub[sub['Type'] == 'Forecast_EMA'].sort_values('Future Month')
    if not e.empty:
        plt.plot(e['Future Month'], e['Attrition Rate'], linestyle='-.', label=f"{g} EMA Forecast")

plt.axvline(pd.to_datetime(FORECAST_START), color='gray', linestyle=':', linewidth=1)
plt.title("Attrition Rate â€” Actual (solid) vs Forecast SMA (--) & EMA (-.)")
plt.xlabel("Month")
plt.ylabel("Attrition Rate (%)")
plt.legend(ncol=2, fontsize='small')   # compact legend
plt.grid(True)
plt.tight_layout()
plt.show()

# -----------------------
# Overall aggregated totals plot
# -----------------------
# Compute actual overall (weighted by headcount)
# exits = rate/100 * headcount  -> sum exits / sum hc -> overall rate %
actual_tot = df.groupby('MONTH').apply(
    lambda d: pd.Series({
        'total_exits': (d['MONTHLY_ATTRITION_RATE'] / 100.0 * d['HEADCOUNT']).sum(),
        'total_hc'   : d['HEADCOUNT'].sum()
    })
).reset_index().rename(columns={'MONTH':'Future Month'})

actual_tot['overall_rate'] = actual_tot['total_exits'] / actual_tot['total_hc'] * 100.0
actual_tot['Type'] = 'Actual_Total'
actual_tot = actual_tot[['Future Month','overall_rate','Type']].rename(columns={'overall_rate':'Rate'})

# Forecast totals (sum predicted counts and base HC across groups per month)
# note: forecast_df already repeats Base Month HC per group per month, so summing is fine
forecast_tot_sma = forecast_df.groupby('Future Month').agg({
    'Fut Vol. Attr Count_sma': 'sum',
    'Base Month HC': 'sum'
}).reset_index()
forecast_tot_sma['Rate_sma'] = (forecast_tot_sma['Fut Vol. Attr Count_sma'] / forecast_tot_sma['Base Month HC']) * 100.0
forecast_tot_sma['Type'] = 'Forecast_Total_SMA'
forecast_tot_sma = forecast_tot_sma[['Future Month','Rate_sma','Type']].rename(columns={'Rate_sma':'Rate'})

forecast_tot_ema = forecast_df.groupby('Future Month').agg({
    'Fut Vol. Attr Count_ema': 'sum',
    'Base Month HC': 'sum'
}).reset_index()
forecast_tot_ema['Rate_ema'] = (forecast_tot_ema['Fut Vol. Attr Count_ema'] / forecast_tot_ema['Base Month HC']) * 100.0
forecast_tot_ema['Type'] = 'Forecast_Total_EMA'
forecast_tot_ema = forecast_tot_ema[['Future Month','Rate_ema','Type']].rename(columns={'Rate_ema':'Rate'})

# combine totals
tot_plot = pd.concat([actual_tot, forecast_tot_sma, forecast_tot_ema], ignore_index=True)
tot_plot['Future Month'] = pd.to_datetime(tot_plot['Future Month'])

plt.figure(figsize=(12,5))
act = tot_plot[tot_plot['Type']=='Actual_Total'].sort_values('Future Month')
sma = tot_plot[tot_plot['Type']=='Forecast_Total_SMA'].sort_values('Future Month')
ema = tot_plot[tot_plot['Type']=='Forecast_Total_EMA'].sort_values('Future Month')

if not act.empty:
    plt.plot(act['Future Month'], act['Rate'], label='Overall Actual', linewidth=2)
if not sma.empty:
    plt.plot(sma['Future Month'], sma['Rate'], '--', label='Overall Forecast SMA')
if not ema.empty:
    plt.plot(ema['Future Month'], ema['Rate'], '-.', label='Overall Forecast EMA')

plt.axvline(pd.to_datetime(FORECAST_START), color='gray', linestyle=':', linewidth=1)
plt.title("Overall Attrition Rate (weighted by headcount) â€” Actual vs Forecast")
plt.xlabel("Month")
plt.ylabel("Attrition Rate (%)")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()
