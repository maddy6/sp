
import numpy as np
import pandas as pd
from scipy.special import expit  # Sigmoid function
from scipy.stats import gaussian_kde

# Generate synthetic fraud detection dataset
np.random.seed(42)
n_samples = 5000
scores = np.random.randint(0, 1000, n_samples)
probabilities = scores / 999  
labels = np.random.binomial(1, probabilities)

# Create DataFrame
df = pd.DataFrame({"score": scores, "label": labels})

# Custom Sigmoid Score Transformation
def sigmoid_transform(score, a=0.02, b=-5):
    return expit(a * score + b)

df["sigmoid_scaled"] = sigmoid_transform(df["score"])

# Tail Boosting Using Fraud Quantiles
gamma = 1.2  
df["tail_boosted"] = df["score"] ** gamma  

# Fraud Density Adjustment Using KDE
fraud_scores = df[df["label"] == 1]["score"]
kde = gaussian_kde(fraud_scores)
df["density_adjusted"] = kde(df["score"])

# Adaptive Mean Reversion (Bayesian Smoothing)
fraud_mean = df[df["label"] == 1]["score"].mean()
lambda_factor = 0.7  
df["bayesian_smoothed"] = lambda_factor * df["score"] + (1 - lambda_factor) * fraud_mean

# Dynamic Score Re-Weighting (Gradient-Based)
eta = 0.1
gradient = np.gradient(df["score"])
df["gradient_scaled"] = df["score"] + eta * gradient

# Display results
print(df.head())





import numpy as np
import pandas as pd
from scipy.optimize import minimize

# Generate synthetic fraud detection dataset
np.random.seed(42)
n_samples = 5000
scores = np.random.randint(0, 1000, n_samples)
probabilities = scores / 999  
labels = np.random.binomial(1, probabilities)

# Create DataFrame
df = pd.DataFrame({"score": scores, "label": labels})

# Compute means and variances
fraud_scores = df[df["label"] == 1]["score"]
all_scores = df["score"]

mean_fraud = fraud_scores.mean()
var_fraud = fraud_scores.var()
var_all = all_scores.var()

# 1️⃣ Variance Ratio Method
lambda_var = var_all / (var_all + var_fraud)

# 2️⃣ Maximum Likelihood Estimation (MLE)
def mle_loss(lambda_factor):
    smoothed_scores = lambda_factor * df["score"] + (1 - lambda_factor) * mean_fraud
    residuals = df["score"] - smoothed_scores
    return np.var(residuals)  # Minimize residual variance

lambda_mle = minimize(mle_loss, x0=0.5, bounds=[(0, 1)]).x[0]

# 3️⃣ Bayesian Smoothing with Optimal λ
df["bayesian_smooth_var"] = lambda_var * df["score"] + (1 - lambda_var) * mean_fraud
df["bayesian_smooth_mle"] = lambda_mle * df["score"] + (1 - lambda_mle) * mean_fraud

# Display results
print(f"Optimal Lambda (Variance Method): {lambda_var:.4f}")
print(f"Optimal Lambda (MLE): {lambda_mle:.4f}")
print(df.head())



