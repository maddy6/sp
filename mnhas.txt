# install if needed
# pip install pymc arviz matplotlib

import pandas as pd
import numpy as np
import pymc as pm
import arviz as az
import matplotlib.pyplot as plt

# -----------------------------------------
# 1. Load your data
# -----------------------------------------
df = pd.read_excel('monthwise_updated_attrition_dataset.xlsx')

# Sort by group and month
df = df.sort_values(['BUSINESS_GROUPS_TA','MONTH']).reset_index(drop=True)

# Basic features
groups = df['BUSINESS_GROUPS_TA'].unique()
n_groups = len(groups)
group_idx = df['BUSINESS_GROUPS_TA'].astype('category').cat.codes.values

# Observed counts and exposure
exits = df['VOLUNTARY_EXITS'].values
headcount = df['HEADCOUNT'].values

# -----------------------------------------
# 2. Build hierarchical Bayesian model
# -----------------------------------------
with pm.Model() as hier_model:
    # Hyperpriors for group-level attrition rate (Gamma hyperprior)
    alpha_hyper = pm.HalfNormal('alpha_hyper', sigma=2.0)
    beta_hyper  = pm.HalfNormal('beta_hyper', sigma=2.0)
    
    # Group-level attrition rates (latent)
    theta_group = pm.Gamma('theta_group', alpha=alpha_hyper, beta=beta_hyper, shape=n_groups)
    
    # Expected exits per row = headcount * theta of that group
    mu = headcount * theta_group[group_idx]
    
    # Likelihood: Poisson observed exits
    y_obs = pm.Poisson('y_obs', mu=mu, observed=exits)
    
    # Predictive posterior
    trace = pm.sample(2000, tune=2000, target_accept=0.95, random_seed=42)

# -----------------------------------------
# 3. Summarise posterior
# -----------------------------------------
az.summary(trace, var_names=['alpha_hyper','beta_hyper','theta_group'])

# Posterior mean attrition rates per group:
theta_means = trace.posterior['theta_group'].mean(dim=("chain","draw")).values

group_results = pd.DataFrame({
    'BUSINESS_GROUPS_TA': groups,
    'posterior_attrition_rate': theta_means
})

print(group_results)

# -----------------------------------------
# 4. Make predictions for each row
# -----------------------------------------
# For each draw, predicted exits per row
theta_draws = trace.posterior['theta_group'].stack(sample=("chain","draw")).values  # shape (n_groups, draws)
predicted_exits = []
for i, gidx in enumerate(group_idx):
    lam_draws = headcount[i] * theta_draws[gidx,:]
    pred_mean = lam_draws.mean()
    pred_lower = np.percentile(lam_draws, 2.5)
    pred_upper = np.percentile(lam_draws, 97.5)
    predicted_exits.append((pred_mean, pred_lower, pred_upper))

predicted_exits = pd.DataFrame(predicted_exits, columns=['pred_mean','pred_lower','pred_upper'])
df_pred = pd.concat([df, predicted_exits], axis=1)

# -----------------------------------------
# 5. Visualise predicted vs actual
# -----------------------------------------
plt.figure(figsize=(10,6))
for g in groups:
    dfg = df_pred[df_pred['BUSINESS_GROUPS_TA']==g]
    plt.plot(dfg['MONTH'], dfg['VOLUNTARY_EXITS'], 'o-', label=f'{g} Actual')
    plt.plot(dfg['MONTH'], dfg['pred_mean'], 'x--', label=f'{g} Predicted')
plt.xlabel('Month')
plt.ylabel('Exits')
plt.title('Actual vs Predicted Exits by Group')
plt.legend(bbox_to_anchor=(1.05,1))
plt.tight_layout()
plt.show()



















# Requires: pandas, numpy, scipy
import pandas as pd
import numpy as np
from scipy import stats

# 1. load (adjust path as needed)
df = pd.read_excel('monthwise_updated_attrition_dataset.xlsx')  # your file
# ensure MONTH sorts chronologically
df = df.sort_values(['BUSINESS_GROUPS_TA', 'MONTH']).reset_index(drop=True)

# 2. quick per-row per-person exit rate estimate (no pooling)
df['lambda_hat'] = df['VOLUNTARY_EXITS'] / df['HEADCOUNT']  # observed per-person rate

# 3. Empirical Bayes (method-of-moments) to get global Gamma prior for theta
m = df['lambda_hat'].mean()
v = df['lambda_hat'].var(ddof=1)
# safety if v is 0 or extremely small:
if v <= 0 or np.isnan(v):
    # fallback weak prior around mean
    alpha0, beta0 = 1.0, 1.0 / max(m, 1e-6)
else:
    alpha0 = (m**2) / v
    beta0  = m / v
# Note: in the Gamma(rate) parameterization, mean = alpha/beta

# 4. create cumulative-up-to-previous-month statistics per group (so forecasting uses only past)
g = df.groupby('BUSINESS_GROUPS_TA')
df['cum_exits_prev'] = g['VOLUNTARY_EXITS'].cumsum() - df['VOLUNTARY_EXITS']
df['cum_head_prev']  = g['HEADCOUNT'].cumsum() - df['HEADCOUNT']

# For the first row of a group, cum_*_prev will be 0 -> posterior is just prior

# 5. posterior parameters using past data (alpha_post = alpha0 + sum_exits_past ; beta_post = beta0 + sum_headcount_past)
df['alpha_post_prev'] = alpha0 + df['cum_exits_prev']
df['beta_post_prev']  = beta0  + df['cum_head_prev']

# 6. choose exposure (HEADCOUNT) for next-month prediction. If you have a next-month HEADCOUNT use it;
#    otherwise use current HEADCOUNT as a simple estimator for next month exposure.
df['HEADCOUNT_next_est'] = df['HEADCOUNT']  # simple, can be improved by modeling hires separately

# 7. predictive mean for next-month exits:
#    E[exits_next] = HEADCOUNT_next * (alpha_post_prev / beta_post_prev)
df['pred_exits_mean'] = df['HEADCOUNT_next_est'] * (df['alpha_post_prev'] / df['beta_post_prev'])

# 8. predictive 95% credible interval using Negative-Binomial parameterization:
#    NB parameters: r = alpha_post_prev, p = beta_post_prev / (beta_post_prev + HEADCOUNT_next_est)
r = df['alpha_post_prev'].values
p = df['beta_post_prev'].values / (df['beta_post_prev'].values + df['HEADCOUNT_next_est'].values)

# use scipy nbinom: nbinom.ppf returns number of failures (exits) quantile
lower_q = stats.nbinom.ppf(0.025, r, p)
upper_q = stats.nbinom.ppf(0.975, r, p)

df['pred_exits_ci_lower'] = lower_q
df['pred_exits_ci_upper'] = upper_q

# 9. predicted attrition rate (mean and CI)
df['pred_monthly_attrition_rate_mean'] = df['pred_exits_mean'] / df['HEADCOUNT_next_est']
df['pred_attr_rate_ci_lower'] = df['pred_exits_ci_lower'] / df['HEADCOUNT_next_est']
df['pred_attr_rate_ci_upper'] = df['pred_exits_ci_upper'] / df['HEADCOUNT_next_est']

# 10. view results for latest month in each BUSINESS_GROUPS_TA (example)
latest_preds = df.groupby('BUSINESS_GROUPS_TA').tail(1)[[
    'BUSINESS_GROUPS_TA','MONTH','HEADCOUNT','VOLUNTARY_EXITS','MONTHLY_ATTRITION_RATE',
    'pred_exits_mean','pred_exits_ci_lower','pred_exits_ci_upper',
    'pred_monthly_attrition_rate_mean','pred_attr_rate_ci_lower','pred_attr_rate_ci_upper'
]]
print(latest_preds.to_string(index=False))






import matplotlib.pyplot as plt
import seaborn as sns

# Example: pick one BUSINESS_GROUPS_TA to plot (change as needed)
group_to_plot = df['BUSINESS_GROUPS_TA'].unique()[0]

plot_df = df[df['BUSINESS_GROUPS_TA'] == group_to_plot].copy()

plt.figure(figsize=(14,6))

# Actual voluntary exits
sns.lineplot(
    data=plot_df,
    x='MONTH', y='VOLUNTARY_EXITS',
    label='Actual Exits', marker='o'
)

# Predicted mean
sns.lineplot(
    data=plot_df,
    x='MONTH', y='pred_exits_mean',
    label='Predicted Exits (mean)', marker='o'
)

# Fill between lower/upper CI
plt.fill_between(
    plot_df['MONTH'],
    plot_df['pred_exits_ci_lower'],
    plot_df['pred_exits_ci_upper'],
    color='gray', alpha=0.2, label='95% Predicted Interval'
)

plt.title(f'Predicted vs Actual Voluntary Exits â€“ {group_to_plot}')
plt.xticks(rotation=45)
plt.ylabel('Number of Exits')
plt.legend()
plt.tight_layout()
plt.show()
