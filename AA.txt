Matches per day

SELECT INGEST_DATE, COUNT(*) AS MATCH_COUNT
FROM (
    SELECT TRUNC(INGESTED_DATE) AS INGEST_DATE,
           CANDIDATE_ID,
           JOB_APPLICATION
    FROM VFA_APP_USR_TALD.WD_RECRUITING_DIVERSE_INTERVIEW_PANELS
    WHERE INGESTED_DATE >= DATE '2025-09-01'
      AND INGESTED_DATE <  DATE '2025-09-08'

    INTERSECT

    SELECT TRUNC(INGESTED_DATE),
           CANDIDATE_ID,
           JOB_APPLICATION
    FROM VFA_APP_USR_TALD.WD_RECRUITING_DIVERSE_INTERVIEW_PANELS_TEMP
    WHERE INGESTED_DATE >= DATE '2025-09-01'
      AND INGESTED_DATE <  DATE '2025-09-08'
)
GROUP BY INGEST_DATE
ORDER BY INGEST_DATE;

















SELECT
    'MAIN_TABLE' AS TABLE_NAME,
    MIN(INGESTED_DATE) AS MIN_INGESTED_DATE,
    MAX(INGESTED_DATE) AS MAX_INGESTED_DATE
FROM VFA_APP_USR_TALD.WD_RECRUITING_DIVERSE_INTERVIEW_PANELS

UNION ALL

SELECT
    'TEMP_TABLE' AS TABLE_NAME,
    MIN(INGESTED_DATE),
    MAX(INGESTED_DATE)
FROM VFA_APP_USR_TALD.WD_RECRUITING_DIVERSE_INTERVIEW_PANELS_TEMP;






SELECT COUNT(*)
FROM (
    SELECT CANDIDATE_ID, JOB_APPLICATION
    FROM VFA_APP_USR_TALD.WD_RECRUITING_DIVERSE_INTERVIEW_PANELS
    INTERSECT
    SELECT CANDIDATE_ID, JOB_APPLICATION
    FROM VFA_APP_USR_TALD.WD_RECRUITING_DIVERSE_INTERVIEW_PANELS_TEMP
);






SELECT CANDIDATE_ID, JOB_APPLICATION
FROM VFA_APP_USR_TALD.WD_RECRUITING_DIVERSE_INTERVIEW_PANELS
INTERSECT
SELECT CANDIDATE_ID, JOB_APPLICATION
FROM VFA_APP_USR_TALD.WD_RECRUITING_DIVERSE_INTERVIEW_PANELS_TEMP;













SELECT COUNT(*) AS COMMON_ROW_COUNT
FROM (
    SELECT *
    FROM VFA_APP_USR_TALD.WD_RECRUITING_DIVERSE_INTERVIEW_PANELS
    INTERSECT
    SELECT *
    FROM VFA_APP_USR_TALD.WD_RECRUITING_DIVERSE_INTERVIEW_PANELS_TEMP
);



SELECT *
FROM VFA_APP_USR_TALD.WD_RECRUITING_DIVERSE_INTERVIEW_PANELS
INTERSECT
SELECT *
FROM VFA_APP_USR_TALD.WD_RECRUITING_DIVERSE_INTERVIEW_PANELS_TEMP;


























--------------------------------------------------------------------------------
-- FULL: LISTAGG final (may hit 4000-char limit if many/long diffs)
-- Filter ETL_BATCHID = '20251124'
--------------------------------------------------------------------------------
WITH
m AS (
  SELECT ROW_NUMBER() OVER (ORDER BY sig_hash, ROWID) AS rn,
         JOB_APPLICATION,
         TRIM(TO_CHAR(CANDIDATE_ID))                 AS CANDIDATE_ID,
         TRIM(TO_CHAR(POSITION))                     AS POSITION,
         TRIM(TO_CHAR(EMPLOYEE_ID))                  AS EMPLOYEE_ID,
         TRIM(TO_CHAR(SOEID))                        AS SOEID,
         TRIM(TO_CHAR(JOB_REQUISITION))              AS JOB_REQUISITION,
         TRIM(TO_CHAR(ORIGINAL_JOB_REQUISITION))     AS ORIGINAL_JOB_REQUISITION,
         TRIM(TO_CHAR(ADDED_DATE))                   AS ADDED_DATE,
         TRIM(TO_CHAR(SOURCE_CATEGORY))              AS SOURCE_CATEGORY,
         TRIM(TO_CHAR(SOURCE))                       AS SOURCE,
         TRIM(TO_CHAR(RECRUITING_AGENCY))            AS RECRUITING_AGENCY,
         TRIM(TO_CHAR(CANDIDATE_STATUS))             AS CANDIDATE_STATUS,
         TRIM(TO_CHAR(LAST_RECRUITING_STAGE))        AS LAST_RECRUITING_STAGE,
         TRIM(TO_CHAR(JOB_APPLICATION_STEP))         AS JOB_APPLICATION_STEP,
         TRIM(TO_CHAR(LAST_RECRUITING_STAGE_NUMBER)) AS LAST_RECRUITING_STAGE_NUMBER,
         TRIM(TO_CHAR(FINAL_DISPOSITION_REASON))     AS FINAL_DISPOSITION_REASON,
         TRIM(TO_CHAR(OFFER_STATUS))                 AS OFFER_STATUS,
         TRIM(TO_CHAR(HIRED))                        AS HIRED,
         TRIM(TO_CHAR(TIME_TO_OFFER_ACCEPT_DAYS))    AS TIME_TO_OFFER_ACCEPT_DAYS,
         TRIM(TO_CHAR(TIME_TO_OFFER_REJECT_DAYS))    AS TIME_TO_OFFER_REJECT_DAYS,
         TRIM(TO_CHAR(CANDIDATE_START_DATE))         AS CANDIDATE_START_DATE,
         TRIM(TO_CHAR(REFERRED_BY))                  AS REFERRED_BY,
         TRIM(TO_CHAR(CREATED_DATE))                 AS CREATED_DATE,
         TRIM(TO_CHAR(DATE_TIME_COMPLETED))          AS DATE_TIME_COMPLETED,
         TRIM(TO_CHAR(UPDATED_BY))                   AS UPDATED_BY,
         TRIM(TO_CHAR(UPDATED_ON))                   AS UPDATED_ON,
         TRIM(TO_CHAR(RECRUITER))                    AS RECRUITER,
         TRIM(TO_CHAR(CANDIDATE_TAGS))               AS CANDIDATE_TAGS,
         TRIM(TO_CHAR(CANDIDATE_POOL))               AS CANDIDATE_POOL,
         TRIM(TO_CHAR(ETL_BATCHID))                  AS ETL_BATCHID
  FROM (
    SELECT
      ORA_HASH(
        COALESCE(TRIM(TO_CHAR(JOB_APPLICATION)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CANDIDATE_ID)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(POSITION)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(EMPLOYEE_ID)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(SOEID)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(JOB_REQUISITION)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(ORIGINAL_JOB_REQUISITION)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(ADDED_DATE)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(SOURCE_CATEGORY)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(SOURCE)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(RECRUITING_AGENCY)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CANDIDATE_STATUS)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(LAST_RECRUITING_STAGE)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(JOB_APPLICATION_STEP)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(LAST_RECRUITING_STAGE_NUMBER)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(FINAL_DISPOSITION_REASON)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(OFFER_STATUS)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(HIRED)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(TIME_TO_OFFER_ACCEPT_DAYS)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(TIME_TO_OFFER_REJECT_DAYS)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CANDIDATE_START_DATE)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(REFERRED_BY)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CREATED_DATE)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(DATE_TIME_COMPLETED)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(UPDATED_BY)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(UPDATED_ON)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(RECRUITER)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CANDIDATE_TAGS)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CANDIDATE_POOL)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(ETL_BATCHID)),'#')
      ) AS sig_hash,
      JOB_APPLICATION, CANDIDATE_ID, POSITION, EMPLOYEE_ID, SOEID,
      JOB_REQUISITION, ORIGINAL_JOB_REQUISITION, ADDED_DATE, SOURCE_CATEGORY,
      SOURCE, RECRUITING_AGENCY, CANDIDATE_STATUS, LAST_RECRUITING_STAGE,
      JOB_APPLICATION_STEP, LAST_RECRUITING_STAGE_NUMBER, FINAL_DISPOSITION_REASON,
      OFFER_STATUS, HIRED, TIME_TO_OFFER_ACCEPT_DAYS, TIME_TO_OFFER_REJECT_DAYS,
      CANDIDATE_START_DATE, REFERRED_BY, CREATED_DATE, DATE_TIME_COMPLETED,
      UPDATED_BY, UPDATED_ON, RECRUITER, CANDIDATE_TAGS, CANDIDATE_POOL, ETL_BATCHID
    FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION
    WHERE TRIM(TO_CHAR(ETL_BATCHID)) = '20251124'
  )
),

t AS (
  SELECT ROW_NUMBER() OVER (ORDER BY sig_hash, ROWID) AS rn,
         JOB_APPLICATION,
         TRIM(TO_CHAR(CANDIDATE_ID))                 AS CANDIDATE_ID,
         TRIM(TO_CHAR(POSITION))                     AS POSITION,
         TRIM(TO_CHAR(EMPLOYEE_ID))                  AS EMPLOYEE_ID,
         TRIM(TO_CHAR(SOEID))                        AS SOEID,
         TRIM(TO_CHAR(JOB_REQUISITION))              AS JOB_REQUISITION,
         TRIM(TO_CHAR(ORIGINAL_JOB_REQUISITION))     AS ORIGINAL_JOB_REQUISITION,
         TRIM(TO_CHAR(ADDED_DATE))                   AS ADDED_DATE,
         TRIM(TO_CHAR(SOURCE_CATEGORY))              AS SOURCE_CATEGORY,
         TRIM(TO_CHAR(SOURCE))                       AS SOURCE,
         TRIM(TO_CHAR(RECRUITING_AGENCY))            AS RECRUITING_AGENCY,
         TRIM(TO_CHAR(CANDIDATE_STATUS))             AS CANDIDATE_STATUS,
         TRIM(TO_CHAR(LAST_RECRUITING_STAGE))        AS LAST_RECRUITING_STAGE,
         TRIM(TO_CHAR(JOB_APPLICATION_STEP))         AS JOB_APPLICATION_STEP,
         TRIM(TO_CHAR(LAST_RECRUITING_STAGE_NUMBER)) AS LAST_RECRUITING_STAGE_NUMBER,
         TRIM(TO_CHAR(FINAL_DISPOSITION_REASON))     AS FINAL_DISPOSITION_REASON,
         TRIM(TO_CHAR(OFFER_STATUS))                 AS OFFER_STATUS,
         TRIM(TO_CHAR(HIRED))                        AS HIRED,
         TRIM(TO_CHAR(TIME_TO_OFFER_ACCEPT_DAYS))    AS TIME_TO_OFFER_ACCEPT_DAYS,
         TRIM(TO_CHAR(TIME_TO_OFFER_REJECT_DAYS))    AS TIME_TO_OFFER_REJECT_DAYS,
         TRIM(TO_CHAR(CANDIDATE_START_DATE))         AS CANDIDATE_START_DATE,
         TRIM(TO_CHAR(REFERRED_BY))                  AS REFERRED_BY,
         TRIM(TO_CHAR(CREATED_DATE))                 AS CREATED_DATE,
         TRIM(TO_CHAR(DATE_TIME_COMPLETED))          AS DATE_TIME_COMPLETED,
         TRIM(TO_CHAR(UPDATED_BY))                   AS UPDATED_BY,
         TRIM(TO_CHAR(UPDATED_ON))                   AS UPDATED_ON,
         TRIM(TO_CHAR(RECRUITER))                    AS RECRUITER,
         TRIM(TO_CHAR(CANDIDATE_TAGS))               AS CANDIDATE_TAGS,
         TRIM(TO_CHAR(CANDIDATE_POOL))               AS CANDIDATE_POOL,
         TRIM(TO_CHAR(ETL_BATCHID))                  AS ETL_BATCHID
  FROM (
    SELECT
      ORA_HASH(
        COALESCE(TRIM(TO_CHAR(JOB_APPLICATION)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CANDIDATE_ID)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(POSITION)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(EMPLOYEE_ID)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(SOEID)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(JOB_REQUISITION)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(ORIGINAL_JOB_REQUISITION)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(ADDED_DATE)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(SOURCE_CATEGORY)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(SOURCE)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(RECRUITING_AGENCY)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CANDIDATE_STATUS)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(LAST_RECRUITING_STAGE)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(JOB_APPLICATION_STEP)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(LAST_RECRUITING_STAGE_NUMBER)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(FINAL_DISPOSITION_REASON)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(OFFER_STATUS)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(HIRED)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(TIME_TO_OFFER_ACCEPT_DAYS)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(TIME_TO_OFFER_REJECT_DAYS)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CANDIDATE_START_DATE)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(REFERRED_BY)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CREATED_DATE)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(DATE_TIME_COMPLETED)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(UPDATED_BY)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(UPDATED_ON)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(RECRUITER)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CANDIDATE_TAGS)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CANDIDATE_POOL)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(ETL_BATCHID)),'#')
      ) AS sig_hash,
      JOB_APPLICATION, CANDIDATE_ID, POSITION, EMPLOYEE_ID, SOEID,
      JOB_REQUISITION, ORIGINAL_JOB_REQUISITION, ADDED_DATE, SOURCE_CATEGORY,
      SOURCE, RECRUITING_AGENCY, CANDIDATE_STATUS, LAST_RECRUITING_STAGE,
      JOB_APPLICATION_STEP, LAST_RECRUITING_STAGE_NUMBER, FINAL_DISPOSITION_REASON,
      OFFER_STATUS, HIRED, TIME_TO_OFFER_ACCEPT_DAYS, TIME_TO_OFFER_REJECT_DAYS,
      CANDIDATE_START_DATE, REFERRED_BY, CREATED_DATE, DATE_TIME_COMPLETED,
      UPDATED_BY, UPDATED_ON, RECRUITER, CANDIDATE_TAGS, CANDIDATE_POOL, ETL_BATCHID
    FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP
    WHERE TRIM(TO_CHAR(ETL_BATCHID)) = '20251124'
  )
),

diffs AS (
  SELECT rn,
         'JOB_APPLICATION' AS column_name,
         TRIM(TO_CHAR(m.JOB_APPLICATION)) AS main_val,
         TRIM(TO_CHAR(t.JOB_APPLICATION)) AS temp_val
  FROM m FULL JOIN t USING(rn)
  WHERE TRIM(TO_CHAR(m.JOB_APPLICATION)) <> TRIM(TO_CHAR(t.JOB_APPLICATION))

  UNION ALL

  SELECT rn,
         'CANDIDATE_ID' AS column_name,
         TRIM(TO_CHAR(m.CANDIDATE_ID)) AS main_val,
         TRIM(TO_CHAR(t.CANDIDATE_ID)) AS temp_val
  FROM m FULL JOIN t USING(rn)
  WHERE TRIM(TO_CHAR(m.CANDIDATE_ID)) <> TRIM(TO_CHAR(t.CANDIDATE_ID))

  UNION ALL

  SELECT rn,
         'POSITION' AS column_name,
         TRIM(TO_CHAR(m.POSITION)) AS main_val,
         TRIM(TO_CHAR(t.POSITION)) AS temp_val
  FROM m FULL JOIN t USING(rn)
  WHERE TRIM(TO_CHAR(m.POSITION)) <> TRIM(TO_CHAR(t.POSITION))

  UNION ALL

  SELECT rn,
         'EMPLOYEE_ID' AS column_name,
         TRIM(TO_CHAR(m.EMPLOYEE_ID)) AS main_val,
         TRIM(TO_CHAR(t.EMPLOYEE_ID)) AS temp_val
  FROM m FULL JOIN t USING(rn)
  WHERE TRIM(TO_CHAR(m.EMPLOYEE_ID)) <> TRIM(TO_CHAR(t.EMPLOYEE_ID))

  UNION ALL

  SELECT rn, 'SOEID' AS column_name, TRIM(TO_CHAR(m.SOEID)) AS main_val, TRIM(TO_CHAR(t.SOEID)) AS temp_val
  FROM m FULL JOIN t USING(rn) WHERE TRIM(TO_CHAR(m.SOEID)) <> TRIM(TO_CHAR(t.SOEID))

  UNION ALL

  SELECT rn, 'JOB_REQUISITION' AS column_name, TRIM(TO_CHAR(m.JOB_REQUISITION)) AS main_val, TRIM(TO_CHAR(t.JOB_REQUISITION)) AS temp_val
  FROM m FULL JOIN t USING(rn) WHERE TRIM(TO_CHAR(m.JOB_REQUISITION)) <> TRIM(TO_CHAR(t.JOB_REQUISITION))

  UNION ALL

  SELECT rn, 'ORIGINAL_JOB_REQUISITION' AS column_name, TRIM(TO_CHAR(m.ORIGINAL_JOB_REQUISITION)) AS main_val, TRIM(TO_CHAR(t.ORIGINAL_JOB_REQUISITION)) AS temp_val
  FROM m FULL JOIN t USING(rn) WHERE TRIM(TO_CHAR(m.ORIGINAL_JOB_REQUISITION)) <> TRIM(TO_CHAR(t.ORIGINAL_JOB_REQUISITION))

  UNION ALL

  SELECT rn, 'ADDED_DATE' AS column_name, TRIM(TO_CHAR(m.ADDED_DATE)) AS main_val, TRIM(TO_CHAR(t.ADDED_DATE)) AS temp_val
  FROM m FULL JOIN t USING(rn) WHERE TRIM(TO_CHAR(m.ADDED_DATE)) <> TRIM(TO_CHAR(t.ADDED_DATE))

  UNION ALL

  SELECT rn, 'SOURCE_CATEGORY' AS column_name, TRIM(TO_CHAR(m.SOURCE_CATEGORY)) AS main_val, TRIM(TO_CHAR(t.SOURCE_CATEGORY)) AS temp_val
  FROM m FULL JOIN t USING(rn) WHERE TRIM(TO_CHAR(m.SOURCE_CATEGORY)) <> TRIM(TO_CHAR(t.SOURCE_CATEGORY))

  UNION ALL

  SELECT rn, 'SOURCE' AS column_name, TRIM(TO_CHAR(m.SOURCE)) AS main_val, TRIM(TO_CHAR(t.SOURCE)) AS temp_val
  FROM m FULL JOIN t USING(rn) WHERE TRIM(TO_CHAR(m.SOURCE)) <> TRIM(TO_CHAR(t.SOURCE))

  UNION ALL

  SELECT rn, 'RECRUITING_AGENCY' AS column_name, TRIM(TO_CHAR(m.RECRUITING_AGENCY)) AS main_val, TRIM(TO_CHAR(t.RECRUITING_AGENCY)) AS temp_val
  FROM m FULL JOIN t USING(rn) WHERE TRIM(TO_CHAR(m.RECRUITING_AGENCY)) <> TRIM(TO_CHAR(t.RECRUITING_AGENCY))

  UNION ALL

  SELECT rn, 'CANDIDATE_STATUS' AS column_name, TRIM(TO_CHAR(m.CANDIDATE_STATUS)) AS main_val, TRIM(TO_CHAR(t.CANDIDATE_STATUS)) AS temp_val
  FROM m FULL JOIN t USING(rn) WHERE TRIM(TO_CHAR(m.CANDIDATE_STATUS)) <> TRIM(TO_CHAR(t.CANDIDATE_STATUS))

  UNION ALL

  SELECT rn, 'LAST_RECRUITING_STAGE' AS column_name, TRIM(TO_CHAR(m.LAST_RECRUITING_STAGE)) AS main_val, TRIM(TO_CHAR(t.LAST_RECRUITING_STAGE)) AS temp_val
  FROM m FULL JOIN t USING(rn) WHERE TRIM(TO_CHAR(m.LAST_RECRUITING_STAGE)) <> TRIM(TO_CHAR(t.LAST_RECRUITING_STAGE))

  UNION ALL

  SELECT rn, 'JOB_APPLICATION_STEP' AS column_name, TRIM(TO_CHAR(m.JOB_APPLICATION_STEP)) AS main_val, TRIM(TO_CHAR(t.JOB_APPLICATION_STEP)) AS temp_val
  FROM m FULL JOIN t USING(rn) WHERE TRIM(TO_CHAR(m.JOB_APPLICATION_STEP)) <> TRIM(TO_CHAR(t.JOB_APPLICATION_STEP))

  UNION ALL

  SELECT rn, 'LAST_RECRUITING_STAGE_NUMBER' AS column_name, TRIM(TO_CHAR(m.LAST_RECRUITING_STAGE_NUMBER)) AS main_val, TRIM(TO_CHAR(t.LAST_RECRUITING_STAGE_NUMBER)) AS temp_val
  FROM m FULL JOIN t USING(rn) WHERE TRIM(TO_CHAR(m.LAST_RECRUITING_STAGE_NUMBER)) <> TRIM(TO_CHAR(t.LAST_RECRUITING_STAGE_NUMBER))

  UNION ALL

  SELECT rn, 'FINAL_DISPOSITION_REASON' AS column_name, TRIM(TO_CHAR(m.FINAL_DISPOSITION_REASON)) AS main_val, TRIM(TO_CHAR(t.FINAL_DISPOSITION_REASON)) AS temp_val
  FROM m FULL JOIN t USING(rn) WHERE TRIM(TO_CHAR(m.FINAL_DISPOSITION_REASON)) <> TRIM(TO_CHAR(t.FINAL_DISPOSITION_REASON))

  UNION ALL

  SELECT rn, 'OFFER_STATUS' AS column_name, TRIM(TO_CHAR(m.OFFER_STATUS)) AS main_val, TRIM(TO_CHAR(t.OFFER_STATUS)) AS temp_val
  FROM m FULL JOIN t USING(rn) WHERE TRIM(TO_CHAR(m.OFFER_STATUS)) <> TRIM(TO_CHAR(t.OFFER_STATUS))

  UNION ALL

  SELECT rn, 'HIRED' AS column_name, TRIM(TO_CHAR(m.HIRED)) AS main_val, TRIM(TO_CHAR(t.HIRED)) AS temp_val
  FROM m FULL JOIN t USING(rn) WHERE TRIM(TO_CHAR(m.HIRED)) <> TRIM(TO_CHAR(t.HIRED))

  UNION ALL

  SELECT rn, 'TIME_TO_OFFER_ACCEPT_DAYS' AS column_name, TRIM(TO_CHAR(m.TIME_TO_OFFER_ACCEPT_DAYS)) AS main_val, TRIM(TO_CHAR(t.TIME_TO_OFFER_ACCEPT_DAYS)) AS temp_val
  FROM m FULL JOIN t USING(rn) WHERE TRIM(TO_CHAR(m.TIME_TO_OFFER_ACCEPT_DAYS)) <> TRIM(TO_CHAR(t.TIME_TO_OFFER_ACCEPT_DAYS))

  UNION ALL

  SELECT rn, 'TIME_TO_OFFER_REJECT_DAYS' AS column_name, TRIM(TO_CHAR(m.TIME_TO_OFFER_REJECT_DAYS)) AS main_val, TRIM(TO_CHAR(t.TIME_TO_OFFER_REJECT_DAYS)) AS temp_val
  FROM m FULL JOIN t USING(rn) WHERE TRIM(TO_CHAR(m.TIME_TO_OFFER_REJECT_DAYS)) <> TRIM(TO_CHAR(t.TIME_TO_OFFER_REJECT_DAYS))

  UNION ALL

  SELECT rn, 'CANDIDATE_START_DATE' AS column_name, TRIM(TO_CHAR(m.CANDIDATE_START_DATE)) AS main_val, TRIM(TO_CHAR(t.CANDIDATE_START_DATE)) AS temp_val
  FROM m FULL JOIN t USING(rn) WHERE TRIM(TO_CHAR(m.CANDIDATE_START_DATE)) <> TRIM(TO_CHAR(t.CANDIDATE_START_DATE))

  UNION ALL

  SELECT rn, 'REFERRED_BY' AS column_name, TRIM(TO_CHAR(m.REFERRED_BY)) AS main_val, TRIM(TO_CHAR(t.REFERRED_BY)) AS temp_val
  FROM m FULL JOIN t USING(rn) WHERE TRIM(TO_CHAR(m.REFERRED_BY)) <> TRIM(TO_CHAR(t.REFERRED_BY))

  UNION ALL

  SELECT rn, 'CREATED_DATE' AS column_name, TRIM(TO_CHAR(m.CREATED_DATE)) AS main_val, TRIM(TO_CHAR(t.CREATED_DATE)) AS temp_val
  FROM m FULL JOIN t USING(rn) WHERE TRIM(TO_CHAR(m.CREATED_DATE)) <> TRIM(TO_CHAR(t.CREATED_DATE))

  UNION ALL

  SELECT rn, 'DATE_TIME_COMPLETED' AS column_name, TRIM(TO_CHAR(m.DATE_TIME_COMPLETED)) AS main_val, TRIM(TO_CHAR(t.DATE_TIME_COMPLETED)) AS temp_val
  FROM m FULL JOIN t USING(rn) WHERE TRIM(TO_CHAR(m.DATE_TIME_COMPLETED)) <> TRIM(TO_CHAR(t.DATE_TIME_COMPLETED))

  UNION ALL

  SELECT rn, 'UPDATED_BY' AS column_name, TRIM(TO_CHAR(m.UPDATED_BY)) AS main_val, TRIM(TO_CHAR(t.UPDATED_BY)) AS temp_val
  FROM m FULL JOIN t USING(rn) WHERE TRIM(TO_CHAR(m.UPDATED_BY)) <> TRIM(TO_CHAR(t.UPDATED_BY))

  UNION ALL

  SELECT rn, 'UPDATED_ON' AS column_name, TRIM(TO_CHAR(m.UPDATED_ON)) AS main_val, TRIM(TO_CHAR(t.UPDATED_ON)) AS temp_val
  FROM m FULL JOIN t USING(rn) WHERE TRIM(TO_CHAR(m.UPDATED_ON)) <> TRIM(TO_CHAR(t.UPDATED_ON))

  UNION ALL

  SELECT rn, 'RECRUITER' AS column_name, TRIM(TO_CHAR(m.RECRUITER)) AS main_val, TRIM(TO_CHAR(t.RECRUITER)) AS temp_val
  FROM m FULL JOIN t USING(rn) WHERE TRIM(TO_CHAR(m.RECRUITER)) <> TRIM(TO_CHAR(t.RECRUITER))

  UNION ALL

  SELECT rn, 'CANDIDATE_TAGS' AS column_name, TRIM(TO_CHAR(m.CANDIDATE_TAGS)) AS main_val, TRIM(TO_CHAR(t.CANDIDATE_TAGS)) AS temp_val
  FROM m FULL JOIN t USING(rn) WHERE TRIM(TO_CHAR(m.CANDIDATE_TAGS)) <> TRIM(TO_CHAR(t.CANDIDATE_TAGS))

  UNION ALL

  SELECT rn, 'CANDIDATE_POOL' AS column_name, TRIM(TO_CHAR(m.CANDIDATE_POOL)) AS main_val, TRIM(TO_CHAR(t.CANDIDATE_POOL)) AS temp_val
  FROM m FULL JOIN t USING(rn) WHERE TRIM(TO_CHAR(m.CANDIDATE_POOL)) <> TRIM(TO_CHAR(t.CANDIDATE_POOL))

  UNION ALL

  SELECT rn, 'ETL_BATCHID' AS column_name, TRIM(TO_CHAR(m.ETL_BATCHID)) AS main_val, TRIM(TO_CHAR(t.ETL_BATCHID)) AS temp_val
  FROM m FULL JOIN t USING(rn) WHERE TRIM(TO_CHAR(m.ETL_BATCHID)) <> TRIM(TO_CHAR(t.ETL_BATCHID))
)

SELECT
  rn,
  LISTAGG(column_name, ', ') WITHIN GROUP (ORDER BY column_name) AS differing_columns,
  COUNT(*) AS diff_count,
  LISTAGG(column_name || '=' || main_val || ' -> ' || temp_val, '; ') WITHIN GROUP (ORDER BY column_name) AS all_mismatch_column_values
FROM diffs
GROUP BY rn
ORDER BY diff_count DESC, rn
FETCH FIRST 200 ROWS ONLY;



























WITH
m AS (
  SELECT ROW_NUMBER() OVER (ORDER BY sig_hash, ROWID) AS rn,
         JOB_APPLICATION,
         TRIM(TO_CHAR(CANDIDATE_ID)) AS CANDIDATE_ID,
         TRIM(TO_CHAR(POSITION)) AS POSITION,
         TRIM(TO_CHAR(EMPLOYEE_ID)) AS EMPLOYEE_ID,
         TRIM(TO_CHAR(SOEID)) AS SOEID,
         TRIM(TO_CHAR(JOB_REQUISITION)) AS JOB_REQUISITION,
         TRIM(TO_CHAR(ORIGINAL_JOB_REQUISITION)) AS ORIGINAL_JOB_REQUISITION,
         TRIM(TO_CHAR(ADDED_DATE)) AS ADDED_DATE,
         TRIM(TO_CHAR(SOURCE_CATEGORY)) AS SOURCE_CATEGORY,
         TRIM(TO_CHAR(SOURCE)) AS SOURCE,
         TRIM(TO_CHAR(RECRUITING_AGENCY)) AS RECRUITING_AGENCY,
         TRIM(TO_CHAR(CANDIDATE_STATUS)) AS CANDIDATE_STATUS,
         TRIM(TO_CHAR(LAST_RECRUITING_STAGE)) AS LAST_RECRUITING_STAGE,
         TRIM(TO_CHAR(JOB_APPLICATION_STEP)) AS JOB_APPLICATION_STEP,
         TRIM(TO_CHAR(LAST_RECRUITING_STAGE_NUMBER)) AS LAST_RECRUITING_STAGE_NUMBER,
         TRIM(TO_CHAR(FINAL_DISPOSITION_REASON)) AS FINAL_DISPOSITION_REASON,
         TRIM(TO_CHAR(OFFER_STATUS)) AS OFFER_STATUS,
         TRIM(TO_CHAR(HIRED)) AS HIRED,
         TRIM(TO_CHAR(TIME_TO_OFFER_ACCEPT_DAYS)) AS TIME_TO_OFFER_ACCEPT_DAYS,
         TRIM(TO_CHAR(TIME_TO_OFFER_REJECT_DAYS)) AS TIME_TO_OFFER_REJECT_DAYS,
         TRIM(TO_CHAR(CANDIDATE_START_DATE)) AS CANDIDATE_START_DATE,
         TRIM(TO_CHAR(REFERRED_BY)) AS REFERRED_BY,
         TRIM(TO_CHAR(CREATED_DATE)) AS CREATED_DATE,
         TRIM(TO_CHAR(DATE_TIME_COMPLETED)) AS DATE_TIME_COMPLETED,
         TRIM(TO_CHAR(UPDATED_BY)) AS UPDATED_BY,
         TRIM(TO_CHAR(UPDATED_ON)) AS UPDATED_ON,
         TRIM(TO_CHAR(RECRUITER)) AS RECRUITER,
         TRIM(TO_CHAR(CANDIDATE_TAGS)) AS CANDIDATE_TAGS,
         TRIM(TO_CHAR(CANDIDATE_POOL)) AS CANDIDATE_POOL,
         TRIM(TO_CHAR(ETL_BATCHID)) AS ETL_BATCHID
  FROM (
    SELECT
      ORA_HASH(
        COALESCE(TRIM(TO_CHAR(JOB_APPLICATION)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CANDIDATE_ID)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(POSITION)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(EMPLOYEE_ID)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(SOEID)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(JOB_REQUISITION)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(ORIGINAL_JOB_REQUISITION)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(ADDED_DATE)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(SOURCE_CATEGORY)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(SOURCE)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(RECRUITING_AGENCY)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CANDIDATE_STATUS)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(LAST_RECRUITING_STAGE)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(JOB_APPLICATION_STEP)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(LAST_RECRUITING_STAGE_NUMBER)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(FINAL_DISPOSITION_REASON)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(OFFER_STATUS)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(HIRED)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(TIME_TO_OFFER_ACCEPT_DAYS)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(TIME_TO_OFFER_REJECT_DAYS)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CANDIDATE_START_DATE)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(REFERRED_BY)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CREATED_DATE)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(DATE_TIME_COMPLETED)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(UPDATED_BY)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(UPDATED_ON)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(RECRUITER)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CANDIDATE_TAGS)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CANDIDATE_POOL)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(ETL_BATCHID)),'#')
      ) AS sig_hash,
      JOB_APPLICATION, CANDIDATE_ID, POSITION, EMPLOYEE_ID, SOEID,
      JOB_REQUISITION, ORIGINAL_JOB_REQUISITION, ADDED_DATE, SOURCE_CATEGORY,
      SOURCE, RECRUITING_AGENCY, CANDIDATE_STATUS, LAST_RECRUITING_STAGE,
      JOB_APPLICATION_STEP, LAST_RECRUITING_STAGE_NUMBER, FINAL_DISPOSITION_REASON,
      OFFER_STATUS, HIRED, TIME_TO_OFFER_ACCEPT_DAYS, TIME_TO_OFFER_REJECT_DAYS,
      CANDIDATE_START_DATE, REFERRED_BY, CREATED_DATE, DATE_TIME_COMPLETED,
      UPDATED_BY, UPDATED_ON, RECRUITER, CANDIDATE_TAGS, CANDIDATE_POOL, ETL_BATCHID
    FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION
    WHERE TRIM(TO_CHAR(ETL_BATCHID)) = '20251124'
  )
),

t AS (
  SELECT ROW_NUMBER() OVER (ORDER BY sig_hash, ROWID) AS rn,
         JOB_APPLICATION,
         TRIM(TO_CHAR(CANDIDATE_ID)) AS CANDIDATE_ID,
         TRIM(TO_CHAR(POSITION)) AS POSITION,
         TRIM(TO_CHAR(EMPLOYEE_ID)) AS EMPLOYEE_ID,
         TRIM(TO_CHAR(SOEID)) AS SOEID,
         TRIM(TO_CHAR(JOB_REQUISITION)) AS JOB_REQUISITION,
         TRIM(TO_CHAR(ORIGINAL_JOB_REQUISITION)) AS ORIGINAL_JOB_REQUISITION,
         TRIM(TO_CHAR(ADDED_DATE)) AS ADDED_DATE,
         TRIM(TO_CHAR(SOURCE_CATEGORY)) AS SOURCE_CATEGORY,
         TRIM(TO_CHAR(SOURCE)) AS SOURCE,
         TRIM(TO_CHAR(RECRUITING_AGENCY)) AS RECRUITING_AGENCY,
         TRIM(TO_CHAR(CANDIDATE_STATUS)) AS CANDIDATE_STATUS,
         TRIM(TO_CHAR(LAST_RECRUITING_STAGE)) AS LAST_RECRUITING_STAGE,
         TRIM(TO_CHAR(JOB_APPLICATION_STEP)) AS JOB_APPLICATION_STEP,
         TRIM(TO_CHAR(LAST_RECRUITING_STAGE_NUMBER)) AS LAST_RECRUITING_STAGE_NUMBER,
         TRIM(TO_CHAR(FINAL_DISPOSITION_REASON)) AS FINAL_DISPOSITION_REASON,
         TRIM(TO_CHAR(OFFER_STATUS)) AS OFFER_STATUS,
         TRIM(TO_CHAR(HIRED)) AS HIRED,
         TRIM(TO_CHAR(TIME_TO_OFFER_ACCEPT_DAYS)) AS TIME_TO_OFFER_ACCEPT_DAYS,
         TRIM(TO_CHAR(TIME_TO_OFFER_REJECT_DAYS)) AS TIME_TO_OFFER_REJECT_DAYS,
         TRIM(TO_CHAR(CANDIDATE_START_DATE)) AS CANDIDATE_START_DATE,
         TRIM(TO_CHAR(REFERRED_BY)) AS REFERRED_BY,
         TRIM(TO_CHAR(CREATED_DATE)) AS CREATED_DATE,
         TRIM(TO_CHAR(DATE_TIME_COMPLETED)) AS DATE_TIME_COMPLETED,
         TRIM(TO_CHAR(UPDATED_BY)) AS UPDATED_BY,
         TRIM(TO_CHAR(UPDATED_ON)) AS UPDATED_ON,
         TRIM(TO_CHAR(RECRUITER)) AS RECRUITER,
         TRIM(TO_CHAR(CANDIDATE_TAGS)) AS CANDIDATE_TAGS,
         TRIM(TO_CHAR(CANDIDATE_POOL)) AS CANDIDATE_POOL,
         TRIM(TO_CHAR(ETL_BATCHID)) AS ETL_BATCHID
  FROM (
    SELECT
      ORA_HASH(
        COALESCE(TRIM(TO_CHAR(JOB_APPLICATION)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CANDIDATE_ID)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(POSITION)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(EMPLOYEE_ID)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(SOEID)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(JOB_REQUISITION)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(ORIGINAL_JOB_REQUISITION)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(ADDED_DATE)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(SOURCE_CATEGORY)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(SOURCE)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(RECRUITING_AGENCY)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CANDIDATE_STATUS)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(LAST_RECRUITING_STAGE)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(JOB_APPLICATION_STEP)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(LAST_RECRUITING_STAGE_NUMBER)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(FINAL_DISPOSITION_REASON)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(OFFER_STATUS)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(HIRED)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(TIME_TO_OFFER_ACCEPT_DAYS)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(TIME_TO_OFFER_REJECT_DAYS)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CANDIDATE_START_DATE)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(REFERRED_BY)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CREATED_DATE)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(DATE_TIME_COMPLETED)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(UPDATED_BY)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(UPDATED_ON)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(RECRUITER)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CANDIDATE_TAGS)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CANDIDATE_POOL)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(ETL_BATCHID)),'#')
      ) AS sig_hash,
      JOB_APPLICATION, CANDIDATE_ID, POSITION, EMPLOYEE_ID, SOEID,
      JOB_REQUISITION, ORIGINAL_JOB_REQUISITION, ADDED_DATE, SOURCE_CATEGORY,
      SOURCE, RECRUITING_AGENCY, CANDIDATE_STATUS, LAST_RECRUITING_STAGE,
      JOB_APPLICATION_STEP, LAST_RECRUITING_STAGE_NUMBER, FINAL_DISPOSITION_REASON,
      OFFER_STATUS, HIRED, TIME_TO_OFFER_ACCEPT_DAYS, TIME_TO_OFFER_REJECT_DAYS,
      CANDIDATE_START_DATE, REFERRED_BY, CREATED_DATE, DATE_TIME_COMPLETED,
      UPDATED_BY, UPDATED_ON, RECRUITER, CANDIDATE_TAGS, CANDIDATE_POOL, ETL_BATCHID
    FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP
    WHERE TRIM(TO_CHAR(ETL_BATCHID)) = '20251124'
  )
),

diffs AS (
  SELECT rn, 'JOB_APPLICATION', TRIM(TO_CHAR(m.JOB_APPLICATION)), TRIM(TO_CHAR(t.JOB_APPLICATION)) FROM m FULL JOIN t USING(rn)
    WHERE TRIM(TO_CHAR(m.JOB_APPLICATION)) <> TRIM(TO_CHAR(t.JOB_APPLICATION))
  UNION ALL
  SELECT rn, 'CANDIDATE_ID', TRIM(TO_CHAR(m.CANDIDATE_ID)), TRIM(TO_CHAR(t.CANDIDATE_ID)) FROM m FULL JOIN t USING(rn)
    WHERE TRIM(TO_CHAR(m.CANDIDATE_ID)) <> TRIM(TO_CHAR(t.CANDIDATE_ID))
  UNION ALL
  SELECT rn, 'POSITION', TRIM(TO_CHAR(m.POSITION)), TRIM(TO_CHAR(t.POSITION)) FROM m FULL JOIN t USING(rn)
    WHERE TRIM(TO_CHAR(m.POSITION)) <> TRIM(TO_CHAR(t.POSITION))
  UNION ALL
  SELECT rn, 'EMPLOYEE_ID', TRIM(TO_CHAR(m.EMPLOYEE_ID)), TRIM(TO_CHAR(t.EMPLOYEE_ID)) FROM m FULL JOIN t USING(rn)
    WHERE TRIM(TO_CHAR(m.EMPLOYEE_ID)) <> TRIM(TO_CHAR(t.EMPLOYEE_ID))
  UNION ALL
  SELECT rn, 'SOEID', TRIM(TO_CHAR(m.SOEID)), TRIM(TO_CHAR(t.SOEID)) FROM m FULL JOIN t USING(rn)
    WHERE TRIM(TO_CHAR(m.SOEID)) <> TRIM(TO_CHAR(t.SOEID))
  UNION ALL
  SELECT rn, 'JOB_REQUISITION', TRIM(TO_CHAR(m.JOB_REQUISITION)), TRIM(TO_CHAR(t.JOB_REQUISITION)) FROM m FULL JOIN t USING(rn)
    WHERE TRIM(TO_CHAR(m.JOB_REQUISITION)) <> TRIM(TO_CHAR(t.JOB_REQUISITION))
  UNION ALL
  SELECT rn, 'ORIGINAL_JOB_REQUISITION', TRIM(TO_CHAR(m.ORIGINAL_JOB_REQUISITION)), TRIM(TO_CHAR(t.ORIGINAL_JOB_REQUISITION)) FROM m FULL JOIN t USING(rn)
    WHERE TRIM(TO_CHAR(m.ORIGINAL_JOB_REQUISITION)) <> TRIM(TO_CHAR(t.ORIGINAL_JOB_REQUISITION))
  UNION ALL
  SELECT rn, 'ADDED_DATE', TRIM(TO_CHAR(m.ADDED_DATE)), TRIM(TO_CHAR(t.ADDED_DATE)) FROM m FULL JOIN t USING(rn)
    WHERE TRIM(TO_CHAR(m.ADDED_DATE)) <> TRIM(TO_CHAR(t.ADDED_DATE))
  UNION ALL
  SELECT rn, 'SOURCE_CATEGORY', TRIM(TO_CHAR(m.SOURCE_CATEGORY)), TRIM(TO_CHAR(t.SOURCE_CATEGORY)) FROM m FULL JOIN t USING(rn)
    WHERE TRIM(TO_CHAR(m.SOURCE_CATEGORY)) <> TRIM(TO_CHAR(t.SOURCE_CATEGORY))
  UNION ALL
  SELECT rn, 'SOURCE', TRIM(TO_CHAR(m.SOURCE)), TRIM(TO_CHAR(t.SOURCE)) FROM m FULL JOIN t USING(rn)
    WHERE TRIM(TO_CHAR(m.SOURCE)) <> TRIM(TO_CHAR(t.SOURCE))
  UNION ALL
  SELECT rn, 'RECRUITING_AGENCY', TRIM(TO_CHAR(m.RECRUITING_AGENCY)), TRIM(TO_CHAR(t.RECRUITING_AGENCY)) FROM m FULL JOIN t USING(rn)
    WHERE TRIM(TO_CHAR(m.RECRUITING_AGENCY)) <> TRIM(TO_CHAR(t.RECRUITING_AGENCY))
  UNION ALL
  SELECT rn, 'CANDIDATE_STATUS', TRIM(TO_CHAR(m.CANDIDATE_STATUS)), TRIM(TO_CHAR(t.CANDIDATE_STATUS)) FROM m FULL JOIN t USING(rn)
    WHERE TRIM(TO_CHAR(m.CANDIDATE_STATUS)) <> TRIM(TO_CHAR(t.CANDIDATE_STATUS))
  UNION ALL
  SELECT rn, 'LAST_RECRUITING_STAGE', TRIM(TO_CHAR(m.LAST_RECRUITING_STAGE)), TRIM(TO_CHAR(t.LAST_RECRUITING_STAGE)) FROM m FULL JOIN t USING(rn)
    WHERE TRIM(TO_CHAR(m.LAST_RECRUITING_STAGE)) <> TRIM(TO_CHAR(t.LAST_RECRUITING_STAGE))
  UNION ALL
  SELECT rn, 'JOB_APPLICATION_STEP', TRIM(TO_CHAR(m.JOB_APPLICATION_STEP)), TRIM(TO_CHAR(t.JOB_APPLICATION_STEP)) FROM m FULL JOIN t USING(rn)
    WHERE TRIM(TO_CHAR(m.JOB_APPLICATION_STEP)) <> TRIM(TO_CHAR(t.JOB_APPLICATION_STEP))
  UNION ALL
  SELECT rn, 'LAST_RECRUITING_STAGE_NUMBER', TRIM(TO_CHAR(m.LAST_RECRUITING_STAGE_NUMBER)), TRIM(TO_CHAR(t.LAST_RECRUITING_STAGE_NUMBER)) FROM m FULL JOIN t USING(rn)
    WHERE TRIM(TO_CHAR(m.LAST_RECRUITING_STAGE_NUMBER)) <> TRIM(TO_CHAR(t.LAST_RECRUITING_STAGE_NUMBER))
  UNION ALL
  SELECT rn, 'FINAL_DISPOSITION_REASON', TRIM(TO_CHAR(m.FINAL_DISPOSITION_REASON)), TRIM(TO_CHAR(t.FINAL_DISPOSITION_REASON)) FROM m FULL JOIN t USING(rn)
    WHERE TRIM(TO_CHAR(m.FINAL_DISPOSITION_REASON)) <> TRIM(TO_CHAR(t.FINAL_DISPOSITION_REASON))
  UNION ALL
  SELECT rn, 'OFFER_STATUS', TRIM(TO_CHAR(m.OFFER_STATUS)), TRIM(TO_CHAR(t.OFFER_STATUS)) FROM m FULL JOIN t USING(rn)
    WHERE TRIM(TO_CHAR(m.OFFER_STATUS)) <> TRIM(TO_CHAR(t.OFFER_STATUS))
  UNION ALL
  SELECT rn, 'HIRED', TRIM(TO_CHAR(m.HIRED)), TRIM(TO_CHAR(t.HIRED)) FROM m FULL JOIN t USING(rn)
    WHERE TRIM(TO_CHAR(m.HIRED)) <> TRIM(TO_CHAR(t.HIRED))
  UNION ALL
  SELECT rn, 'TIME_TO_OFFER_ACCEPT_DAYS', TRIM(TO_CHAR(m.TIME_TO_OFFER_ACCEPT_DAYS)), TRIM(TO_CHAR(t.TIME_TO_OFFER_ACCEPT_DAYS)) FROM m FULL JOIN t USING(rn)
    WHERE TRIM(TO_CHAR(m.TIME_TO_OFFER_ACCEPT_DAYS)) <> TRIM(TO_CHAR(t.TIME_TO_OFFER_ACCEPT_DAYS))
  UNION ALL
  SELECT rn, 'TIME_TO_OFFER_REJECT_DAYS', TRIM(TO_CHAR(m.TIME_TO_OFFER_REJECT_DAYS)), TRIM(TO_CHAR(t.TIME_TO_OFFER_REJECT_DAYS)) FROM m FULL JOIN t USING(rn)
    WHERE TRIM(TO_CHAR(m.TIME_TO_OFFER_REJECT_DAYS)) <> TRIM(TO_CHAR(t.TIME_TO_OFFER_REJECT_DAYS))
  UNION ALL
  SELECT rn, 'CANDIDATE_START_DATE', TRIM(TO_CHAR(m.CANDIDATE_START_DATE)), TRIM(TO_CHAR(t.CANDIDATE_START_DATE)) FROM m FULL JOIN t USING(rn)
    WHERE TRIM(TO_CHAR(m.CANDIDATE_START_DATE)) <> TRIM(TO_CHAR(t.CANDIDATE_START_DATE))
  UNION ALL
  SELECT rn, 'REFERRED_BY', TRIM(TO_CHAR(m.REFERRED_BY)), TRIM(TO_CHAR(t.REFERRED_BY)) FROM m FULL JOIN t USING(rn)
    WHERE TRIM(TO_CHAR(m.REFERRED_BY)) <> TRIM(TO_CHAR(t.REFERRED_BY))
  UNION ALL
  SELECT rn, 'CREATED_DATE', TRIM(TO_CHAR(m.CREATED_DATE)), TRIM(TO_CHAR(t.CREATED_DATE)) FROM m FULL JOIN t USING(rn)
    WHERE TRIM(TO_CHAR(m.CREATED_DATE)) <> TRIM(TO_CHAR(t.CREATED_DATE))
  UNION ALL
  SELECT rn, 'DATE_TIME_COMPLETED', TRIM(TO_CHAR(m.DATE_TIME_COMPLETED)), TRIM(TO_CHAR(t.DATE_TIME_COMPLETED)) FROM m FULL JOIN t USING(rn)
    WHERE TRIM(TO_CHAR(m.DATE_TIME_COMPLETED)) <> TRIM(TO_CHAR(t.DATE_TIME_COMPLETED))
  UNION ALL
  SELECT rn, 'UPDATED_BY', TRIM(TO_CHAR(m.UPDATED_BY)), TRIM(TO_CHAR(t.UPDATED_BY)) FROM m FULL JOIN t USING(rn)
    WHERE TRIM(TO_CHAR(m.UPDATED_BY)) <> TRIM(TO_CHAR(t.UPDATED_BY))
  UNION ALL
  SELECT rn, 'UPDATED_ON', TRIM(TO_CHAR(m.UPDATED_ON)), TRIM(TO_CHAR(t.UPDATED_ON)) FROM m FULL JOIN t USING(rn)
    WHERE TRIM(TO_CHAR(m.UPDATED_ON)) <> TRIM(TO_CHAR(t.UPDATED_ON))
  UNION ALL
  SELECT rn, 'RECRUITER', TRIM(TO_CHAR(m.RECRUITER)), TRIM(TO_CHAR(t.RECRUITER)) FROM m FULL JOIN t USING(rn)
    WHERE TRIM(TO_CHAR(m.RECRUITER)) <> TRIM(TO_CHAR(t.RECRUITER))
  UNION ALL
  SELECT rn, 'CANDIDATE_TAGS', TRIM(TO_CHAR(m.CANDIDATE_TAGS)), TRIM(TO_CHAR(t.CANDIDATE_TAGS)) FROM m FULL JOIN t USING(rn)
    WHERE TRIM(TO_CHAR(m.CANDIDATE_TAGS)) <> TRIM(TO_CHAR(t.CANDIDATE_TAGS))
  UNION ALL
  SELECT rn, 'CANDIDATE_POOL', TRIM(TO_CHAR(m.CANDIDATE_POOL)), TRIM(TO_CHAR(t.CANDIDATE_POOL)) FROM m FULL JOIN t USING(rn)
    WHERE TRIM(TO_CHAR(m.CANDIDATE_POOL)) <> TRIM(TO_CHAR(t.CANDIDATE_POOL))
  UNION ALL
  SELECT rn, 'ETL_BATCHID', TRIM(TO_CHAR(m.ETL_BATCHID)), TRIM(TO_CHAR(t.ETL_BATCHID)) FROM m FULL JOIN t USING(rn)
    WHERE TRIM(TO_CHAR(m.ETL_BATCHID)) <> TRIM(TO_CHAR(t.ETL_BATCHID))
)

SELECT
  rn,
  LISTAGG(column_name, ', ') WITHIN GROUP (ORDER BY column_name) AS differing_columns,
  COUNT(*) AS diff_count,
  LISTAGG(
    column_name || '=' || main_val || ' -> ' || temp_val,
    '; '
  ) WITHIN GROUP (ORDER BY column_name) AS all_mismatch_column_values
FROM diffs
GROUP BY rn
ORDER BY diff_count DESC, rn
FETCH FIRST 200 ROWS ONLY;



























-- Count of full-row matches (rows common in both MAIN & TEMP)
WITH main_sig AS (
  SELECT 
    COALESCE(TRIM(TO_CHAR(JOB_APPLICATION)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(CANDIDATE_ID)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(POSITION)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(EMPLOYEE_ID)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(SOEID)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(JOB_REQUISITION)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(ORIGINAL_JOB_REQUISITION)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(ADDED_DATE)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(SOURCE_CATEGORY)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(SOURCE)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(RECRUITING_AGENCY)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(CANDIDATE_STATUS)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(LAST_RECRUITING_STAGE)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(JOB_APPLICATION_STEP)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(LAST_RECRUITING_STAGE_NUMBER)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(FINAL_DISPOSITION_REASON)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(OFFER_STATUS)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(HIRED)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(TIME_TO_OFFER_ACCEPT_DAYS)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(TIME_TO_OFFER_REJECT_DAYS)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(CANDIDATE_START_DATE)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(REFERRED_BY)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(CREATED_DATE)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(DATE_TIME_COMPLETED)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(UPDATED_BY)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(UPDATED_ON)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(RECRUITER)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(CANDIDATE_TAGS)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(CANDIDATE_POOL)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(ETL_BATCHID)),'#') AS full_sig
  FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION
  WHERE TRIM(TO_CHAR(ETL_BATCHID)) = '20251124'
),
temp_sig AS (
  SELECT 
    COALESCE(TRIM(TO_CHAR(JOB_APPLICATION)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(CANDIDATE_ID)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(POSITION)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(EMPLOYEE_ID)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(SOEID)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(JOB_REQUISITION)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(ORIGINAL_JOB_REQUISITION)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(ADDED_DATE)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(SOURCE_CATEGORY)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(SOURCE)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(RECRUITING_AGENCY)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(CANDIDATE_STATUS)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(LAST_RECRUITING_STAGE)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(JOB_APPLICATION_STEP)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(LAST_RECRUITING_STAGE_NUMBER)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(FINAL_DISPOSITION_REASON)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(OFFER_STATUS)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(HIRED)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(TIME_TO_OFFER_ACCEPT_DAYS)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(TIME_TO_OFFER_REJECT_DAYS)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(CANDIDATE_START_DATE)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(REFERRED_BY)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(CREATED_DATE)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(DATE_TIME_COMPLETED)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(UPDATED_BY)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(UPDATED_ON)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(RECRUITER)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(CANDIDATE_TAGS)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(CANDIDATE_POOL)),'#') || '|' ||
    COALESCE(TRIM(TO_CHAR(ETL_BATCHID)),'#') AS full_sig
  FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP
  WHERE TRIM(TO_CHAR(ETL_BATCHID)) = '20251124'
)
SELECT COUNT(*) AS common_full_rows
FROM (
  SELECT full_sig FROM main_sig
  INTERSECT
  SELECT full_sig FROM temp_sig
);































--------------------------------------------------------------------------------
-- SAFE, simplified row-diff summary (no TO_CHAR(format) to avoid ORA-01722)
-- Filtered by ETL_BATCHID = 20251124
--------------------------------------------------------------------------------
WITH
-- MAIN (aligned) using numeric hash signature
m AS (
  SELECT ROW_NUMBER() OVER (ORDER BY sig_hash, ROWID) AS rn,
         JOB_APPLICATION,
         TRIM(TO_CHAR(CANDIDATE_ID))                 AS CANDIDATE_ID,
         TRIM(TO_CHAR(POSITION))                     AS POSITION,
         TRIM(TO_CHAR(EMPLOYEE_ID))                  AS EMPLOYEE_ID,
         TRIM(TO_CHAR(SOEID))                        AS SOEID,
         TRIM(TO_CHAR(JOB_REQUISITION))              AS JOB_REQUISITION,
         TRIM(TO_CHAR(ORIGINAL_JOB_REQUISITION))     AS ORIGINAL_JOB_REQUISITION,
         TRIM(TO_CHAR(ADDED_DATE))                   AS ADDED_DATE,
         TRIM(TO_CHAR(SOURCE_CATEGORY))              AS SOURCE_CATEGORY,
         TRIM(TO_CHAR(SOURCE))                       AS SOURCE,
         TRIM(TO_CHAR(RECRUITING_AGENCY))            AS RECRUITING_AGENCY,
         TRIM(TO_CHAR(CANDIDATE_STATUS))             AS CANDIDATE_STATUS,
         TRIM(TO_CHAR(LAST_RECRUITING_STAGE))        AS LAST_RECRUITING_STAGE,
         TRIM(TO_CHAR(JOB_APPLICATION_STEP))         AS JOB_APPLICATION_STEP,
         TRIM(TO_CHAR(LAST_RECRUITING_STAGE_NUMBER)) AS LAST_RECRUITING_STAGE_NUMBER,
         TRIM(TO_CHAR(FINAL_DISPOSITION_REASON))     AS FINAL_DISPOSITION_REASON,
         TRIM(TO_CHAR(OFFER_STATUS))                 AS OFFER_STATUS,
         TRIM(TO_CHAR(HIRED))                        AS HIRED,
         TRIM(TO_CHAR(TIME_TO_OFFER_ACCEPT_DAYS))    AS TIME_TO_OFFER_ACCEPT_DAYS,
         TRIM(TO_CHAR(TIME_TO_OFFER_REJECT_DAYS))    AS TIME_TO_OFFER_REJECT_DAYS,
         TRIM(TO_CHAR(CANDIDATE_START_DATE))         AS CANDIDATE_START_DATE,
         TRIM(TO_CHAR(REFERRED_BY))                  AS REFERRED_BY,
         TRIM(TO_CHAR(CREATED_DATE))                 AS CREATED_DATE,
         TRIM(TO_CHAR(DATE_TIME_COMPLETED))          AS DATE_TIME_COMPLETED,
         TRIM(TO_CHAR(UPDATED_BY))                   AS UPDATED_BY,
         TRIM(TO_CHAR(UPDATED_ON))                   AS UPDATED_ON,
         TRIM(TO_CHAR(RECRUITER))                    AS RECRUITER,
         TRIM(TO_CHAR(CANDIDATE_TAGS))               AS CANDIDATE_TAGS,
         TRIM(TO_CHAR(CANDIDATE_POOL))               AS CANDIDATE_POOL,
         TRIM(TO_CHAR(ETL_BATCHID))                  AS ETL_BATCHID
  FROM (
    SELECT
      ORA_HASH(
        COALESCE(TRIM(TO_CHAR(JOB_APPLICATION)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CANDIDATE_ID)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(POSITION)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(EMPLOYEE_ID)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(SOEID)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(JOB_REQUISITION)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(ORIGINAL_JOB_REQUISITION)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(ADDED_DATE)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(SOURCE_CATEGORY)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(SOURCE)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(RECRUITING_AGENCY)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CANDIDATE_STATUS)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(LAST_RECRUITING_STAGE)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(JOB_APPLICATION_STEP)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(LAST_RECRUITING_STAGE_NUMBER)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(FINAL_DISPOSITION_REASON)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(OFFER_STATUS)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(HIRED)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(TIME_TO_OFFER_ACCEPT_DAYS)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(TIME_TO_OFFER_REJECT_DAYS)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CANDIDATE_START_DATE)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(REFERRED_BY)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CREATED_DATE)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(DATE_TIME_COMPLETED)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(UPDATED_BY)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(UPDATED_ON)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(RECRUITER)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CANDIDATE_TAGS)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CANDIDATE_POOL)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(ETL_BATCHID)),'#')
      ) AS sig_hash,
      JOB_APPLICATION, CANDIDATE_ID, POSITION, EMPLOYEE_ID, SOEID,
      JOB_REQUISITION, ORIGINAL_JOB_REQUISITION, ADDED_DATE, SOURCE_CATEGORY,
      SOURCE, RECRUITING_AGENCY, CANDIDATE_STATUS, LAST_RECRUITING_STAGE,
      JOB_APPLICATION_STEP, LAST_RECRUITING_STAGE_NUMBER, FINAL_DISPOSITION_REASON,
      OFFER_STATUS, HIRED, TIME_TO_OFFER_ACCEPT_DAYS, TIME_TO_OFFER_REJECT_DAYS,
      CANDIDATE_START_DATE, REFERRED_BY, CREATED_DATE, DATE_TIME_COMPLETED,
      UPDATED_BY, UPDATED_ON, RECRUITER, CANDIDATE_TAGS, CANDIDATE_POOL, ETL_BATCHID
    FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION
    WHERE TRIM(TO_CHAR(ETL_BATCHID)) = '20251124'
  )
),

-- TEMP (aligned) using same safe approach
t AS (
  SELECT ROW_NUMBER() OVER (ORDER BY sig_hash, ROWID) AS rn,
         JOB_APPLICATION,
         TRIM(TO_CHAR(CANDIDATE_ID))                 AS CANDIDATE_ID,
         TRIM(TO_CHAR(POSITION))                     AS POSITION,
         TRIM(TO_CHAR(EMPLOYEE_ID))                  AS EMPLOYEE_ID,
         TRIM(TO_CHAR(SOEID))                        AS SOEID,
         TRIM(TO_CHAR(JOB_REQUISITION))              AS JOB_REQUISITION,
         TRIM(TO_CHAR(ORIGINAL_JOB_REQUISITION))     AS ORIGINAL_JOB_REQUISITION,
         TRIM(TO_CHAR(ADDED_DATE))                   AS ADDED_DATE,
         TRIM(TO_CHAR(SOURCE_CATEGORY))              AS SOURCE_CATEGORY,
         TRIM(TO_CHAR(SOURCE))                       AS SOURCE,
         TRIM(TO_CHAR(RECRUITING_AGENCY))            AS RECRUITING_AGENCY,
         TRIM(TO_CHAR(CANDIDATE_STATUS))             AS CANDIDATE_STATUS,
         TRIM(TO_CHAR(LAST_RECRUITING_STAGE))        AS LAST_RECRUITING_STAGE,
         TRIM(TO_CHAR(JOB_APPLICATION_STEP))         AS JOB_APPLICATION_STEP,
         TRIM(TO_CHAR(LAST_RECRUITING_STAGE_NUMBER)) AS LAST_RECRUITING_STAGE_NUMBER,
         TRIM(TO_CHAR(FINAL_DISPOSITION_REASON))     AS FINAL_DISPOSITION_REASON,
         TRIM(TO_CHAR(OFFER_STATUS))                 AS OFFER_STATUS,
         TRIM(TO_CHAR(HIRED))                        AS HIRED,
         TRIM(TO_CHAR(TIME_TO_OFFER_ACCEPT_DAYS))    AS TIME_TO_OFFER_ACCEPT_DAYS,
         TRIM(TO_CHAR(TIME_TO_OFFER_REJECT_DAYS))    AS TIME_TO_OFFER_REJECT_DAYS,
         TRIM(TO_CHAR(CANDIDATE_START_DATE))         AS CANDIDATE_START_DATE,
         TRIM(TO_CHAR(REFERRED_BY))                  AS REFERRED_BY,
         TRIM(TO_CHAR(CREATED_DATE))                 AS CREATED_DATE,
         TRIM(TO_CHAR(DATE_TIME_COMPLETED))          AS DATE_TIME_COMPLETED,
         TRIM(TO_CHAR(UPDATED_BY))                   AS UPDATED_BY,
         TRIM(TO_CHAR(UPDATED_ON))                   AS UPDATED_ON,
         TRIM(TO_CHAR(RECRUITER))                    AS RECRUITER,
         TRIM(TO_CHAR(CANDIDATE_TAGS))               AS CANDIDATE_TAGS,
         TRIM(TO_CHAR(CANDIDATE_POOL))               AS CANDIDATE_POOL,
         TRIM(TO_CHAR(ETL_BATCHID))                  AS ETL_BATCHID
  FROM (
    SELECT
      ORA_HASH(
        COALESCE(TRIM(TO_CHAR(JOB_APPLICATION)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CANDIDATE_ID)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(POSITION)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(EMPLOYEE_ID)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(SOEID)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(JOB_REQUISITION)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(ORIGINAL_JOB_REQUISITION)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(ADDED_DATE)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(SOURCE_CATEGORY)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(SOURCE)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(RECRUITING_AGENCY)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CANDIDATE_STATUS)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(LAST_RECRUITING_STAGE)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(JOB_APPLICATION_STEP)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(LAST_RECRUITING_STAGE_NUMBER)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(FINAL_DISPOSITION_REASON)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(OFFER_STATUS)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(HIRED)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(TIME_TO_OFFER_ACCEPT_DAYS)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(TIME_TO_OFFER_REJECT_DAYS)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CANDIDATE_START_DATE)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(REFERRED_BY)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CREATED_DATE)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(DATE_TIME_COMPLETED)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(UPDATED_BY)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(UPDATED_ON)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(RECRUITER)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CANDIDATE_TAGS)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(CANDIDATE_POOL)),'#') || '|' ||
        COALESCE(TRIM(TO_CHAR(ETL_BATCHID)),'#')
      ) AS sig_hash,
      JOB_APPLICATION, CANDIDATE_ID, POSITION, EMPLOYEE_ID, SOEID,
      JOB_REQUISITION, ORIGINAL_JOB_REQUISITION, ADDED_DATE, SOURCE_CATEGORY,
      SOURCE, RECRUITING_AGENCY, CANDIDATE_STATUS, LAST_RECRUITING_STAGE,
      JOB_APPLICATION_STEP, LAST_RECRUITING_STAGE_NUMBER, FINAL_DISPOSITION_REASON,
      OFFER_STATUS, HIRED, TIME_TO_OFFER_ACCEPT_DAYS, TIME_TO_OFFER_REJECT_DAYS,
      CANDIDATE_START_DATE, REFERRED_BY, CREATED_DATE, DATE_TIME_COMPLETED,
      UPDATED_BY, UPDATED_ON, RECRUITER, CANDIDATE_TAGS, CANDIDATE_POOL, ETL_BATCHID
    FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP
    WHERE TRIM(TO_CHAR(ETL_BATCHID)) = '20251124'
  )
),

-- diffs: one row per differing column per aligned rn
diffs AS (
  SELECT rn, 'JOB_APPLICATION' AS column_name, COALESCE(TRIM(TO_CHAR(m.JOB_APPLICATION)),'<NULL>') AS main_val, COALESCE(TRIM(TO_CHAR(t.JOB_APPLICATION)),'<NULL>') AS temp_val
  FROM m FULL JOIN t USING(rn)
  WHERE COALESCE(TRIM(TO_CHAR(m.JOB_APPLICATION)),'<NULL>') <> COALESCE(TRIM(TO_CHAR(t.JOB_APPLICATION)),'<NULL>')

  UNION ALL

  SELECT rn, 'CANDIDATE_ID', COALESCE(TRIM(TO_CHAR(m.CANDIDATE_ID)),'<NULL>'), COALESCE(TRIM(TO_CHAR(t.CANDIDATE_ID)),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE COALESCE(TRIM(TO_CHAR(m.CANDIDATE_ID)),'<NULL>') <> COALESCE(TRIM(TO_CHAR(t.CANDIDATE_ID)),'<NULL>')

  UNION ALL

  SELECT rn, 'POSITION', COALESCE(TRIM(TO_CHAR(m.POSITION)),'<NULL>'), COALESCE(TRIM(TO_CHAR(t.POSITION)),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE COALESCE(TRIM(TO_CHAR(m.POSITION)),'<NULL>') <> COALESCE(TRIM(TO_CHAR(t.POSITION)),'<NULL>')

  UNION ALL

  SELECT rn, 'EMPLOYEE_ID', COALESCE(TRIM(TO_CHAR(m.EMPLOYEE_ID)),'<NULL>'), COALESCE(TRIM(TO_CHAR(t.EMPLOYEE_ID)),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE COALESCE(TRIM(TO_CHAR(m.EMPLOYEE_ID)),'<NULL>') <> COALESCE(TRIM(TO_CHAR(t.EMPLOYEE_ID)),'<NULL>')

  UNION ALL

  SELECT rn, 'SOEID', COALESCE(TRIM(TO_CHAR(m.SOEID)),'<NULL>'), COALESCE(TRIM(TO_CHAR(t.SOEID)),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE COALESCE(TRIM(TO_CHAR(m.SOEID)),'<NULL>') <> COALESCE(TRIM(TO_CHAR(t.SOEID)),'<NULL>')

  UNION ALL

  SELECT rn, 'JOB_REQUISITION', COALESCE(TRIM(TO_CHAR(m.JOB_REQUISITION)),'<NULL>'), COALESCE(TRIM(TO_CHAR(t.JOB_REQUISITION)),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE COALESCE(TRIM(TO_CHAR(m.JOB_REQUISITION)),'<NULL>') <> COALESCE(TRIM(TO_CHAR(t.JOB_REQUISITION)),'<NULL>')

  UNION ALL

  SELECT rn, 'ORIGINAL_JOB_REQUISITION', COALESCE(TRIM(TO_CHAR(m.ORIGINAL_JOB_REQUISITION)),'<NULL>'), COALESCE(TRIM(TO_CHAR(t.ORIGINAL_JOB_REQUISITION)),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE COALESCE(TRIM(TO_CHAR(m.ORIGINAL_JOB_REQUISITION)),'<NULL>') <> COALESCE(TRIM(TO_CHAR(t.ORIGINAL_JOB_REQUISITION)),'<NULL>')

  UNION ALL

  SELECT rn, 'ADDED_DATE', COALESCE(TRIM(TO_CHAR(m.ADDED_DATE)),'<NULL>'), COALESCE(TRIM(TO_CHAR(t.ADDED_DATE)),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE COALESCE(TRIM(TO_CHAR(m.ADDED_DATE)),'<NULL>') <> COALESCE(TRIM(TO_CHAR(t.ADDED_DATE)),'<NULL>')

  UNION ALL

  SELECT rn, 'SOURCE_CATEGORY', COALESCE(TRIM(TO_CHAR(m.SOURCE_CATEGORY)),'<NULL>'), COALESCE(TRIM(TO_CHAR(t.SOURCE_CATEGORY)),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE COALESCE(TRIM(TO_CHAR(m.SOURCE_CATEGORY)),'<NULL>') <> COALESCE(TRIM(TO_CHAR(t.SOURCE_CATEGORY)),'<NULL>')

  UNION ALL

  SELECT rn, 'SOURCE', COALESCE(TRIM(TO_CHAR(m.SOURCE)),'<NULL>'), COALESCE(TRIM(TO_CHAR(t.SOURCE)),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE COALESCE(TRIM(TO_CHAR(m.SOURCE)),'<NULL>') <> COALESCE(TRIM(TO_CHAR(t.SOURCE)),'<NULL>')

  UNION ALL

  SELECT rn, 'RECRUITING_AGENCY', COALESCE(TRIM(TO_CHAR(m.RECRUITING_AGENCY)),'<NULL>'), COALESCE(TRIM(TO_CHAR(t.RECRUITING_AGENCY)),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE COALESCE(TRIM(TO_CHAR(m.RECRUITING_AGENCY)),'<NULL>') <> COALESCE(TRIM(TO_CHAR(t.RECRUITING_AGENCY)),'<NULL>')

  UNION ALL

  SELECT rn, 'CANDIDATE_STATUS', COALESCE(TRIM(TO_CHAR(m.CANDIDATE_STATUS)),'<NULL>'), COALESCE(TRIM(TO_CHAR(t.CANDIDATE_STATUS)),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE COALESCE(TRIM(TO_CHAR(m.CANDIDATE_STATUS)),'<NULL>') <> COALESCE(TRIM(TO_CHAR(t.CANDIDATE_STATUS)),'<NULL>')

  UNION ALL

  SELECT rn, 'LAST_RECRUITING_STAGE', COALESCE(TRIM(TO_CHAR(m.LAST_RECRUITING_STAGE)),'<NULL>'), COALESCE(TRIM(TO_CHAR(t.LAST_RECRUITING_STAGE)),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE COALESCE(TRIM(TO_CHAR(m.LAST_RECRUITING_STAGE)),'<NULL>') <> COALESCE(TRIM(TO_CHAR(t.LAST_RECRUITING_STAGE)),'<NULL>')

  UNION ALL

  SELECT rn, 'JOB_APPLICATION_STEP', COALESCE(TRIM(TO_CHAR(m.JOB_APPLICATION_STEP)),'<NULL>'), COALESCE(TRIM(TO_CHAR(t.JOB_APPLICATION_STEP)),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE COALESCE(TRIM(TO_CHAR(m.JOB_APPLICATION_STEP)),'<NULL>') <> COALESCE(TRIM(TO_CHAR(t.JOB_APPLICATION_STEP)),'<NULL>')

  UNION ALL

  SELECT rn, 'LAST_RECRUITING_STAGE_NUMBER', COALESCE(TRIM(TO_CHAR(m.LAST_RECRUITING_STAGE_NUMBER)),'<NULL>'), COALESCE(TRIM(TO_CHAR(t.LAST_RECRUITING_STAGE_NUMBER)),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE COALESCE(TRIM(TO_CHAR(m.LAST_RECRUITING_STAGE_NUMBER)),'<NULL>') <> COALESCE(TRIM(TO_CHAR(t.LAST_RECRUITING_STAGE_NUMBER)),'<NULL>')

  UNION ALL

  SELECT rn, 'FINAL_DISPOSITION_REASON', COALESCE(TRIM(TO_CHAR(m.FINAL_DISPOSITION_REASON)),'<NULL>'), COALESCE(TRIM(TO_CHAR(t.FINAL_DISPOSITION_REASON)),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE COALESCE(TRIM(TO_CHAR(m.FINAL_DISPOSITION_REASON)),'<NULL>') <> COALESCE(TRIM(TO_CHAR(t.FINAL_DISPOSITION_REASON)),'<NULL>')

  UNION ALL

  SELECT rn, 'OFFER_STATUS', COALESCE(TRIM(TO_CHAR(m.OFFER_STATUS)),'<NULL>'), COALESCE(TRIM(TO_CHAR(t.OFFER_STATUS)),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE COALESCE(TRIM(TO_CHAR(m.OFFER_STATUS)),'<NULL>') <> COALESCE(TRIM(TO_CHAR(t.OFFER_STATUS)),'<NULL>')

  UNION ALL

  SELECT rn, 'HIRED', COALESCE(TRIM(TO_CHAR(m.HIRED)),'<NULL>'), COALESCE(TRIM(TO_CHAR(t.HIRED)),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE COALESCE(TRIM(TO_CHAR(m.HIRED)),'<NULL>') <> COALESCE(TRIM(TO_CHAR(t.HIRED)),'<NULL>')

  UNION ALL

  SELECT rn, 'TIME_TO_OFFER_ACCEPT_DAYS', COALESCE(TRIM(TO_CHAR(m.TIME_TO_OFFER_ACCEPT_DAYS)),'<NULL>'), COALESCE(TRIM(TO_CHAR(t.TIME_TO_OFFER_ACCEPT_DAYS)),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE COALESCE(TRIM(TO_CHAR(m.TIME_TO_OFFER_ACCEPT_DAYS)),'<NULL>') <> COALESCE(TRIM(TO_CHAR(t.TIME_TO_OFFER_ACCEPT_DAYS)),'<NULL>')

  UNION ALL

  SELECT rn, 'TIME_TO_OFFER_REJECT_DAYS', COALESCE(TRIM(TO_CHAR(m.TIME_TO_OFFER_REJECT_DAYS)),'<NULL>'), COALESCE(TRIM(TO_CHAR(t.TIME_TO_OFFER_REJECT_DAYS)),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE COALESCE(TRIM(TO_CHAR(m.TIME_TO_OFFER_REJECT_DAYS)),'<NULL>') <> COALESCE(TRIM(TO_CHAR(t.TIME_TO_OFFER_REJECT_DAYS)),'<NULL>')

  UNION ALL

  SELECT rn, 'CANDIDATE_START_DATE', COALESCE(TRIM(TO_CHAR(m.CANDIDATE_START_DATE)),'<NULL>'), COALESCE(TRIM(TO_CHAR(t.CANDIDATE_START_DATE)),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE COALESCE(TRIM(TO_CHAR(m.CANDIDATE_START_DATE)),'<NULL>') <> COALESCE(TRIM(TO_CHAR(t.CANDIDATE_START_DATE)),'<NULL>')

  UNION ALL

  SELECT rn, 'REFERRED_BY', COALESCE(TRIM(TO_CHAR(m.REFERRED_BY)),'<NULL>'), COALESCE(TRIM(TO_CHAR(t.REFERRED_BY)),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE COALESCE(TRIM(TO_CHAR(m.REFERRED_BY)),'<NULL>') <> COALESCE(TRIM(TO_CHAR(t.REFERRED_BY)),'<NULL>')

  UNION ALL

  SELECT rn, 'CREATED_DATE', COALESCE(TRIM(TO_CHAR(m.CREATED_DATE)),'<NULL>'), COALESCE(TRIM(TO_CHAR(t.CREATED_DATE)),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE COALESCE(TRIM(TO_CHAR(m.CREATED_DATE)),'<NULL>') <> COALESCE(TRIM(TO_CHAR(t.CREATED_DATE)),'<NULL>')

  UNION ALL

  SELECT rn, 'DATE_TIME_COMPLETED', COALESCE(TRIM(TO_CHAR(m.DATE_TIME_COMPLETED)),'<NULL>'), COALESCE(TRIM(TO_CHAR(t.DATE_TIME_COMPLETED)),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE COALESCE(TRIM(TO_CHAR(m.DATE_TIME_COMPLETED)),'<NULL>') <> COALESCE(TRIM(TO_CHAR(t.DATE_TIME_COMPLETED)),'<NULL>')

  UNION ALL

  SELECT rn, 'UPDATED_BY', COALESCE(TRIM(TO_CHAR(m.UPDATED_BY)),'<NULL>'), COALESCE(TRIM(TO_CHAR(t.UPDATED_BY)),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE COALESCE(TRIM(TO_CHAR(m.UPDATED_BY)),'<NULL>') <> COALESCE(TRIM(TO_CHAR(t.UPDATED_BY)),'<NULL>')

  UNION ALL

  SELECT rn, 'UPDATED_ON', COALESCE(TRIM(TO_CHAR(m.UPDATED_ON)),'<NULL>'), COALESCE(TRIM(TO_CHAR(t.UPDATED_ON)),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE COALESCE(TRIM(TO_CHAR(m.UPDATED_ON)),'<NULL>') <> COALESCE(TRIM(TO_CHAR(t.UPDATED_ON)),'<NULL>')

  UNION ALL

  SELECT rn, 'RECRUITER', COALESCE(TRIM(TO_CHAR(m.RECRUITER)),'<NULL>'), COALESCE(TRIM(TO_CHAR(t.RECRUITER)),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE COALESCE(TRIM(TO_CHAR(m.RECRUITER)),'<NULL>') <> COALESCE(TRIM(TO_CHAR(t.RECRUITER)),'<NULL>')

  UNION ALL

  SELECT rn, 'CANDIDATE_TAGS', COALESCE(TRIM(TO_CHAR(m.CANDIDATE_TAGS)),'<NULL>'), COALESCE(TRIM(TO_CHAR(t.CANDIDATE_TAGS)),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE COALESCE(TRIM(TO_CHAR(m.CANDIDATE_TAGS)),'<NULL>') <> COALESCE(TRIM(TO_CHAR(t.CANDIDATE_TAGS)),'<NULL>')

  UNION ALL

  SELECT rn, 'CANDIDATE_POOL', COALESCE(TRIM(TO_CHAR(m.CANDIDATE_POOL)),'<NULL>'), COALESCE(TRIM(TO_CHAR(t.CANDIDATE_POOL)),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE COALESCE(TRIM(TO_CHAR(m.CANDIDATE_POOL)),'<NULL>') <> COALESCE(TRIM(TO_CHAR(t.CANDIDATE_POOL)),'<NULL>')

  UNION ALL

  SELECT rn, 'ETL_BATCHID', COALESCE(TRIM(TO_CHAR(m.ETL_BATCHID)),'<NULL>'), COALESCE(TRIM(TO_CHAR(t.ETL_BATCHID)),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE COALESCE(TRIM(TO_CHAR(m.ETL_BATCHID)),'<NULL>') <> COALESCE(TRIM(TO_CHAR(t.ETL_BATCHID)),'<NULL>')
)

-- final summary
SELECT
  rn,
  LISTAGG(column_name, ', ') WITHIN GROUP (ORDER BY column_name) AS differing_columns,
  COUNT(*) AS diff_count,
  MIN(main_val) KEEP (DENSE_RANK FIRST ORDER BY column_name) AS sample_main_val,
  MIN(temp_val) KEEP (DENSE_RANK FIRST ORDER BY column_name) AS sample_temp_val
FROM diffs
GROUP BY rn
ORDER BY diff_count DESC, rn
FETCH FIRST 200 ROWS ONLY;






























WITH
-- -----------------------
-- aligned MAIN rows (m) using numeric hash signature; filtered by ETL_BATCHID=20251124
-- -----------------------
m AS (
  SELECT ROW_NUMBER() OVER (ORDER BY sig_hash, ROWID) AS rn,
         JOB_APPLICATION,
         TO_CHAR(CANDIDATE_ID)                 AS CANDIDATE_ID,
         TO_CHAR(POSITION)                     AS POSITION,
         TO_CHAR(EMPLOYEE_ID)                  AS EMPLOYEE_ID,
         TO_CHAR(SOEID)                        AS SOEID,
         TO_CHAR(JOB_REQUISITION)              AS JOB_REQUISITION,
         TO_CHAR(ORIGINAL_JOB_REQUISITION)     AS ORIGINAL_JOB_REQUISITION,
         TO_CHAR(ADDED_DATE,'YYYYMMDDHH24MISS')AS ADDED_DATE,
         TO_CHAR(SOURCE_CATEGORY)              AS SOURCE_CATEGORY,
         TO_CHAR(SOURCE)                       AS SOURCE,
         TO_CHAR(RECRUITING_AGENCY)            AS RECRUITING_AGENCY,
         TO_CHAR(CANDIDATE_STATUS)             AS CANDIDATE_STATUS,
         TO_CHAR(LAST_RECRUITING_STAGE)        AS LAST_RECRUITING_STAGE,
         TO_CHAR(JOB_APPLICATION_STEP)         AS JOB_APPLICATION_STEP,
         TO_CHAR(LAST_RECRUITING_STAGE_NUMBER) AS LAST_RECRUITING_STAGE_NUMBER,
         TO_CHAR(FINAL_DISPOSITION_REASON)     AS FINAL_DISPOSITION_REASON,
         TO_CHAR(OFFER_STATUS)                 AS OFFER_STATUS,
         TO_CHAR(HIRED)                        AS HIRED,
         TO_CHAR(TIME_TO_OFFER_ACCEPT_DAYS)    AS TIME_TO_OFFER_ACCEPT_DAYS,
         TO_CHAR(TIME_TO_OFFER_REJECT_DAYS)    AS TIME_TO_OFFER_REJECT_DAYS,
         TO_CHAR(CANDIDATE_START_DATE,'YYYYMMDDHH24MISS') AS CANDIDATE_START_DATE,
         TO_CHAR(REFERRED_BY)                  AS REFERRED_BY,
         TO_CHAR(CREATED_DATE,'YYYYMMDDHH24MISS')       AS CREATED_DATE,
         TO_CHAR(DATE_TIME_COMPLETED,'YYYYMMDDHH24MISS')AS DATE_TIME_COMPLETED,
         TO_CHAR(UPDATED_BY)                   AS UPDATED_BY,
         TO_CHAR(UPDATED_ON,'YYYYMMDDHH24MISS')AS UPDATED_ON,
         TO_CHAR(RECRUITER)                    AS RECRUITER,
         TO_CHAR(CANDIDATE_TAGS)               AS CANDIDATE_TAGS,
         TO_CHAR(CANDIDATE_POOL)               AS CANDIDATE_POOL,
         TO_CHAR(ETL_BATCHID)                  AS ETL_BATCHID
  FROM (
    SELECT
      ORA_HASH(
        NVL(TRIM(TO_CHAR(JOB_APPLICATION)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(CANDIDATE_ID)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(POSITION)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(EMPLOYEE_ID)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(SOEID)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(JOB_REQUISITION)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(ORIGINAL_JOB_REQUISITION)),'#') || '|' ||
        NVL(TO_CHAR(ADDED_DATE,'YYYYMMDDHH24MISS'),'#') || '|' ||
        NVL(TRIM(TO_CHAR(SOURCE_CATEGORY)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(SOURCE)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(RECRUITING_AGENCY)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(CANDIDATE_STATUS)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(LAST_RECRUITING_STAGE)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(JOB_APPLICATION_STEP)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(LAST_RECRUITING_STAGE_NUMBER)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(FINAL_DISPOSITION_REASON)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(OFFER_STATUS)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(HIRED)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(TIME_TO_OFFER_ACCEPT_DAYS)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(TIME_TO_OFFER_REJECT_DAYS)),'#') || '|' ||
        NVL(TO_CHAR(CANDIDATE_START_DATE,'YYYYMMDDHH24MISS'),'#') || '|' ||
        NVL(TRIM(TO_CHAR(REFERRED_BY)),'#') || '|' ||
        NVL(TO_CHAR(CREATED_DATE,'YYYYMMDDHH24MISS'),'#') || '|' ||
        NVL(TO_CHAR(DATE_TIME_COMPLETED,'YYYYMMDDHH24MISS'),'#') || '|' ||
        NVL(TRIM(TO_CHAR(UPDATED_BY)),'#') || '|' ||
        NVL(TO_CHAR(UPDATED_ON,'YYYYMMDDHH24MISS'),'#') || '|' ||
        NVL(TRIM(TO_CHAR(RECRUITER)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(CANDIDATE_TAGS)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(CANDIDATE_POOL)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(ETL_BATCHID)),'#')
      ) AS sig_hash,
      JOB_APPLICATION, CANDIDATE_ID, POSITION, EMPLOYEE_ID, SOEID,
      JOB_REQUISITION, ORIGINAL_JOB_REQUISITION, ADDED_DATE, SOURCE_CATEGORY,
      SOURCE, RECRUITING_AGENCY, CANDIDATE_STATUS, LAST_RECRUITING_STAGE,
      JOB_APPLICATION_STEP, LAST_RECRUITING_STAGE_NUMBER, FINAL_DISPOSITION_REASON,
      OFFER_STATUS, HIRED, TIME_TO_OFFER_ACCEPT_DAYS, TIME_TO_OFFER_REJECT_DAYS,
      CANDIDATE_START_DATE, REFERRED_BY, CREATED_DATE, DATE_TIME_COMPLETED,
      UPDATED_BY, UPDATED_ON, RECRUITER, CANDIDATE_TAGS, CANDIDATE_POOL, ETL_BATCHID
    FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION
    WHERE TRIM(TO_CHAR(ETL_BATCHID)) = '20251124'
  )
),

-- -----------------------
-- aligned TEMP rows (t) using same hash expression; filtered by ETL_BATCHID=20251124
-- -----------------------
t AS (
  SELECT ROW_NUMBER() OVER (ORDER BY sig_hash, ROWID) AS rn,
         JOB_APPLICATION,
         TO_CHAR(CANDIDATE_ID)                 AS CANDIDATE_ID,
         TO_CHAR(POSITION)                     AS POSITION,
         TO_CHAR(EMPLOYEE_ID)                  AS EMPLOYEE_ID,
         TO_CHAR(SOEID)                        AS SOEID,
         TO_CHAR(JOB_REQUISITION)              AS JOB_REQUISITION,
         TO_CHAR(ORIGINAL_JOB_REQUISITION)     AS ORIGINAL_JOB_REQUISITION,
         TO_CHAR(ADDED_DATE,'YYYYMMDDHH24MISS')AS ADDED_DATE,
         TO_CHAR(SOURCE_CATEGORY)              AS SOURCE_CATEGORY,
         TO_CHAR(SOURCE)                       AS SOURCE,
         TO_CHAR(RECRUITING_AGENCY)            AS RECRUITING_AGENCY,
         TO_CHAR(CANDIDATE_STATUS)             AS CANDIDATE_STATUS,
         TO_CHAR(LAST_RECRUITING_STAGE)        AS LAST_RECRUITING_STAGE,
         TO_CHAR(JOB_APPLICATION_STEP)         AS JOB_APPLICATION_STEP,
         TO_CHAR(LAST_RECRUITING_STAGE_NUMBER) AS LAST_RECRUITING_STAGE_NUMBER,
         TO_CHAR(FINAL_DISPOSITION_REASON)     AS FINAL_DISPOSITION_REASON,
         TO_CHAR(OFFER_STATUS)                 AS OFFER_STATUS,
         TO_CHAR(HIRED)                        AS HIRED,
         TO_CHAR(TIME_TO_OFFER_ACCEPT_DAYS)    AS TIME_TO_OFFER_ACCEPT_DAYS,
         TO_CHAR(TIME_TO_OFFER_REJECT_DAYS)    AS TIME_TO_OFFER_REJECT_DAYS,
         TO_CHAR(CANDIDATE_START_DATE,'YYYYMMDDHH24MISS') AS CANDIDATE_START_DATE,
         TO_CHAR(REFERRED_BY)                  AS REFERRED_BY,
         TO_CHAR(CREATED_DATE,'YYYYMMDDHH24MISS')       AS CREATED_DATE,
         TO_CHAR(DATE_TIME_COMPLETED,'YYYYMMDDHH24MISS')AS DATE_TIME_COMPLETED,
         TO_CHAR(UPDATED_BY)                   AS UPDATED_BY,
         TO_CHAR(UPDATED_ON,'YYYYMMDDHH24MISS')AS UPDATED_ON,
         TO_CHAR(RECRUITER)                    AS RECRUITER,
         TO_CHAR(CANDIDATE_TAGS)               AS CANDIDATE_TAGS,
         TO_CHAR(CANDIDATE_POOL)               AS CANDIDATE_POOL,
         TO_CHAR(ETL_BATCHID)                  AS ETL_BATCHID
  FROM (
    SELECT
      ORA_HASH(
        NVL(TRIM(TO_CHAR(JOB_APPLICATION)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(CANDIDATE_ID)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(POSITION)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(EMPLOYEE_ID)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(SOEID)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(JOB_REQUISITION)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(ORIGINAL_JOB_REQUISITION)),'#') || '|' ||
        NVL(TO_CHAR(ADDED_DATE,'YYYYMMDDHH24MISS'),'#') || '|' ||
        NVL(TRIM(TO_CHAR(SOURCE_CATEGORY)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(SOURCE)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(RECRUITING_AGENCY)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(CANDIDATE_STATUS)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(LAST_RECRUITING_STAGE)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(JOB_APPLICATION_STEP)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(LAST_RECRUITING_STAGE_NUMBER)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(FINAL_DISPOSITION_REASON)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(OFFER_STATUS)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(HIRED)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(TIME_TO_OFFER_ACCEPT_DAYS)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(TIME_TO_OFFER_REJECT_DAYS)),'#') || '|' ||
        NVL(TO_CHAR(CANDIDATE_START_DATE,'YYYYMMDDHH24MISS'),'#') || '|' ||
        NVL(TRIM(TO_CHAR(REFERRED_BY)),'#') || '|' ||
        NVL(TO_CHAR(CREATED_DATE,'YYYYMMDDHH24MISS'),'#') || '|' ||
        NVL(TO_CHAR(DATE_TIME_COMPLETED,'YYYYMMDDHH24MISS'),'#') || '|' ||
        NVL(TRIM(TO_CHAR(UPDATED_BY)),'#') || '|' ||
        NVL(TO_CHAR(UPDATED_ON,'YYYYMMDDHH24MISS'),'#') || '|' ||
        NVL(TRIM(TO_CHAR(RECRUITER)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(CANDIDATE_TAGS)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(CANDIDATE_POOL)),'#') || '|' ||
        NVL(TRIM(TO_CHAR(ETL_BATCHID)),'#')
      ) AS sig_hash,
      JOB_APPLICATION, CANDIDATE_ID, POSITION, EMPLOYEE_ID, SOEID,
      JOB_REQUISITION, ORIGINAL_JOB_REQUISITION, ADDED_DATE, SOURCE_CATEGORY,
      SOURCE, RECRUITING_AGENCY, CANDIDATE_STATUS, LAST_RECRUITING_STAGE,
      JOB_APPLICATION_STEP, LAST_RECRUITING_STAGE_NUMBER, FINAL_DISPOSITION_REASON,
      OFFER_STATUS, HIRED, TIME_TO_OFFER_ACCEPT_DAYS, TIME_TO_OFFER_REJECT_DAYS,
      CANDIDATE_START_DATE, REFERRED_BY, CREATED_DATE, DATE_TIME_COMPLETED,
      UPDATED_BY, UPDATED_ON, RECRUITER, CANDIDATE_TAGS, CANDIDATE_POOL, ETL_BATCHID
    FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP
    WHERE TRIM(TO_CHAR(ETL_BATCHID)) = '20251124'
  )
),

-- -----------------------
-- diffs: one row per differing column per aligned rn
-- -----------------------
diffs AS (
  SELECT rn, 'JOB_APPLICATION' AS column_name, NVL(TO_CHAR(m.JOB_APPLICATION),'<NULL>') AS main_val, NVL(TO_CHAR(t.JOB_APPLICATION),'<NULL>') AS temp_val
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.JOB_APPLICATION),'<NULL>') <> NVL(TO_CHAR(t.JOB_APPLICATION),'<NULL>')

  UNION ALL

  SELECT rn, 'CANDIDATE_ID', NVL(TO_CHAR(m.CANDIDATE_ID),'<NULL>'), NVL(TO_CHAR(t.CANDIDATE_ID),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.CANDIDATE_ID),'<NULL>') <> NVL(TO_CHAR(t.CANDIDATE_ID),'<NULL>')

  UNION ALL

  SELECT rn, 'POSITION', NVL(TO_CHAR(m.POSITION),'<NULL>'), NVL(TO_CHAR(t.POSITION),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.POSITION),'<NULL>') <> NVL(TO_CHAR(t.POSITION),'<NULL>')

  UNION ALL

  SELECT rn, 'EMPLOYEE_ID', NVL(TO_CHAR(m.EMPLOYEE_ID),'<NULL>'), NVL(TO_CHAR(t.EMPLOYEE_ID),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.EMPLOYEE_ID),'<NULL>') <> NVL(TO_CHAR(t.EMPLOYEE_ID),'<NULL>')

  UNION ALL

  SELECT rn, 'SOEID', NVL(TO_CHAR(m.SOEID),'<NULL>'), NVL(TO_CHAR(t.SOEID),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.SOEID),'<NULL>') <> NVL(TO_CHAR(t.SOEID),'<NULL>')

  UNION ALL

  SELECT rn, 'JOB_REQUISITION', NVL(TO_CHAR(m.JOB_REQUISITION),'<NULL>'), NVL(TO_CHAR(t.JOB_REQUISITION),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.JOB_REQUISITION),'<NULL>') <> NVL(TO_CHAR(t.JOB_REQUISITION),'<NULL>')

  UNION ALL

  SELECT rn, 'ORIGINAL_JOB_REQUISITION', NVL(TO_CHAR(m.ORIGINAL_JOB_REQUISITION),'<NULL>'), NVL(TO_CHAR(t.ORIGINAL_JOB_REQUISITION),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.ORIGINAL_JOB_REQUISITION),'<NULL>') <> NVL(TO_CHAR(t.ORIGINAL_JOB_REQUISITION),'<NULL>')

  UNION ALL

  SELECT rn, 'ADDED_DATE', NVL(TO_CHAR(m.ADDED_DATE,'YYYY-MM-DD HH24:MI:SS'),'<NULL>'), NVL(TO_CHAR(t.ADDED_DATE,'YYYY-MM-DD HH24:MI:SS'),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.ADDED_DATE,'YYYYMMDDHH24MISS'),'<NULL>') <> NVL(TO_CHAR(t.ADDED_DATE,'YYYYMMDDHH24MISS'),'<NULL>')

  UNION ALL

  SELECT rn, 'SOURCE_CATEGORY', NVL(TO_CHAR(m.SOURCE_CATEGORY),'<NULL>'), NVL(TO_CHAR(t.SOURCE_CATEGORY),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.SOURCE_CATEGORY),'<NULL>') <> NVL(TO_CHAR(t.SOURCE_CATEGORY),'<NULL>')

  UNION ALL

  SELECT rn, 'SOURCE', NVL(TO_CHAR(m.SOURCE),'<NULL>'), NVL(TO_CHAR(t.SOURCE),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.SOURCE),'<NULL>') <> NVL(TO_CHAR(t.SOURCE),'<NULL>')

  UNION ALL

  SELECT rn, 'RECRUITING_AGENCY', NVL(TO_CHAR(m.RECRUITING_AGENCY),'<NULL>'), NVL(TO_CHAR(t.RECRUITING_AGENCY),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.RECRUITING_AGENCY),'<NULL>') <> NVL(TO_CHAR(t.RECRUITING_AGENCY),'<NULL>')

  UNION ALL

  SELECT rn, 'CANDIDATE_STATUS', NVL(TO_CHAR(m.CANDIDATE_STATUS),'<NULL>'), NVL(TO_CHAR(t.CANDIDATE_STATUS),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.CANDIDATE_STATUS),'<NULL>') <> NVL(TO_CHAR(t.CANDIDATE_STATUS),'<NULL>')

  UNION ALL

  SELECT rn, 'LAST_RECRUITING_STAGE', NVL(TO_CHAR(m.LAST_RECRUITING_STAGE),'<NULL>'), NVL(TO_CHAR(t.LAST_RECRUITING_STAGE),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.LAST_RECRUITING_STAGE),'<NULL>') <> NVL(TO_CHAR(t.LAST_RECRUITING_STAGE),'<NULL>')

  UNION ALL

  SELECT rn, 'JOB_APPLICATION_STEP', NVL(TO_CHAR(m.JOB_APPLICATION_STEP),'<NULL>'), NVL(TO_CHAR(t.JOB_APPLICATION_STEP),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.JOB_APPLICATION_STEP),'<NULL>') <> NVL(TO_CHAR(t.JOB_APPLICATION_STEP),'<NULL>')

  UNION ALL

  SELECT rn, 'LAST_RECRUITING_STAGE_NUMBER', NVL(TO_CHAR(m.LAST_RECRUITING_STAGE_NUMBER),'<NULL>'), NVL(TO_CHAR(t.LAST_RECRUITING_STAGE_NUMBER),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.LAST_RECRUITING_STAGE_NUMBER),'<NULL>') <> NVL(TO_CHAR(t.LAST_RECRUITING_STAGE_NUMBER),'<NULL>')

  UNION ALL

  SELECT rn, 'FINAL_DISPOSITION_REASON', NVL(TO_CHAR(m.FINAL_DISPOSITION_REASON),'<NULL>'), NVL(TO_CHAR(t.FINAL_DISPOSITION_REASON),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.FINAL_DISPOSITION_REASON),'<NULL>') <> NVL(TO_CHAR(t.FINAL_DISPOSITION_REASON),'<NULL>')

  UNION ALL

  SELECT rn, 'OFFER_STATUS', NVL(TO_CHAR(m.OFFER_STATUS),'<NULL>'), NVL(TO_CHAR(t.OFFER_STATUS),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.OFFER_STATUS),'<NULL>') <> NVL(TO_CHAR(t.OFFER_STATUS),'<NULL>')

  UNION ALL

  SELECT rn, 'HIRED', NVL(TO_CHAR(m.HIRED),'<NULL>'), NVL(TO_CHAR(t.HIRED),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.HIRED),'<NULL>') <> NVL(TO_CHAR(t.HIRED),'<NULL>')

  UNION ALL

  SELECT rn, 'TIME_TO_OFFER_ACCEPT_DAYS', NVL(TO_CHAR(m.TIME_TO_OFFER_ACCEPT_DAYS),'<NULL>'), NVL(TO_CHAR(t.TIME_TO_OFFER_ACCEPT_DAYS),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.TIME_TO_OFFER_ACCEPT_DAYS),'<NULL>') <> NVL(TO_CHAR(t.TIME_TO_OFFER_ACCEPT_DAYS),'<NULL>')

  UNION ALL

  SELECT rn, 'TIME_TO_OFFER_REJECT_DAYS', NVL(TO_CHAR(m.TIME_TO_OFFER_REJECT_DAYS),'<NULL>'), NVL(TO_CHAR(t.TIME_TO_OFFER_REJECT_DAYS),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.TIME_TO_OFFER_REJECT_DAYS),'<NULL>') <> NVL(TO_CHAR(t.TIME_TO_OFFER_REJECT_DAYS),'<NULL>')

  UNION ALL

  SELECT rn, 'CANDIDATE_START_DATE', NVL(TO_CHAR(m.CANDIDATE_START_DATE,'YYYY-MM-DD HH24:MI:SS'),'<NULL>'), NVL(TO_CHAR(t.CANDIDATE_START_DATE,'YYYY-MM-DD HH24:MI:SS'),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.CANDIDATE_START_DATE,'YYYYMMDDHH24MISS'),'<NULL>') <> NVL(TO_CHAR(t.CANDIDATE_START_DATE,'YYYYMMDDHH24MISS'),'<NULL>')

  UNION ALL

  SELECT rn, 'REFERRED_BY', NVL(TO_CHAR(m.REFERRED_BY),'<NULL>'), NVL(TO_CHAR(t.REFERRED_BY),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.REFERRED_BY),'<NULL>') <> NVL(TO_CHAR(t.REFERRED_BY),'<NULL>')

  UNION ALL

  SELECT rn, 'CREATED_DATE', NVL(TO_CHAR(m.CREATED_DATE,'YYYY-MM-DD HH24:MI:SS'),'<NULL>'), NVL(TO_CHAR(t.CREATED_DATE,'YYYY-MM-DD HH24:MI:SS'),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.CREATED_DATE,'YYYYMMDDHH24MISS'),'<NULL>') <> NVL(TO_CHAR(t.CREATED_DATE,'YYYYMMDDHH24MISS'),'<NULL>')

  UNION ALL

  SELECT rn, 'DATE_TIME_COMPLETED', NVL(TO_CHAR(m.DATE_TIME_COMPLETED,'YYYY-MM-DD HH24:MI:SS'),'<NULL>'), NVL(TO_CHAR(t.DATE_TIME_COMPLETED,'YYYY-MM-DD HH24:MI:SS'),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.DATE_TIME_COMPLETED,'YYYYMMDDHH24MISS'),'<NULL>') <> NVL(TO_CHAR(t.DATE_TIME_COMPLETED,'YYYYMMDDHH24MISS'),'<NULL>')

  UNION ALL

  SELECT rn, 'UPDATED_BY', NVL(TO_CHAR(m.UPDATED_BY),'<NULL>'), NVL(TO_CHAR(t.UPDATED_BY),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.UPDATED_BY),'<NULL>') <> NVL(TO_CHAR(t.UPDATED_BY),'<NULL>')

  UNION ALL

  SELECT rn, 'UPDATED_ON', NVL(TO_CHAR(m.UPDATED_ON,'YYYY-MM-DD HH24:MI:SS'),'<NULL>'), NVL(TO_CHAR(t.UPDATED_ON,'YYYY-MM-DD HH24:MI:SS'),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.UPDATED_ON,'YYYYMMDDHH24MISS'),'<NULL>') <> NVL(TO_CHAR(t.UPDATED_ON,'YYYYMMDDHH24MISS'),'<NULL>')

  UNION ALL

  SELECT rn, 'RECRUITER', NVL(TO_CHAR(m.RECRUITER),'<NULL>'), NVL(TO_CHAR(t.RECRUITER),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.RECRUITER),'<NULL>') <> NVL(TO_CHAR(t.RECRUITER),'<NULL>')

  UNION ALL

  SELECT rn, 'CANDIDATE_TAGS', NVL(TO_CHAR(m.CANDIDATE_TAGS),'<NULL>'), NVL(TO_CHAR(t.CANDIDATE_TAGS),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.CANDIDATE_TAGS),'<NULL>') <> NVL(TO_CHAR(t.CANDIDATE_TAGS),'<NULL>')

  UNION ALL

  SELECT rn, 'CANDIDATE_POOL', NVL(TO_CHAR(m.CANDIDATE_POOL),'<NULL>'), NVL(TO_CHAR(t.CANDIDATE_POOL),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.CANDIDATE_POOL),'<NULL>') <> NVL(TO_CHAR(t.CANDIDATE_POOL),'<NULL>')

  UNION ALL

  SELECT rn, 'ETL_BATCHID', NVL(TO_CHAR(m.ETL_BATCHID),'<NULL>'), NVL(TO_CHAR(t.ETL_BATCHID),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.ETL_BATCHID),'<NULL>') <> NVL(TO_CHAR(t.ETL_BATCHID),'<NULL>')
)

-- -----------------------
-- Final summary: one row per aligned rn (only rows that have differences)
-- -----------------------
SELECT
  rn,
  LISTAGG(column_name, ', ') WITHIN GROUP (ORDER BY column_name) AS differing_columns,
  COUNT(*) AS diff_count,
  MIN(main_val) KEEP (DENSE_RANK FIRST ORDER BY column_name) AS sample_main_val,
  MIN(temp_val) KEEP (DENSE_RANK FIRST ORDER BY column_name) AS sample_temp_val
FROM diffs
GROUP BY rn
ORDER BY diff_count DESC, rn
FETCH FIRST 200 ROWS ONLY;






















WITH
-- -----------------------
-- aligned MAIN rows (m) using numeric hash signature
-- -----------------------
m AS (
  SELECT ROW_NUMBER() OVER (ORDER BY sig_hash, ROWID) AS rn,
         JOB_APPLICATION,
         TO_CHAR(CANDIDATE_ID)                 AS CANDIDATE_ID,
         TO_CHAR(POSITION)                     AS POSITION,
         TO_CHAR(EMPLOYEE_ID)                  AS EMPLOYEE_ID,
         TO_CHAR(SOEID)                        AS SOEID,
         TO_CHAR(JOB_REQUISITION)              AS JOB_REQUISITION,
         TO_CHAR(ORIGINAL_JOB_REQUISITION)     AS ORIGINAL_JOB_REQUISITION,
         TO_CHAR(ADDED_DATE,'YYYYMMDDHH24MISS')AS ADDED_DATE,
         TO_CHAR(SOURCE_CATEGORY)              AS SOURCE_CATEGORY,
         TO_CHAR(SOURCE)                       AS SOURCE,
         TO_CHAR(RECRUITING_AGENCY)            AS RECRUITING_AGENCY,
         TO_CHAR(CANDIDATE_STATUS)             AS CANDIDATE_STATUS,
         TO_CHAR(LAST_RECRUITING_STAGE)        AS LAST_RECRUITING_STAGE,
         TO_CHAR(JOB_APPLICATION_STEP)         AS JOB_APPLICATION_STEP,
         TO_CHAR(LAST_RECRUITING_STAGE_NUMBER) AS LAST_RECRUITING_STAGE_NUMBER,
         TO_CHAR(FINAL_DISPOSITION_REASON)     AS FINAL_DISPOSITION_REASON,
         TO_CHAR(OFFER_STATUS)                 AS OFFER_STATUS,
         TO_CHAR(HIRED)                        AS HIRED,
         TO_CHAR(TIME_TO_OFFER_ACCEPT_DAYS)    AS TIME_TO_OFFER_ACCEPT_DAYS,
         TO_CHAR(TIME_TO_OFFER_REJECT_DAYS)    AS TIME_TO_OFFER_REJECT_DAYS,
         TO_CHAR(CANDIDATE_START_DATE,'YYYYMMDDHH24MISS') AS CANDIDATE_START_DATE,
         TO_CHAR(REFERRED_BY)                  AS REFERRED_BY,
         TO_CHAR(CREATED_DATE,'YYYYMMDDHH24MISS')       AS CREATED_DATE,
         TO_CHAR(DATE_TIME_COMPLETED,'YYYYMMDDHH24MISS')AS DATE_TIME_COMPLETED,
         TO_CHAR(UPDATED_BY)                   AS UPDATED_BY,
         TO_CHAR(UPDATED_ON,'YYYYMMDDHH24MISS')AS UPDATED_ON,
         TO_CHAR(RECRUITER)                    AS RECRUITER,
         TO_CHAR(CANDIDATE_TAGS)               AS CANDIDATE_TAGS,
         TO_CHAR(CANDIDATE_POOL)               AS CANDIDATE_POOL,
         TO_CHAR(ETL_BATCHID)                  AS ETL_BATCHID
  FROM (
    SELECT
      -- numeric hash signature; use ORA_HASH over the normalized concatenation
      ORA_HASH(
        NVL(TO_CHAR(JOB_APPLICATION),'#') || '|' ||
        NVL(TO_CHAR(CANDIDATE_ID),'#') || '|' ||
        NVL(TO_CHAR(POSITION),'#') || '|' ||
        NVL(TO_CHAR(EMPLOYEE_ID),'#') || '|' ||
        NVL(TO_CHAR(SOEID),'#') || '|' ||
        NVL(TO_CHAR(JOB_REQUISITION),'#') || '|' ||
        NVL(TO_CHAR(ORIGINAL_JOB_REQUISITION),'#') || '|' ||
        NVL(TO_CHAR(ADDED_DATE,'YYYYMMDDHH24MISS'),'#') || '|' ||
        NVL(TO_CHAR(SOURCE_CATEGORY),'#') || '|' ||
        NVL(TO_CHAR(SOURCE),'#') || '|' ||
        NVL(TO_CHAR(RECRUITING_AGENCY),'#') || '|' ||
        NVL(TO_CHAR(CANDIDATE_STATUS),'#') || '|' ||
        NVL(TO_CHAR(LAST_RECRUITING_STAGE),'#') || '|' ||
        NVL(TO_CHAR(JOB_APPLICATION_STEP),'#') || '|' ||
        NVL(TO_CHAR(LAST_RECRUITING_STAGE_NUMBER),'#') || '|' ||
        NVL(TO_CHAR(FINAL_DISPOSITION_REASON),'#') || '|' ||
        NVL(TO_CHAR(OFFER_STATUS),'#') || '|' ||
        NVL(TO_CHAR(HIRED),'#') || '|' ||
        NVL(TO_CHAR(TIME_TO_OFFER_ACCEPT_DAYS),'#') || '|' ||
        NVL(TO_CHAR(TIME_TO_OFFER_REJECT_DAYS),'#') || '|' ||
        NVL(TO_CHAR(CANDIDATE_START_DATE,'YYYYMMDDHH24MISS'),'#') || '|' ||
        NVL(TO_CHAR(REFERRED_BY),'#') || '|' ||
        NVL(TO_CHAR(CREATED_DATE,'YYYYMMDDHH24MISS'),'#') || '|' ||
        NVL(TO_CHAR(DATE_TIME_COMPLETED,'YYYYMMDDHH24MISS'),'#') || '|' ||
        NVL(TO_CHAR(UPDATED_BY),'#') || '|' ||
        NVL(TO_CHAR(UPDATED_ON,'YYYYMMDDHH24MISS'),'#') || '|' ||
        NVL(TO_CHAR(RECRUITER),'#') || '|' ||
        NVL(TO_CHAR(CANDIDATE_TAGS),'#') || '|' ||
        NVL(TO_CHAR(CANDIDATE_POOL),'#') || '|' ||
        NVL(TO_CHAR(ETL_BATCHID),'#')
      ) AS sig_hash,
      JOB_APPLICATION, CANDIDATE_ID, POSITION, EMPLOYEE_ID, SOEID,
      JOB_REQUISITION, ORIGINAL_JOB_REQUISITION, ADDED_DATE, SOURCE_CATEGORY,
      SOURCE, RECRUITING_AGENCY, CANDIDATE_STATUS, LAST_RECRUITING_STAGE,
      JOB_APPLICATION_STEP, LAST_RECRUITING_STAGE_NUMBER, FINAL_DISPOSITION_REASON,
      OFFER_STATUS, HIRED, TIME_TO_OFFER_ACCEPT_DAYS, TIME_TO_OFFER_REJECT_DAYS,
      CANDIDATE_START_DATE, REFERRED_BY, CREATED_DATE, DATE_TIME_COMPLETED,
      UPDATED_BY, UPDATED_ON, RECRUITER, CANDIDATE_TAGS, CANDIDATE_POOL, ETL_BATCHID
    FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION
  )
),

-- -----------------------
-- aligned TEMP rows (t) using same hash expression
-- -----------------------
t AS (
  SELECT ROW_NUMBER() OVER (ORDER BY sig_hash, ROWID) AS rn,
         JOB_APPLICATION,
         TO_CHAR(CANDIDATE_ID)                 AS CANDIDATE_ID,
         TO_CHAR(POSITION)                     AS POSITION,
         TO_CHAR(EMPLOYEE_ID)                  AS EMPLOYEE_ID,
         TO_CHAR(SOEID)                        AS SOEID,
         TO_CHAR(JOB_REQUISITION)              AS JOB_REQUISITION,
         TO_CHAR(ORIGINAL_JOB_REQUISITION)     AS ORIGINAL_JOB_REQUISITION,
         TO_CHAR(ADDED_DATE,'YYYYMMDDHH24MISS')AS ADDED_DATE,
         TO_CHAR(SOURCE_CATEGORY)              AS SOURCE_CATEGORY,
         TO_CHAR(SOURCE)                       AS SOURCE,
         TO_CHAR(RECRUITING_AGENCY)            AS RECRUITING_AGENCY,
         TO_CHAR(CANDIDATE_STATUS)             AS CANDIDATE_STATUS,
         TO_CHAR(LAST_RECRUITING_STAGE)        AS LAST_RECRUITING_STAGE,
         TO_CHAR(JOB_APPLICATION_STEP)         AS JOB_APPLICATION_STEP,
         TO_CHAR(LAST_RECRUITING_STAGE_NUMBER) AS LAST_RECRUITING_STAGE_NUMBER,
         TO_CHAR(FINAL_DISPOSITION_REASON)     AS FINAL_DISPOSITION_REASON,
         TO_CHAR(OFFER_STATUS)                 AS OFFER_STATUS,
         TO_CHAR(HIRED)                        AS HIRED,
         TO_CHAR(TIME_TO_OFFER_ACCEPT_DAYS)    AS TIME_TO_OFFER_ACCEPT_DAYS,
         TO_CHAR(TIME_TO_OFFER_REJECT_DAYS)    AS TIME_TO_OFFER_REJECT_DAYS,
         TO_CHAR(CANDIDATE_START_DATE,'YYYYMMDDHH24MISS') AS CANDIDATE_START_DATE,
         TO_CHAR(REFERRED_BY)                  AS REFERRED_BY,
         TO_CHAR(CREATED_DATE,'YYYYMMDDHH24MISS')       AS CREATED_DATE,
         TO_CHAR(DATE_TIME_COMPLETED,'YYYYMMDDHH24MISS')AS DATE_TIME_COMPLETED,
         TO_CHAR(UPDATED_BY)                   AS UPDATED_BY,
         TO_CHAR(UPDATED_ON,'YYYYMMDDHH24MISS')AS UPDATED_ON,
         TO_CHAR(RECRUITER)                    AS RECRUITER,
         TO_CHAR(CANDIDATE_TAGS)               AS CANDIDATE_TAGS,
         TO_CHAR(CANDIDATE_POOL)               AS CANDIDATE_POOL,
         TO_CHAR(ETL_BATCHID)                  AS ETL_BATCHID
  FROM (
    SELECT
      ORA_HASH(
        NVL(TO_CHAR(JOB_APPLICATION),'#') || '|' ||
        NVL(TO_CHAR(CANDIDATE_ID),'#') || '|' ||
        NVL(TO_CHAR(POSITION),'#') || '|' ||
        NVL(TO_CHAR(EMPLOYEE_ID),'#') || '|' ||
        NVL(TO_CHAR(SOEID),'#') || '|' ||
        NVL(TO_CHAR(JOB_REQUISITION),'#') || '|' ||
        NVL(TO_CHAR(ORIGINAL_JOB_REQUISITION),'#') || '|' ||
        NVL(TO_CHAR(ADDED_DATE,'YYYYMMDDHH24MISS'),'#') || '|' ||
        NVL(TO_CHAR(SOURCE_CATEGORY),'#') || '|' ||
        NVL(TO_CHAR(SOURCE),'#') || '|' ||
        NVL(TO_CHAR(RECRUITING_AGENCY),'#') || '|' ||
        NVL(TO_CHAR(CANDIDATE_STATUS),'#') || '|' ||
        NVL(TO_CHAR(LAST_RECRUITING_STAGE),'#') || '|' ||
        NVL(TO_CHAR(JOB_APPLICATION_STEP),'#') || '|' ||
        NVL(TO_CHAR(LAST_RECRUITING_STAGE_NUMBER),'#') || '|' ||
        NVL(TO_CHAR(FINAL_DISPOSITION_REASON),'#') || '|' ||
        NVL(TO_CHAR(OFFER_STATUS),'#') || '|' ||
        NVL(TO_CHAR(HIRED),'#') || '|' ||
        NVL(TO_CHAR(TIME_TO_OFFER_ACCEPT_DAYS),'#') || '|' ||
        NVL(TO_CHAR(TIME_TO_OFFER_REJECT_DAYS),'#') || '|' ||
        NVL(TO_CHAR(CANDIDATE_START_DATE,'YYYYMMDDHH24MISS'),'#') || '|' ||
        NVL(TO_CHAR(REFERRED_BY),'#') || '|' ||
        NVL(TO_CHAR(CREATED_DATE,'YYYYMMDDHH24MISS'),'#') || '|' ||
        NVL(TO_CHAR(DATE_TIME_COMPLETED,'YYYYMMDDHH24MISS'),'#') || '|' ||
        NVL(TO_CHAR(UPDATED_BY),'#') || '|' ||
        NVL(TO_CHAR(UPDATED_ON,'YYYYMMDDHH24MISS'),'#') || '|' ||
        NVL(TO_CHAR(RECRUITER),'#') || '|' ||
        NVL(TO_CHAR(CANDIDATE_TAGS),'#') || '|' ||
        NVL(TO_CHAR(CANDIDATE_POOL),'#') || '|' ||
        NVL(TO_CHAR(ETL_BATCHID),'#')
      ) AS sig_hash,
      JOB_APPLICATION, CANDIDATE_ID, POSITION, EMPLOYEE_ID, SOEID,
      JOB_REQUISITION, ORIGINAL_JOB_REQUISITION, ADDED_DATE, SOURCE_CATEGORY,
      SOURCE, RECRUITING_AGENCY, CANDIDATE_STATUS, LAST_RECRUITING_STAGE,
      JOB_APPLICATION_STEP, LAST_RECRUITING_STAGE_NUMBER, FINAL_DISPOSITION_REASON,
      OFFER_STATUS, HIRED, TIME_TO_OFFER_ACCEPT_DAYS, TIME_TO_OFFER_REJECT_DAYS,
      CANDIDATE_START_DATE, REFERRED_BY, CREATED_DATE, DATE_TIME_COMPLETED,
      UPDATED_BY, UPDATED_ON, RECRUITER, CANDIDATE_TAGS, CANDIDATE_POOL, ETL_BATCHID
    FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP
  )
),

-- -----------------------
-- diffs: one row per differing column per aligned rn
-- -----------------------
diffs AS (
  SELECT rn, 'JOB_APPLICATION' AS column_name, NVL(TO_CHAR(m.JOB_APPLICATION),'<NULL>') AS main_val, NVL(TO_CHAR(t.JOB_APPLICATION),'<NULL>') AS temp_val
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.JOB_APPLICATION),'<NULL>') <> NVL(TO_CHAR(t.JOB_APPLICATION),'<NULL>')

  UNION ALL

  SELECT rn, 'CANDIDATE_ID', NVL(TO_CHAR(m.CANDIDATE_ID),'<NULL>'), NVL(TO_CHAR(t.CANDIDATE_ID),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.CANDIDATE_ID),'<NULL>') <> NVL(TO_CHAR(t.CANDIDATE_ID),'<NULL>')

  UNION ALL

  SELECT rn, 'POSITION', NVL(TO_CHAR(m.POSITION),'<NULL>'), NVL(TO_CHAR(t.POSITION),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.POSITION),'<NULL>') <> NVL(TO_CHAR(t.POSITION),'<NULL>')

  UNION ALL

  SELECT rn, 'EMPLOYEE_ID', NVL(TO_CHAR(m.EMPLOYEE_ID),'<NULL>'), NVL(TO_CHAR(t.EMPLOYEE_ID),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.EMPLOYEE_ID),'<NULL>') <> NVL(TO_CHAR(t.EMPLOYEE_ID),'<NULL>')

  UNION ALL

  SELECT rn, 'SOEID', NVL(TO_CHAR(m.SOEID),'<NULL>'), NVL(TO_CHAR(t.SOEID),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.SOEID),'<NULL>') <> NVL(TO_CHAR(t.SOEID),'<NULL>')

  UNION ALL

  SELECT rn, 'JOB_REQUISITION', NVL(TO_CHAR(m.JOB_REQUISITION),'<NULL>'), NVL(TO_CHAR(t.JOB_REQUISITION),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.JOB_REQUISITION),'<NULL>') <> NVL(TO_CHAR(t.JOB_REQUISITION),'<NULL>')

  UNION ALL

  SELECT rn, 'ORIGINAL_JOB_REQUISITION', NVL(TO_CHAR(m.ORIGINAL_JOB_REQUISITION),'<NULL>'), NVL(TO_CHAR(t.ORIGINAL_JOB_REQUISITION),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.ORIGINAL_JOB_REQUISITION),'<NULL>') <> NVL(TO_CHAR(t.ORIGINAL_JOB_REQUISITION),'<NULL>')

  UNION ALL

  SELECT rn, 'ADDED_DATE', NVL(TO_CHAR(m.ADDED_DATE,'YYYY-MM-DD HH24:MI:SS'),'<NULL>'), NVL(TO_CHAR(t.ADDED_DATE,'YYYY-MM-DD HH24:MI:SS'),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.ADDED_DATE,'YYYYMMDDHH24MISS'),'<NULL>') <> NVL(TO_CHAR(t.ADDED_DATE,'YYYYMMDDHH24MISS'),'<NULL>')

  UNION ALL

  SELECT rn, 'SOURCE_CATEGORY', NVL(TO_CHAR(m.SOURCE_CATEGORY),'<NULL>'), NVL(TO_CHAR(t.SOURCE_CATEGORY),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.SOURCE_CATEGORY),'<NULL>') <> NVL(TO_CHAR(t.SOURCE_CATEGORY),'<NULL>')

  UNION ALL

  SELECT rn, 'SOURCE', NVL(TO_CHAR(m.SOURCE),'<NULL>'), NVL(TO_CHAR(t.SOURCE),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.SOURCE),'<NULL>') <> NVL(TO_CHAR(t.SOURCE),'<NULL>')

  UNION ALL

  SELECT rn, 'RECRUITING_AGENCY', NVL(TO_CHAR(m.RECRUITING_AGENCY),'<NULL>'), NVL(TO_CHAR(t.RECRUITING_AGENCY),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.RECRUITING_AGENCY),'<NULL>') <> NVL(TO_CHAR(t.RECRUITING_AGENCY),'<NULL>')

  UNION ALL

  SELECT rn, 'CANDIDATE_STATUS', NVL(TO_CHAR(m.CANDIDATE_STATUS),'<NULL>'), NVL(TO_CHAR(t.CANDIDATE_STATUS),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.CANDIDATE_STATUS),'<NULL>') <> NVL(TO_CHAR(t.CANDIDATE_STATUS),'<NULL>')

  UNION ALL

  SELECT rn, 'LAST_RECRUITING_STAGE', NVL(TO_CHAR(m.LAST_RECRUITING_STAGE),'<NULL>'), NVL(TO_CHAR(t.LAST_RECRUITING_STAGE),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.LAST_RECRUITING_STAGE),'<NULL>') <> NVL(TO_CHAR(t.LAST_RECRUITING_STAGE),'<NULL>')

  UNION ALL

  SELECT rn, 'JOB_APPLICATION_STEP', NVL(TO_CHAR(m.JOB_APPLICATION_STEP),'<NULL>'), NVL(TO_CHAR(t.JOB_APPLICATION_STEP),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.JOB_APPLICATION_STEP),'<NULL>') <> NVL(TO_CHAR(t.JOB_APPLICATION_STEP),'<NULL>')

  UNION ALL

  SELECT rn, 'LAST_RECRUITING_STAGE_NUMBER', NVL(TO_CHAR(m.LAST_RECRUITING_STAGE_NUMBER),'<NULL>'), NVL(TO_CHAR(t.LAST_RECRUITING_STAGE_NUMBER),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.LAST_RECRUITING_STAGE_NUMBER),'<NULL>') <> NVL(TO_CHAR(t.LAST_RECRUITING_STAGE_NUMBER),'<NULL>')

  UNION ALL

  SELECT rn, 'FINAL_DISPOSITION_REASON', NVL(TO_CHAR(m.FINAL_DISPOSITION_REASON),'<NULL>'), NVL(TO_CHAR(t.FINAL_DISPOSITION_REASON),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.FINAL_DISPOSITION_REASON),'<NULL>') <> NVL(TO_CHAR(t.FINAL_DISPOSITION_REASON),'<NULL>')

  UNION ALL

  SELECT rn, 'OFFER_STATUS', NVL(TO_CHAR(m.OFFER_STATUS),'<NULL>'), NVL(TO_CHAR(t.OFFER_STATUS),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.OFFER_STATUS),'<NULL>') <> NVL(TO_CHAR(t.OFFER_STATUS),'<NULL>')

  UNION ALL

  SELECT rn, 'HIRED', NVL(TO_CHAR(m.HIRED),'<NULL>'), NVL(TO_CHAR(t.HIRED),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.HIRED),'<NULL>') <> NVL(TO_CHAR(t.HIRED),'<NULL>')

  UNION ALL

  SELECT rn, 'TIME_TO_OFFER_ACCEPT_DAYS', NVL(TO_CHAR(m.TIME_TO_OFFER_ACCEPT_DAYS),'<NULL>'), NVL(TO_CHAR(t.TIME_TO_OFFER_ACCEPT_DAYS),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.TIME_TO_OFFER_ACCEPT_DAYS),'<NULL>') <> NVL(TO_CHAR(t.TIME_TO_OFFER_ACCEPT_DAYS),'<NULL>')

  UNION ALL

  SELECT rn, 'TIME_TO_OFFER_REJECT_DAYS', NVL(TO_CHAR(m.TIME_TO_OFFER_REJECT_DAYS),'<NULL>'), NVL(TO_CHAR(t.TIME_TO_OFFER_REJECT_DAYS),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.TIME_TO_OFFER_REJECT_DAYS),'<NULL>') <> NVL(TO_CHAR(t.TIME_TO_OFFER_REJECT_DAYS),'<NULL>')

  UNION ALL

  SELECT rn, 'CANDIDATE_START_DATE', NVL(TO_CHAR(m.CANDIDATE_START_DATE,'YYYY-MM-DD HH24:MI:SS'),'<NULL>'), NVL(TO_CHAR(t.CANDIDATE_START_DATE,'YYYY-MM-DD HH24:MI:SS'),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.CANDIDATE_START_DATE,'YYYYMMDDHH24MISS'),'<NULL>') <> NVL(TO_CHAR(t.CANDIDATE_START_DATE,'YYYYMMDDHH24MISS'),'<NULL>')

  UNION ALL

  SELECT rn, 'REFERRED_BY', NVL(TO_CHAR(m.REFERRED_BY),'<NULL>'), NVL(TO_CHAR(t.REFERRED_BY),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.REFERRED_BY),'<NULL>') <> NVL(TO_CHAR(t.REFERRED_BY),'<NULL>')

  UNION ALL

  SELECT rn, 'CREATED_DATE', NVL(TO_CHAR(m.CREATED_DATE,'YYYY-MM-DD HH24:MI:SS'),'<NULL>'), NVL(TO_CHAR(t.CREATED_DATE,'YYYY-MM-DD HH24:MI:SS'),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.CREATED_DATE,'YYYYMMDDHH24MISS'),'<NULL>') <> NVL(TO_CHAR(t.CREATED_DATE,'YYYYMMDDHH24MISS'),'<NULL>')

  UNION ALL

  SELECT rn, 'DATE_TIME_COMPLETED', NVL(TO_CHAR(m.DATE_TIME_COMPLETED,'YYYY-MM-DD HH24:MI:SS'),'<NULL>'), NVL(TO_CHAR(t.DATE_TIME_COMPLETED,'YYYY-MM-DD HH24:MI:SS'),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.DATE_TIME_COMPLETED,'YYYYMMDDHH24MISS'),'<NULL>') <> NVL(TO_CHAR(t.DATE_TIME_COMPLETED,'YYYYMMDDHH24MISS'),'<NULL>')

  UNION ALL

  SELECT rn, 'UPDATED_BY', NVL(TO_CHAR(m.UPDATED_BY),'<NULL>'), NVL(TO_CHAR(t.UPDATED_BY),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.UPDATED_BY),'<NULL>') <> NVL(TO_CHAR(t.UPDATED_BY),'<NULL>')

  UNION ALL

  SELECT rn, 'UPDATED_ON', NVL(TO_CHAR(m.UPDATED_ON,'YYYY-MM-DD HH24:MI:SS'),'<NULL>'), NVL(TO_CHAR(t.UPDATED_ON,'YYYY-MM-DD HH24:MI:SS'),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.UPDATED_ON,'YYYYMMDDHH24MISS'),'<NULL>') <> NVL(TO_CHAR(t.UPDATED_ON,'YYYYMMDDHH24MISS'),'<NULL>')

  UNION ALL

  SELECT rn, 'RECRUITER', NVL(TO_CHAR(m.RECRUITER),'<NULL>'), NVL(TO_CHAR(t.RECRUITER),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.RECRUITER),'<NULL>') <> NVL(TO_CHAR(t.RECRUITER),'<NULL>')

  UNION ALL

  SELECT rn, 'CANDIDATE_TAGS', NVL(TO_CHAR(m.CANDIDATE_TAGS),'<NULL>'), NVL(TO_CHAR(t.CANDIDATE_TAGS),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.CANDIDATE_TAGS),'<NULL>') <> NVL(TO_CHAR(t.CANDIDATE_TAGS),'<NULL>')

  UNION ALL

  SELECT rn, 'CANDIDATE_POOL', NVL(TO_CHAR(m.CANDIDATE_POOL),'<NULL>'), NVL(TO_CHAR(t.CANDIDATE_POOL),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.CANDIDATE_POOL),'<NULL>') <> NVL(TO_CHAR(t.CANDIDATE_POOL),'<NULL>')

  UNION ALL

  SELECT rn, 'ETL_BATCHID', NVL(TO_CHAR(m.ETL_BATCHID),'<NULL>'), NVL(TO_CHAR(t.ETL_BATCHID),'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(TO_CHAR(m.ETL_BATCHID),'<NULL>') <> NVL(TO_CHAR(t.ETL_BATCHID),'<NULL>')
)

-- -----------------------
-- Final summary: one row per aligned rn (only rows that have differences)
-- -----------------------
SELECT
  rn,
  LISTAGG(column_name, ', ') WITHIN GROUP (ORDER BY column_name) AS differing_columns,
  COUNT(*) AS diff_count,
  MIN(main_val) KEEP (DENSE_RANK FIRST ORDER BY column_name) AS sample_main_val,
  MIN(temp_val) KEEP (DENSE_RANK FIRST ORDER BY column_name) AS sample_temp_val
FROM diffs
GROUP BY rn
ORDER BY diff_count DESC, rn
FETCH FIRST 200 ROWS ONLY;


























WITH
-- -----------------------
-- aligned MAIN rows (m)
-- -----------------------
m AS (
  SELECT ROW_NUMBER() OVER (ORDER BY sig, ROWID) AS rn,
         JOB_APPLICATION,
         TO_CHAR(CANDIDATE_ID)                 AS CANDIDATE_ID,
         TO_CHAR(POSITION)                     AS POSITION,
         TO_CHAR(EMPLOYEE_ID)                  AS EMPLOYEE_ID,
         TO_CHAR(SOEID)                        AS SOEID,
         TO_CHAR(JOB_REQUISITION)              AS JOB_REQUISITION,
         TO_CHAR(ORIGINAL_JOB_REQUISITION)     AS ORIGINAL_JOB_REQUISITION,
         TO_CHAR(ADDED_DATE,'YYYYMMDDHH24MISS')AS ADDED_DATE,
         TO_CHAR(SOURCE_CATEGORY)              AS SOURCE_CATEGORY,
         TO_CHAR(SOURCE)                       AS SOURCE,
         TO_CHAR(RECRUITING_AGENCY)            AS RECRUITING_AGENCY,
         TO_CHAR(CANDIDATE_STATUS)             AS CANDIDATE_STATUS,
         TO_CHAR(LAST_RECRUITING_STAGE)        AS LAST_RECRUITING_STAGE,
         TO_CHAR(JOB_APPLICATION_STEP)         AS JOB_APPLICATION_STEP,
         TO_CHAR(LAST_RECRUITING_STAGE_NUMBER) AS LAST_RECRUITING_STAGE_NUMBER,
         TO_CHAR(FINAL_DISPOSITION_REASON)     AS FINAL_DISPOSITION_REASON,
         TO_CHAR(OFFER_STATUS)                 AS OFFER_STATUS,
         TO_CHAR(HIRED)                        AS HIRED,
         TO_CHAR(TIME_TO_OFFER_ACCEPT_DAYS)    AS TIME_TO_OFFER_ACCEPT_DAYS,
         TO_CHAR(TIME_TO_OFFER_REJECT_DAYS)    AS TIME_TO_OFFER_REJECT_DAYS,
         TO_CHAR(CANDIDATE_START_DATE,'YYYYMMDDHH24MISS') AS CANDIDATE_START_DATE,
         TO_CHAR(REFERRED_BY)                  AS REFERRED_BY,
         TO_CHAR(CREATED_DATE,'YYYYMMDDHH24MISS')       AS CREATED_DATE,
         TO_CHAR(DATE_TIME_COMPLETED,'YYYYMMDDHH24MISS')AS DATE_TIME_COMPLETED,
         TO_CHAR(UPDATED_BY)                   AS UPDATED_BY,
         TO_CHAR(UPDATED_ON,'YYYYMMDDHH24MISS')AS UPDATED_ON,
         TO_CHAR(RECRUITER)                    AS RECRUITER,
         TO_CHAR(CANDIDATE_TAGS)               AS CANDIDATE_TAGS,
         TO_CHAR(CANDIDATE_POOL)               AS CANDIDATE_POOL,
         TO_CHAR(ETL_BATCHID)                  AS ETL_BATCHID
  FROM (
    SELECT
      NVL(TO_CHAR(JOB_APPLICATION),'#') || '|' ||
      NVL(TO_CHAR(CANDIDATE_ID),'#') || '|' ||
      NVL(TO_CHAR(POSITION),'#') || '|' ||
      NVL(TO_CHAR(EMPLOYEE_ID),'#') || '|' ||
      NVL(TO_CHAR(SOEID),'#') || '|' ||
      NVL(TO_CHAR(JOB_REQUISITION),'#') || '|' ||
      NVL(TO_CHAR(ORIGINAL_JOB_REQUISITION),'#') || '|' ||
      NVL(TO_CHAR(ADDED_DATE,'YYYYMMDDHH24MISS'),'#') || '|' ||
      NVL(TO_CHAR(SOURCE_CATEGORY),'#') || '|' ||
      NVL(TO_CHAR(SOURCE),'#') || '|' ||
      NVL(TO_CHAR(RECRUITING_AGENCY),'#') || '|' ||
      NVL(TO_CHAR(CANDIDATE_STATUS),'#') || '|' ||
      NVL(TO_CHAR(LAST_RECRUITING_STAGE),'#') || '|' ||
      NVL(TO_CHAR(JOB_APPLICATION_STEP),'#') || '|' ||
      NVL(TO_CHAR(LAST_RECRUITING_STAGE_NUMBER),'#') || '|' ||
      NVL(TO_CHAR(FINAL_DISPOSITION_REASON),'#') || '|' ||
      NVL(TO_CHAR(OFFER_STATUS),'#') || '|' ||
      NVL(TO_CHAR(HIRED),'#') || '|' ||
      NVL(TO_CHAR(TIME_TO_OFFER_ACCEPT_DAYS),'#') || '|' ||
      NVL(TO_CHAR(TIME_TO_OFFER_REJECT_DAYS),'#') || '|' ||
      NVL(TO_CHAR(CANDIDATE_START_DATE,'YYYYMMDDHH24MISS'),'#') || '|' ||
      NVL(TO_CHAR(REFERRED_BY),'#') || '|' ||
      NVL(TO_CHAR(CREATED_DATE,'YYYYMMDDHH24MISS'),'#') || '|' ||
      NVL(TO_CHAR(DATE_TIME_COMPLETED,'YYYYMMDDHH24MISS'),'#') || '|' ||
      NVL(TO_CHAR(UPDATED_BY),'#') || '|' ||
      NVL(TO_CHAR(UPDATED_ON,'YYYYMMDDHH24MISS'),'#') || '|' ||
      NVL(TO_CHAR(RECRUITER),'#') || '|' ||
      NVL(TO_CHAR(CANDIDATE_TAGS),'#') || '|' ||
      NVL(TO_CHAR(CANDIDATE_POOL),'#') || '|' ||
      NVL(TO_CHAR(ETL_BATCHID),'#')  AS sig,
      JOB_APPLICATION, CANDIDATE_ID, POSITION, EMPLOYEE_ID, SOEID,
      JOB_REQUISITION, ORIGINAL_JOB_REQUISITION, ADDED_DATE, SOURCE_CATEGORY,
      SOURCE, RECRUITING_AGENCY, CANDIDATE_STATUS, LAST_RECRUITING_STAGE,
      JOB_APPLICATION_STEP, LAST_RECRUITING_STAGE_NUMBER, FINAL_DISPOSITION_REASON,
      OFFER_STATUS, HIRED, TIME_TO_OFFER_ACCEPT_DAYS, TIME_TO_OFFER_REJECT_DAYS,
      CANDIDATE_START_DATE, REFERRED_BY, CREATED_DATE, DATE_TIME_COMPLETED,
      UPDATED_BY, UPDATED_ON, RECRUITER, CANDIDATE_TAGS, CANDIDATE_POOL, ETL_BATCHID
    FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION
  )
),

-- -----------------------
-- aligned TEMP rows (t)
-- -----------------------
t AS (
  SELECT ROW_NUMBER() OVER (ORDER BY sig, ROWID) AS rn,
         JOB_APPLICATION,
         TO_CHAR(CANDIDATE_ID)                 AS CANDIDATE_ID,
         TO_CHAR(POSITION)                     AS POSITION,
         TO_CHAR(EMPLOYEE_ID)                  AS EMPLOYEE_ID,
         TO_CHAR(SOEID)                        AS SOEID,
         TO_CHAR(JOB_REQUISITION)              AS JOB_REQUISITION,
         TO_CHAR(ORIGINAL_JOB_REQUISITION)     AS ORIGINAL_JOB_REQUISITION,
         TO_CHAR(ADDED_DATE,'YYYYMMDDHH24MISS')AS ADDED_DATE,
         TO_CHAR(SOURCE_CATEGORY)              AS SOURCE_CATEGORY,
         TO_CHAR(SOURCE)                       AS SOURCE,
         TO_CHAR(RECRUITING_AGENCY)            AS RECRUITING_AGENCY,
         TO_CHAR(CANDIDATE_STATUS)             AS CANDIDATE_STATUS,
         TO_CHAR(LAST_RECRUITING_STAGE)        AS LAST_RECRUITING_STAGE,
         TO_CHAR(JOB_APPLICATION_STEP)         AS JOB_APPLICATION_STEP,
         TO_CHAR(LAST_RECRUITING_STAGE_NUMBER) AS LAST_RECRUITING_STAGE_NUMBER,
         TO_CHAR(FINAL_DISPOSITION_REASON)     AS FINAL_DISPOSITION_REASON,
         TO_CHAR(OFFER_STATUS)                 AS OFFER_STATUS,
         TO_CHAR(HIRED)                        AS HIRED,
         TO_CHAR(TIME_TO_OFFER_ACCEPT_DAYS)    AS TIME_TO_OFFER_ACCEPT_DAYS,
         TO_CHAR(TIME_TO_OFFER_REJECT_DAYS)    AS TIME_TO_OFFER_REJECT_DAYS,
         TO_CHAR(CANDIDATE_START_DATE,'YYYYMMDDHH24MISS') AS CANDIDATE_START_DATE,
         TO_CHAR(REFERRED_BY)                  AS REFERRED_BY,
         TO_CHAR(CREATED_DATE,'YYYYMMDDHH24MISS')       AS CREATED_DATE,
         TO_CHAR(DATE_TIME_COMPLETED,'YYYYMMDDHH24MISS')AS DATE_TIME_COMPLETED,
         TO_CHAR(UPDATED_BY)                   AS UPDATED_BY,
         TO_CHAR(UPDATED_ON,'YYYYMMDDHH24MISS')AS UPDATED_ON,
         TO_CHAR(RECRUITER)                    AS RECRUITER,
         TO_CHAR(CANDIDATE_TAGS)               AS CANDIDATE_TAGS,
         TO_CHAR(CANDIDATE_POOL)               AS CANDIDATE_POOL,
         TO_CHAR(ETL_BATCHID)                  AS ETL_BATCHID
  FROM (
    SELECT
      NVL(TO_CHAR(JOB_APPLICATION),'#') || '|' ||
      NVL(TO_CHAR(CANDIDATE_ID),'#') || '|' ||
      NVL(TO_CHAR(POSITION),'#') || '|' ||
      NVL(TO_CHAR(EMPLOYEE_ID),'#') || '|' ||
      NVL(TO_CHAR(SOEID),'#') || '|' ||
      NVL(TO_CHAR(JOB_REQUISITION),'#') || '|' ||
      NVL(TO_CHAR(ORIGINAL_JOB_REQUISITION),'#') || '|' ||
      NVL(TO_CHAR(ADDED_DATE,'YYYYMMDDHH24MISS'),'#') || '|' ||
      NVL(TO_CHAR(SOURCE_CATEGORY),'#') || '|' ||
      NVL(TO_CHAR(SOURCE),'#') || '|' ||
      NVL(TO_CHAR(RECRUITING_AGENCY),'#') || '|' ||
      NVL(TO_CHAR(CANDIDATE_STATUS),'#') || '|' ||
      NVL(TO_CHAR(LAST_RECRUITING_STAGE),'#') || '|' ||
      NVL(TO_CHAR(JOB_APPLICATION_STEP),'#') || '|' ||
      NVL(TO_CHAR(LAST_RECRUITING_STAGE_NUMBER),'#') || '|' ||
      NVL(TO_CHAR(FINAL_DISPOSITION_REASON),'#') || '|' ||
      NVL(TO_CHAR(OFFER_STATUS),'#') || '|' ||
      NVL(TO_CHAR(HIRED),'#') || '|' ||
      NVL(TO_CHAR(TIME_TO_OFFER_ACCEPT_DAYS),'#') || '|' ||
      NVL(TO_CHAR(TIME_TO_OFFER_REJECT_DAYS),'#') || '|' ||
      NVL(TO_CHAR(CANDIDATE_START_DATE,'YYYYMMDDHH24MISS'),'#') || '|' ||
      NVL(TO_CHAR(REFERRED_BY),'#') || '|' ||
      NVL(TO_CHAR(CREATED_DATE,'YYYYMMDDHH24MISS'),'#') || '|' ||
      NVL(TO_CHAR(DATE_TIME_COMPLETED,'YYYYMMDDHH24MISS'),'#') || '|' ||
      NVL(TO_CHAR(UPDATED_BY),'#') || '|' ||
      NVL(TO_CHAR(UPDATED_ON,'YYYYMMDDHH24MISS'),'#') || '|' ||
      NVL(TO_CHAR(RECRUITER),'#') || '|' ||
      NVL(TO_CHAR(CANDIDATE_TAGS),'#') || '|' ||
      NVL(TO_CHAR(CANDIDATE_POOL),'#') || '|' ||
      NVL(TO_CHAR(ETL_BATCHID),'#')  AS sig,
      JOB_APPLICATION, CANDIDATE_ID, POSITION, EMPLOYEE_ID, SOEID,
      JOB_REQUISITION, ORIGINAL_JOB_REQUISITION, ADDED_DATE, SOURCE_CATEGORY,
      SOURCE, RECRUITING_AGENCY, CANDIDATE_STATUS, LAST_RECRUITING_STAGE,
      JOB_APPLICATION_STEP, LAST_RECRUITING_STAGE_NUMBER, FINAL_DISPOSITION_REASON,
      OFFER_STATUS, HIRED, TIME_TO_OFFER_ACCEPT_DAYS, TIME_TO_OFFER_REJECT_DAYS,
      CANDIDATE_START_DATE, REFERRED_BY, CREATED_DATE, DATE_TIME_COMPLETED,
      UPDATED_BY, UPDATED_ON, RECRUITER, CANDIDATE_TAGS, CANDIDATE_POOL, ETL_BATCHID
    FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP
  )
),

-- -----------------------
-- diffs: one row per differing column per aligned rn
-- -----------------------
diffs AS (
  SELECT rn, 'JOB_APPLICATION' AS column_name, NVL(m.JOB_APPLICATION,'<NULL>') AS main_val, NVL(t.JOB_APPLICATION,'<NULL>') AS temp_val
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(m.JOB_APPLICATION,'<NULL>') <> NVL(t.JOB_APPLICATION,'<NULL>')

  UNION ALL

  SELECT rn, 'CANDIDATE_ID', NVL(m.CANDIDATE_ID,'<NULL>'), NVL(t.CANDIDATE_ID,'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(m.CANDIDATE_ID,'<NULL>') <> NVL(t.CANDIDATE_ID,'<NULL>')

  UNION ALL

  SELECT rn, 'POSITION', NVL(m.POSITION,'<NULL>'), NVL(t.POSITION,'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(m.POSITION,'<NULL>') <> NVL(t.POSITION,'<NULL>')

  UNION ALL

  SELECT rn, 'EMPLOYEE_ID', NVL(m.EMPLOYEE_ID,'<NULL>'), NVL(t.EMPLOYEE_ID,'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(m.EMPLOYEE_ID,'<NULL>') <> NVL(t.EMPLOYEE_ID,'<NULL>')

  UNION ALL

  SELECT rn, 'SOEID', NVL(m.SOEID,'<NULL>'), NVL(t.SOEID,'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(m.SOEID,'<NULL>') <> NVL(t.SOEID,'<NULL>')

  UNION ALL

  SELECT rn, 'JOB_REQUISITION', NVL(m.JOB_REQUISITION,'<NULL>'), NVL(t.JOB_REQUISITION,'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(m.JOB_REQUISITION,'<NULL>') <> NVL(t.JOB_REQUISITION,'<NULL>')

  UNION ALL

  SELECT rn, 'ORIGINAL_JOB_REQUISITION', NVL(m.ORIGINAL_JOB_REQUISITION,'<NULL>'), NVL(t.ORIGINAL_JOB_REQUISITION,'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(m.ORIGINAL_JOB_REQUISITION,'<NULL>') <> NVL(t.ORIGINAL_JOB_REQUISITION,'<NULL>')

  UNION ALL

  SELECT rn, 'ADDED_DATE', NVL(m.ADDED_DATE,'<NULL>'), NVL(t.ADDED_DATE,'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(m.ADDED_DATE,'<NULL>') <> NVL(t.ADDED_DATE,'<NULL>')

  UNION ALL

  SELECT rn, 'SOURCE_CATEGORY', NVL(m.SOURCE_CATEGORY,'<NULL>'), NVL(t.SOURCE_CATEGORY,'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(m.SOURCE_CATEGORY,'<NULL>') <> NVL(t.SOURCE_CATEGORY,'<NULL>')

  UNION ALL

  SELECT rn, 'SOURCE', NVL(m.SOURCE,'<NULL>'), NVL(t.SOURCE,'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(m.SOURCE,'<NULL>') <> NVL(t.SOURCE,'<NULL>')

  UNION ALL

  SELECT rn, 'RECRUITING_AGENCY', NVL(m.RECRUITING_AGENCY,'<NULL>'), NVL(t.RECRUITING_AGENCY,'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(m.RECRUITING_AGENCY,'<NULL>') <> NVL(t.RECRUITING_AGENCY,'<NULL>')

  UNION ALL

  SELECT rn, 'CANDIDATE_STATUS', NVL(m.CANDIDATE_STATUS,'<NULL>'), NVL(t.CANDIDATE_STATUS,'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(m.CANDIDATE_STATUS,'<NULL>') <> NVL(t.CANDIDATE_STATUS,'<NULL>')

  UNION ALL

  SELECT rn, 'LAST_RECRUITING_STAGE', NVL(m.LAST_RECRUITING_STAGE,'<NULL>'), NVL(t.LAST_RECRUITING_STAGE,'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(m.LAST_RECRUITING_STAGE,'<NULL>') <> NVL(t.LAST_RECRUITING_STAGE,'<NULL>')

  UNION ALL

  SELECT rn, 'JOB_APPLICATION_STEP', NVL(m.JOB_APPLICATION_STEP,'<NULL>'), NVL(t.JOB_APPLICATION_STEP,'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(m.JOB_APPLICATION_STEP,'<NULL>') <> NVL(t.JOB_APPLICATION_STEP,'<NULL>')

  UNION ALL

  SELECT rn, 'LAST_RECRUITING_STAGE_NUMBER', NVL(m.LAST_RECRUITING_STAGE_NUMBER,'<NULL>'), NVL(t.LAST_RECRUITING_STAGE_NUMBER,'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(m.LAST_RECRUITING_STAGE_NUMBER,'<NULL>') <> NVL(t.LAST_RECRUITING_STAGE_NUMBER,'<NULL>')

  UNION ALL

  SELECT rn, 'FINAL_DISPOSITION_REASON', NVL(m.FINAL_DISPOSITION_REASON,'<NULL>'), NVL(t.FINAL_DISPOSITION_REASON,'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(m.FINAL_DISPOSITION_REASON,'<NULL>') <> NVL(t.FINAL_DISPOSITION_REASON,'<NULL>')

  UNION ALL

  SELECT rn, 'OFFER_STATUS', NVL(m.OFFER_STATUS,'<NULL>'), NVL(t.OFFER_STATUS,'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(m.OFFER_STATUS,'<NULL>') <> NVL(t.OFFER_STATUS,'<NULL>')

  UNION ALL

  SELECT rn, 'HIRED', NVL(m.HIRED,'<NULL>'), NVL(t.HIRED,'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(m.HIRED,'<NULL>') <> NVL(t.HIRED,'<NULL>')

  UNION ALL

  SELECT rn, 'TIME_TO_OFFER_ACCEPT_DAYS', NVL(m.TIME_TO_OFFER_ACCEPT_DAYS,'<NULL>'), NVL(t.TIME_TO_OFFER_ACCEPT_DAYS,'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(m.TIME_TO_OFFER_ACCEPT_DAYS,'<NULL>') <> NVL(t.TIME_TO_OFFER_ACCEPT_DAYS,'<NULL>')

  UNION ALL

  SELECT rn, 'TIME_TO_OFFER_REJECT_DAYS', NVL(m.TIME_TO_OFFER_REJECT_DAYS,'<NULL>'), NVL(t.TIME_TO_OFFER_REJECT_DAYS,'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(m.TIME_TO_OFFER_REJECT_DAYS,'<NULL>') <> NVL(t.TIME_TO_OFFER_REJECT_DAYS,'<NULL>')

  UNION ALL

  SELECT rn, 'CANDIDATE_START_DATE', NVL(m.CANDIDATE_START_DATE,'<NULL>'), NVL(t.CANDIDATE_START_DATE,'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(m.CANDIDATE_START_DATE,'<NULL>') <> NVL(t.CANDIDATE_START_DATE,'<NULL>')

  UNION ALL

  SELECT rn, 'REFERRED_BY', NVL(m.REFERRED_BY,'<NULL>'), NVL(t.REFERRED_BY,'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(m.REFERRED_BY,'<NULL>') <> NVL(t.REFERRED_BY,'<NULL>')

  UNION ALL

  SELECT rn, 'CREATED_DATE', NVL(m.CREATED_DATE,'<NULL>'), NVL(t.CREATED_DATE,'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(m.CREATED_DATE,'<NULL>') <> NVL(t.CREATED_DATE,'<NULL>')

  UNION ALL

  SELECT rn, 'DATE_TIME_COMPLETED', NVL(m.DATE_TIME_COMPLETED,'<NULL>'), NVL(t.DATE_TIME_COMPLETED,'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(m.DATE_TIME_COMPLETED,'<NULL>') <> NVL(t.DATE_TIME_COMPLETED,'<NULL>')

  UNION ALL

  SELECT rn, 'UPDATED_BY', NVL(m.UPDATED_BY,'<NULL>'), NVL(t.UPDATED_BY,'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(m.UPDATED_BY,'<NULL>') <> NVL(t.UPDATED_BY,'<NULL>')

  UNION ALL

  SELECT rn, 'UPDATED_ON', NVL(m.UPDATED_ON,'<NULL>'), NVL(t.UPDATED_ON,'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(m.UPDATED_ON,'<NULL>') <> NVL(t.UPDATED_ON,'<NULL>')

  UNION ALL

  SELECT rn, 'RECRUITER', NVL(m.RECRUITER,'<NULL>'), NVL(t.RECRUITER,'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(m.RECRUITER,'<NULL>') <> NVL(t.RECRUITER,'<NULL>')

  UNION ALL

  SELECT rn, 'CANDIDATE_TAGS', NVL(m.CANDIDATE_TAGS,'<NULL>'), NVL(t.CANDIDATE_TAGS,'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(m.CANDIDATE_TAGS,'<NULL>') <> NVL(t.CANDIDATE_TAGS,'<NULL>')

  UNION ALL

  SELECT rn, 'CANDIDATE_POOL', NVL(m.CANDIDATE_POOL,'<NULL>'), NVL(t.CANDIDATE_POOL,'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(m.CANDIDATE_POOL,'<NULL>') <> NVL(t.CANDIDATE_POOL,'<NULL>')

  UNION ALL

  SELECT rn, 'ETL_BATCHID', NVL(m.ETL_BATCHID,'<NULL>'), NVL(t.ETL_BATCHID,'<NULL>')
  FROM m FULL JOIN t USING(rn)
  WHERE NVL(m.ETL_BATCHID,'<NULL>') <> NVL(t.ETL_BATCHID,'<NULL>')
)

-- -----------------------
-- Final summary: one row per aligned rn
-- -----------------------
SELECT
  rn,
  LISTAGG(column_name, ', ') WITHIN GROUP (ORDER BY column_name) AS differing_columns,
  COUNT(*) AS diff_count,
  -- sample values: values from the first differing column (alphabetical)
  MIN(main_val) KEEP (DENSE_RANK FIRST ORDER BY column_name) AS sample_main_val,
  MIN(temp_val) KEEP (DENSE_RANK FIRST ORDER BY column_name) AS sample_temp_val
FROM diffs
GROUP BY rn
ORDER BY diff_count DESC, rn
FETCH FIRST 200 ROWS ONLY;


























Absolutely YES  if you cannot create tables or views, I will give you a single, clean, SELECT-only script that:

 Gives:

1. Counts of identical rows


2. Count of rows in MAIN but not in TEMP


3. Count of rows in TEMP but not in MAIN


4. Count of rows where ANY column value differs


5. Which columns differ & how many rows differ per column


6. Sample mismatching rows and sample differing columns



 Requires:

NO CREATE TABLE

NO CREATE VIEW

NO PL/SQL

Works directly in UAT read-only environment.



---

 FINAL SELECT-ONLY SCRIPT (RUN AS-IS)

Paste & run the entire script.
This uses your 30 columns from the screenshot.


---

 SECTION 1  BASIC COUNTS

-- Count rows in each table
SELECT 'MAIN' AS table_name, COUNT(*) AS cnt
FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION
UNION ALL
SELECT 'TEMP', COUNT(*) 
FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP;


---

 SECTION 2  EXACT MATCHING ROWS (INTERSECT)

How many rows are exactly identical across all columns:

SELECT COUNT(*) AS matching_rows
FROM (
    SELECT 
      JOB_APPLICATION,
      CANDIDATE_ID,
      POSITION,
      EMPLOYEE_ID,
      SOEID,
      JOB_REQUISITION,
      ORIGINAL_JOB_REQUISITION,
      ADDED_DATE,
      SOURCE_CATEGORY,
      SOURCE,
      RECRUITING_AGENCY,
      CANDIDATE_STATUS,
      LAST_RECRUITING_STAGE,
      JOB_APPLICATION_STEP,
      LAST_RECRUITING_STAGE_NUMBER,
      FINAL_DISPOSITION_REASON,
      OFFER_STATUS,
      HIRED,
      TIME_TO_OFFER_ACCEPT_DAYS,
      TIME_TO_OFFER_REJECT_DAYS,
      CANDIDATE_START_DATE,
      REFERRED_BY,
      CREATED_DATE,
      DATE_TIME_COMPLETED,
      UPDATED_BY,
      UPDATED_ON,
      RECRUITER,
      CANDIDATE_TAGS,
      CANDIDATE_POOL,
      ETL_BATCHID
    FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION
    INTERSECT
    SELECT 
      JOB_APPLICATION,
      CANDIDATE_ID,
      POSITION,
      EMPLOYEE_ID,
      SOEID,
      JOB_REQUISITION,
      ORIGINAL_JOB_REQUISITION,
      ADDED_DATE,
      SOURCE_CATEGORY,
      SOURCE,
      RECRUITING_AGENCY,
      CANDIDATE_STATUS,
      LAST_RECRUITING_STAGE,
      JOB_APPLICATION_STEP,
      LAST_RECRUITING_STAGE_NUMBER,
      FINAL_DISPOSITION_REASON,
      OFFER_STATUS,
      HIRED,
      TIME_TO_OFFER_ACCEPT_DAYS,
      TIME_TO_OFFER_REJECT_DAYS,
      CANDIDATE_START_DATE,
      REFERRED_BY,
      CREATED_DATE,
      DATE_TIME_COMPLETED,
      UPDATED_BY,
      UPDATED_ON,
      RECRUITER,
      CANDIDATE_TAGS,
      CANDIDATE_POOL,
      ETL_BATCHID
    FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP
);


---

 SECTION 3  ROWS IN MAIN BUT NOT IN TEMP

SELECT COUNT(*) AS main_not_in_temp
FROM (
    SELECT 
      JOB_APPLICATION,
      CANDIDATE_ID,
      POSITION,
      EMPLOYEE_ID,
      SOEID,
      JOB_REQUISITION,
      ORIGINAL_JOB_REQUISITION,
      ADDED_DATE,
      SOURCE_CATEGORY,
      SOURCE,
      RECRUITING_AGENCY,
      CANDIDATE_STATUS,
      LAST_RECRUITING_STAGE,
      JOB_APPLICATION_STEP,
      LAST_RECRUITING_STAGE_NUMBER,
      FINAL_DISPOSITION_REASON,
      OFFER_STATUS,
      HIRED,
      TIME_TO_OFFER_ACCEPT_DAYS,
      TIME_TO_OFFER_REJECT_DAYS,
      CANDIDATE_START_DATE,
      REFERRED_BY,
      CREATED_DATE,
      DATE_TIME_COMPLETED,
      UPDATED_BY,
      UPDATED_ON,
      RECRUITER,
      CANDIDATE_TAGS,
      CANDIDATE_POOL,
      ETL_BATCHID
    FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION
    MINUS
    SELECT 
      JOB_APPLICATION,
      CANDIDATE_ID,
      POSITION,
      EMPLOYEE_ID,
      SOEID,
      JOB_REQUISITION,
      ORIGINAL_JOB_REQUISITION,
      ADDED_DATE,
      SOURCE_CATEGORY,
      SOURCE,
      RECRUITING_AGENCY,
      CANDIDATE_STATUS,
      LAST_RECRUITING_STAGE,
      JOB_APPLICATION_STEP,
      LAST_RECRUITING_STAGE_NUMBER,
      FINAL_DISPOSITION_REASON,
      OFFER_STATUS,
      HIRED,
      TIME_TO_OFFER_ACCEPT_DAYS,
      TIME_TO_OFFER_REJECT_DAYS,
      CANDIDATE_START_DATE,
      REFERRED_BY,
      CREATED_DATE,
      DATE_TIME_COMPLETED,
      UPDATED_BY,
      UPDATED_ON,
      RECRUITER,
      CANDIDATE_TAGS,
      CANDIDATE_POOL,
      ETL_BATCHID
    FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP
);


---

 SECTION 4  ROWS IN TEMP BUT NOT IN MAIN

SELECT COUNT(*) AS temp_not_in_main
FROM (
    SELECT 
      JOB_APPLICATION,
      CANDIDATE_ID,
      POSITION,
      EMPLOYEE_ID,
      SOEID,
      JOB_REQUISITION,
      ORIGINAL_JOB_REQUISITION,
      ADDED_DATE,
      SOURCE_CATEGORY,
      SOURCE,
      RECRUITING_AGENCY,
      CANDIDATE_STATUS,
      LAST_RECRUITING_STAGE,
      JOB_APPLICATION_STEP,
      LAST_RECRUITING_STAGE_NUMBER,
      FINAL_DISPOSITION_REASON,
      OFFER_STATUS,
      HIRED,
      TIME_TO_OFFER_ACCEPT_DAYS,
      TIME_TO_OFFER_REJECT_DAYS,
      CANDIDATE_START_DATE,
      REFERRED_BY,
      CREATED_DATE,
      DATE_TIME_COMPLETED,
      UPDATED_BY,
      UPDATED_ON,
      RECRUITER,
      CANDIDATE_TAGS,
      CANDIDATE_POOL,
      ETL_BATCHID
    FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP
    MINUS
    SELECT 
      JOB_APPLICATION,
      CANDIDATE_ID,
      POSITION,
      EMPLOYEE_ID,
      SOEID,
      JOB_REQUISITION,
      ORIGINAL_JOB_REQUISITION,
      ADDED_DATE,
      SOURCE_CATEGORY,
      SOURCE,
      RECRUITING_AGENCY,
      CANDIDATE_STATUS,
      LAST_RECRUITING_STAGE,
      JOB_APPLICATION_STEP,
      LAST_RECRUITING_STAGE_NUMBER,
      FINAL_DISPOSITION_REASON,
      OFFER_STATUS,
      HIRED,
      TIME_TO_OFFER_ACCEPT_DAYS,
      TIME_TO_OFFER_REJECT_DAYS,
      CANDIDATE_START_DATE,
      REFERRED_BY,
      CREATED_DATE,
      DATE_TIME_COMPLETED,
      UPDATED_BY,
      UPDATED_ON,
      RECRUITER,
      CANDIDATE_TAGS,
      CANDIDATE_POOL,
      ETL_BATCHID
    FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION
);


---

 SECTION 5  FIND WHICH COLUMNS ARE DIFFERENT

Goal  For each column, check if values differ row-by-row.

Since you cannot create staging tables, we do a direct FULL OUTER JOIN on all columns, comparing each column.

We need a joining key.
Your table DOES HAVE ONE:
 JOB_APPLICATION looks like a primary key.

If wrong, tell me.


---

 Count rows where ANY column differs

SELECT COUNT(*) AS rows_with_any_difference
FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION m
FULL OUTER JOIN WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP t
  ON m.JOB_APPLICATION = t.JOB_APPLICATION
WHERE 
    NVL(m.CANDIDATE_ID,'#') <> NVL(t.CANDIDATE_ID,'#')
 OR NVL(m.POSITION,'#') <> NVL(t.POSITION,'#')
 OR NVL(m.EMPLOYEE_ID,'#') <> NVL(t.EMPLOYEE_ID,'#')
 OR NVL(m.SOEID,'#') <> NVL(t.SOEID,'#')
 OR NVL(m.JOB_REQUISITION,'#') <> NVL(t.JOB_REQUISITION,'#')
 OR NVL(m.ORIGINAL_JOB_REQUISITION,'#') <> NVL(t.ORIGINAL_JOB_REQUISITION,'#')
 OR NVL(TO_CHAR(m.ADDED_DATE,'YYYYMMDDHH24MISS'),'#') <> NVL(TO_CHAR(t.ADDED_DATE,'YYYYMMDDHH24MISS'),'#')
 OR NVL(m.SOURCE_CATEGORY,'#') <> NVL(t.SOURCE_CATEGORY,'#')
 OR NVL(m.SOURCE,'#') <> NVL(t.SOURCE,'#')
 OR NVL(m.RECRUITING_AGENCY,'#') <> NVL(t.RECRUITING_AGENCY,'#')
 OR NVL(m.CANDIDATE_STATUS,'#') <> NVL(t.CANDIDATE_STATUS,'#')
 OR NVL(m.LAST_RECRUITING_STAGE,'#') <> NVL(t.LAST_RECRUITING_STAGE,'#')
 OR NVL(m.JOB_APPLICATION_STEP,'#') <> NVL(t.JOB_APPLICATION_STEP,'#')
 OR NVL(m.LAST_RECRUITING_STAGE_NUMBER,'#') <> NVL(t.LAST_RECRUITING_STAGE_NUMBER,'#')
 OR NVL(m.FINAL_DISPOSITION_REASON,'#') <> NVL(t.FINAL_DISPOSITION_REASON,'#')
 OR NVL(m.OFFER_STATUS,'#') <> NVL(t.OFFER_STATUS,'#')
 OR NVL(m.HIRED,'#') <> NVL(t.HIRED,'#')
 OR NVL(m.TIME_TO_OFFER_ACCEPT_DAYS,'#') <> NVL(t.TIME_TO_OFFER_ACCEPT_DAYS,'#')
 OR NVL(m.TIME_TO_OFFER_REJECT_DAYS,'#') <> NVL(t.TIME_TO_OFFER_REJECT_DAYS,'#')
 OR NVL(TO_CHAR(m.CANDIDATE_START_DATE,'YYYYMMDDHH24MISS'),'#') <> NVL(TO_CHAR(t.CANDIDATE_START_DATE,'YYYYMMDDHH24MISS'),'#')
 OR NVL(m.REFERRED_BY,'#') <> NVL(t.REFERRED_BY,'#')
 OR NVL(TO_CHAR(m.CREATED_DATE,'YYYYMMDDHH24MISS'),'#') <> NVL(TO_CHAR(t.CREATED_DATE,'YYYYMMDDHH24MISS'),'#')
 OR NVL(TO_CHAR(m.DATE_TIME_COMPLETED,'YYYYMMDDHH24MISS'),'#') <> NVL(TO_CHAR(t.DATE_TIME_COMPLETED,'YYYYMMDDHH24MISS'),'#')
 OR NVL(m.UPDATED_BY,'#') <> NVL(t.UPDATED_BY,'#')
 OR NVL(TO_CHAR(m.UPDATED_ON,'YYYYMMDDHH24MISS'),'#') <> NVL(TO_CHAR(t.UPDATED_ON,'YYYYMMDDHH24MISS'),'#')
 OR NVL(m.RECRUITER,'#') <> NVL(t.RECRUITER,'#')
 OR NVL(m.CANDIDATE_TAGS,'#') <> NVL(t.CANDIDATE_TAGS,'#')
 OR NVL(m.CANDIDATE_POOL,'#') <> NVL(t.CANDIDATE_POOL,'#')
 OR NVL(m.ETL_BATCHID,'#') <> NVL(t.ETL_BATCHID,'#');


---

 SECTION 6  WHICH COLUMN IS DIFFERENT & HOW MANY ROWS DIFFER PER COLUMN

SELECT 'CANDIDATE_ID' AS column_name, COUNT(*) AS diff_count FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION m
FULL OUTER JOIN WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP t ON m.JOB_APPLICATION = t.JOB_APPLICATION
WHERE NVL(m.CANDIDATE_ID,'#') <> NVL(t.CANDIDATE_ID,'#')
UNION ALL
SELECT 'POSITION', COUNT(*) FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION m
FULL OUTER JOIN WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP t ON m.JOB_APPLICATION = t.JOB_APPLICATION
WHERE NVL(m.POSITION,'#') <> NVL(t.POSITION,'#')
UNION ALL
SELECT 'EMPLOYEE_ID', COUNT(*) FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION m
FULL OUTER JOIN WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP t ON m.JOB_APPLICATION = t.JOB_APPLICATION
WHERE NVL(m.EMPLOYEE_ID,'#') <> NVL(t.EMPLOYEE_ID,'#')
-- CONTINUE for all 30 columns exactly as above
ORDER BY diff_count DESC;

 I can generate the full 30-column UNION ALL for you automatically
(just say Generate full column diff query).


---

 SECTION 7  SAMPLE ROW-BY-ROW WHERE COLUMNS DIFFER

SELECT m.JOB_APPLICATION,
       m.CANDIDATE_ID AS main_candidate,
       t.CANDIDATE_ID AS temp_candidate,
       m.POSITION AS main_position,
       t.POSITION AS temp_position,
       m.CREATED_DATE AS main_created,
       t.CREATED_DATE AS temp_created
FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION m
JOIN WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP t
  ON m.JOB_APPLICATION = t.JOB_APPLICATION
WHERE NVL(m.CANDIDATE_ID,'#') <> NVL(t.CANDIDATE_ID,'#')
   OR NVL(m.POSITION,'#') <> NVL(t.POSITION,'#')
   OR NVL(TO_CHAR(m.CREATED_DATE,'YYYYMMDDHH24MISS'),'#') <> NVL(TO_CHAR(t.CREATED_DATE,'YYYYMMDDHH24MISS'),'#')
FETCH FIRST 50 ROWS ONLY;


---

 READY.

This is the correct, simplest possible version for an environment where:  you cannot create tables
 you cannot create views
 you cannot run PL/SQL blocks
 you can only run SELECT queries


---

If you want:

I can generate:

 A full diff by each column script (all 30 columns)

 A script that highlights mismatching rows with column-by-column values

 A script that outputs EXACT values side-by-side for mismatching rows

Just tell me:

 Generate full diff script for all 30 columns
or
 Generate row-by-row mismatch viewer


























-- ===========================
-- FINAL SCRIPT using columns from your screenshot
-- Schema: WFA_APP_USR_TALD
-- MAIN table: WD_JOBAPPLICATION
-- TEMP table: WD_JOBAPPLICATION_TEMP
-- ===========================

-- 0) counts for both tables
SELECT 'MAIN' AS which_table, COUNT(*) cnt
FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION
UNION ALL
SELECT 'TEMP', COUNT(*) FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP;

-- 1) Create MATCHING_ROWS (exact identical rows across all common columns)
DROP TABLE MATCHING_ROWS PURGE;
-- ignore errors if you cannot drop (wrap in client if needed)

CREATE TABLE MATCHING_ROWS AS
SELECT JOB_APPLICATION,
       CANDIDATE_ID,
       POSITION,
       EMPLOYEE_ID,
       SOEID,
       JOB_REQUISITION,
       ORIGINAL_JOB_REQUISITION,
       ADDED_DATE,
       SOURCE_CATEGORY,
       SOURCE,
       RECRUITING_AGENCY,
       CANDIDATE_STATUS,
       LAST_RECRUITING_STAGE,
       JOB_APPLICATION_STEP,
       LAST_RECRUITING_STAGE_NUMBER,
       FINAL_DISPOSITION_REASON,
       OFFER_STATUS,
       HIRED,
       TIME_TO_OFFER_ACCEPT_DAYS,
       TIME_TO_OFFER_REJECT_DAYS,
       CANDIDATE_START_DATE,
       REFERRED_BY,
       CREATED_DATE,
       DATE_TIME_COMPLETED,
       UPDATED_BY,
       UPDATED_ON,
       RECRUITER,
       CANDIDATE_TAGS,
       CANDIDATE_POOL,
       ETL_BATCHID
FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION
INTERSECT
SELECT JOB_APPLICATION,
       CANDIDATE_ID,
       POSITION,
       EMPLOYEE_ID,
       SOEID,
       JOB_REQUISITION,
       ORIGINAL_JOB_REQUISITION,
       ADDED_DATE,
       SOURCE_CATEGORY,
       SOURCE,
       RECRUITING_AGENCY,
       CANDIDATE_STATUS,
       LAST_RECRUITING_STAGE,
       JOB_APPLICATION_STEP,
       LAST_RECRUITING_STAGE_NUMBER,
       FINAL_DISPOSITION_REASON,
       OFFER_STATUS,
       HIRED,
       TIME_TO_OFFER_ACCEPT_DAYS,
       TIME_TO_OFFER_REJECT_DAYS,
       CANDIDATE_START_DATE,
       REFERRED_BY,
       CREATED_DATE,
       DATE_TIME_COMPLETED,
       UPDATED_BY,
       UPDATED_ON,
       RECRUITER,
       CANDIDATE_TAGS,
       CANDIDATE_POOL,
       ETL_BATCHID
FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP;

-- quick check
SELECT COUNT(*) FROM MATCHING_ROWS;


-- 2) Rows in MAIN but not in TEMP (exact row diff)
DROP TABLE DIFF_MAIN_NOT_TEMP PURGE;

CREATE TABLE DIFF_MAIN_NOT_TEMP AS
SELECT JOB_APPLICATION,
       CANDIDATE_ID,
       POSITION,
       EMPLOYEE_ID,
       SOEID,
       JOB_REQUISITION,
       ORIGINAL_JOB_REQUISITION,
       ADDED_DATE,
       SOURCE_CATEGORY,
       SOURCE,
       RECRUITING_AGENCY,
       CANDIDATE_STATUS,
       LAST_RECRUITING_STAGE,
       JOB_APPLICATION_STEP,
       LAST_RECRUITING_STAGE_NUMBER,
       FINAL_DISPOSITION_REASON,
       OFFER_STATUS,
       HIRED,
       TIME_TO_OFFER_ACCEPT_DAYS,
       TIME_TO_OFFER_REJECT_DAYS,
       CANDIDATE_START_DATE,
       REFERRED_BY,
       CREATED_DATE,
       DATE_TIME_COMPLETED,
       UPDATED_BY,
       UPDATED_ON,
       RECRUITER,
       CANDIDATE_TAGS,
       CANDIDATE_POOL,
       ETL_BATCHID
FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION
MINUS
SELECT JOB_APPLICATION,
       CANDIDATE_ID,
       POSITION,
       EMPLOYEE_ID,
       SOEID,
       JOB_REQUISITION,
       ORIGINAL_JOB_REQUISITION,
       ADDED_DATE,
       SOURCE_CATEGORY,
       SOURCE,
       RECRUITING_AGENCY,
       CANDIDATE_STATUS,
       LAST_RECRUITING_STAGE,
       JOB_APPLICATION_STEP,
       LAST_RECRUITING_STAGE_NUMBER,
       FINAL_DISPOSITION_REASON,
       OFFER_STATUS,
       HIRED,
       TIME_TO_OFFER_ACCEPT_DAYS,
       TIME_TO_OFFER_REJECT_DAYS,
       CANDIDATE_START_DATE,
       REFERRED_BY,
       CREATED_DATE,
       DATE_TIME_COMPLETED,
       UPDATED_BY,
       UPDATED_ON,
       RECRUITER,
       CANDIDATE_TAGS,
       CANDIDATE_POOL,
       ETL_BATCHID
FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP;

SELECT COUNT(*) FROM DIFF_MAIN_NOT_TEMP;


-- 3) Rows in TEMP but not in MAIN
DROP TABLE DIFF_TEMP_NOT_MAIN PURGE;

CREATE TABLE DIFF_TEMP_NOT_MAIN AS
SELECT JOB_APPLICATION,
       CANDIDATE_ID,
       POSITION,
       EMPLOYEE_ID,
       SOEID,
       JOB_REQUISITION,
       ORIGINAL_JOB_REQUISITION,
       ADDED_DATE,
       SOURCE_CATEGORY,
       SOURCE,
       RECRUITING_AGENCY,
       CANDIDATE_STATUS,
       LAST_RECRUITING_STAGE,
       JOB_APPLICATION_STEP,
       LAST_RECRUITING_STAGE_NUMBER,
       FINAL_DISPOSITION_REASON,
       OFFER_STATUS,
       HIRED,
       TIME_TO_OFFER_ACCEPT_DAYS,
       TIME_TO_OFFER_REJECT_DAYS,
       CANDIDATE_START_DATE,
       REFERRED_BY,
       CREATED_DATE,
       DATE_TIME_COMPLETED,
       UPDATED_BY,
       UPDATED_ON,
       RECRUITER,
       CANDIDATE_TAGS,
       CANDIDATE_POOL,
       ETL_BATCHID
FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP
MINUS
SELECT JOB_APPLICATION,
       CANDIDATE_ID,
       POSITION,
       EMPLOYEE_ID,
       SOEID,
       JOB_REQUISITION,
       ORIGINAL_JOB_REQUISITION,
       ADDED_DATE,
       SOURCE_CATEGORY,
       SOURCE,
       RECRUITING_AGENCY,
       CANDIDATE_STATUS,
       LAST_RECRUITING_STAGE,
       JOB_APPLICATION_STEP,
       LAST_RECRUITING_STAGE_NUMBER,
       FINAL_DISPOSITION_REASON,
       OFFER_STATUS,
       HIRED,
       TIME_TO_OFFER_ACCEPT_DAYS,
       TIME_TO_OFFER_REJECT_DAYS,
       CANDIDATE_START_DATE,
       REFERRED_BY,
       CREATED_DATE,
       DATE_TIME_COMPLETED,
       UPDATED_BY,
       UPDATED_ON,
       RECRUITER,
       CANDIDATE_TAGS,
       CANDIDATE_POOL,
       ETL_BATCHID
FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION;

SELECT COUNT(*) FROM DIFF_TEMP_NOT_MAIN;


-- 4) STAGING VIEWS to align rows using ROW_NUMBER()
-- Drop views if already exist (silent errors ok - run in worksheet)
BEGIN
  EXECUTE IMMEDIATE 'DROP VIEW STG_MAIN_VIEW';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
  EXECUTE IMMEDIATE 'DROP VIEW STG_TEMP_VIEW';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

CREATE OR REPLACE VIEW STG_MAIN_VIEW AS
SELECT ROW_NUMBER() OVER (ORDER BY JOB_APPLICATION,
                                   CANDIDATE_ID,
                                   POSITION,
                                   EMPLOYEE_ID,
                                   SOEID,
                                   JOB_REQUISITION,
                                   ORIGINAL_JOB_REQUISITION,
                                   ADDED_DATE,
                                   SOURCE_CATEGORY,
                                   SOURCE,
                                   RECRUITING_AGENCY,
                                   CANDIDATE_STATUS,
                                   LAST_RECRUITING_STAGE,
                                   JOB_APPLICATION_STEP,
                                   LAST_RECRUITING_STAGE_NUMBER,
                                   FINAL_DISPOSITION_REASON,
                                   OFFER_STATUS,
                                   HIRED,
                                   TIME_TO_OFFER_ACCEPT_DAYS,
                                   TIME_TO_OFFER_REJECT_DAYS,
                                   CANDIDATE_START_DATE,
                                   REFERRED_BY,
                                   CREATED_DATE,
                                   DATE_TIME_COMPLETED,
                                   UPDATED_BY,
                                   UPDATED_ON,
                                   RECRUITER,
                                   CANDIDATE_TAGS,
                                   CANDIDATE_POOL,
                                   ETL_BATCHID
                      ) rn,
       TO_CHAR(JOB_APPLICATION) AS JOB_APPLICATION,
       TO_CHAR(CANDIDATE_ID) AS CANDIDATE_ID,
       TO_CHAR(POSITION) AS POSITION,
       TO_CHAR(EMPLOYEE_ID) AS EMPLOYEE_ID,
       TO_CHAR(SOEID) AS SOEID,
       TO_CHAR(JOB_REQUISITION) AS JOB_REQUISITION,
       TO_CHAR(ORIGINAL_JOB_REQUISITION) AS ORIGINAL_JOB_REQUISITION,
       TO_CHAR(ADDED_DATE,'YYYY-MM-DD HH24:MI:SS') AS ADDED_DATE,
       TO_CHAR(SOURCE_CATEGORY) AS SOURCE_CATEGORY,
       TO_CHAR(SOURCE) AS SOURCE,
       TO_CHAR(RECRUITING_AGENCY) AS RECRUITING_AGENCY,
       TO_CHAR(CANDIDATE_STATUS) AS CANDIDATE_STATUS,
       TO_CHAR(LAST_RECRUITING_STAGE) AS LAST_RECRUITING_STAGE,
       TO_CHAR(JOB_APPLICATION_STEP) AS JOB_APPLICATION_STEP,
       TO_CHAR(LAST_RECRUITING_STAGE_NUMBER) AS LAST_RECRUITING_STAGE_NUMBER,
       TO_CHAR(FINAL_DISPOSITION_REASON) AS FINAL_DISPOSITION_REASON,
       TO_CHAR(OFFER_STATUS) AS OFFER_STATUS,
       TO_CHAR(HIRED) AS HIRED,
       TO_CHAR(TIME_TO_OFFER_ACCEPT_DAYS) AS TIME_TO_OFFER_ACCEPT_DAYS,
       TO_CHAR(TIME_TO_OFFER_REJECT_DAYS) AS TIME_TO_OFFER_REJECT_DAYS,
       TO_CHAR(CANDIDATE_START_DATE,'YYYY-MM-DD HH24:MI:SS') AS CANDIDATE_START_DATE,
       TO_CHAR(REFERRED_BY) AS REFERRED_BY,
       TO_CHAR(CREATED_DATE,'YYYY-MM-DD HH24:MI:SS') AS CREATED_DATE,
       TO_CHAR(DATE_TIME_COMPLETED,'YYYY-MM-DD HH24:MI:SS') AS DATE_TIME_COMPLETED,
       TO_CHAR(UPDATED_BY) AS UPDATED_BY,
       TO_CHAR(UPDATED_ON,'YYYY-MM-DD HH24:MI:SS') AS UPDATED_ON,
       TO_CHAR(RECRUITER) AS RECRUITER,
       TO_CHAR(CANDIDATE_TAGS) AS CANDIDATE_TAGS,
       TO_CHAR(CANDIDATE_POOL) AS CANDIDATE_POOL,
       TO_CHAR(ETL_BATCHID) AS ETL_BATCHID
FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION;


CREATE OR REPLACE VIEW STG_TEMP_VIEW AS
SELECT ROW_NUMBER() OVER (ORDER BY JOB_APPLICATION,
                                   CANDIDATE_ID,
                                   POSITION,
                                   EMPLOYEE_ID,
                                   SOEID,
                                   JOB_REQUISITION,
                                   ORIGINAL_JOB_REQUISITION,
                                   ADDED_DATE,
                                   SOURCE_CATEGORY,
                                   SOURCE,
                                   RECRUITING_AGENCY,
                                   CANDIDATE_STATUS,
                                   LAST_RECRUITING_STAGE,
                                   JOB_APPLICATION_STEP,
                                   LAST_RECRUITING_STAGE_NUMBER,
                                   FINAL_DISPOSITION_REASON,
                                   OFFER_STATUS,
                                   HIRED,
                                   TIME_TO_OFFER_ACCEPT_DAYS,
                                   TIME_TO_OFFER_REJECT_DAYS,
                                   CANDIDATE_START_DATE,
                                   REFERRED_BY,
                                   CREATED_DATE,
                                   DATE_TIME_COMPLETED,
                                   UPDATED_BY,
                                   UPDATED_ON,
                                   RECRUITER,
                                   CANDIDATE_TAGS,
                                   CANDIDATE_POOL,
                                   ETL_BATCHID
                      ) rn,
       TO_CHAR(JOB_APPLICATION) AS JOB_APPLICATION,
       TO_CHAR(CANDIDATE_ID) AS CANDIDATE_ID,
       TO_CHAR(POSITION) AS POSITION,
       TO_CHAR(EMPLOYEE_ID) AS EMPLOYEE_ID,
       TO_CHAR(SOEID) AS SOEID,
       TO_CHAR(JOB_REQUISITION) AS JOB_REQUISITION,
       TO_CHAR(ORIGINAL_JOB_REQUISITION) AS ORIGINAL_JOB_REQUISITION,
       TO_CHAR(ADDED_DATE,'YYYY-MM-DD HH24:MI:SS') AS ADDED_DATE,
       TO_CHAR(SOURCE_CATEGORY) AS SOURCE_CATEGORY,
       TO_CHAR(SOURCE) AS SOURCE,
       TO_CHAR(RECRUITING_AGENCY) AS RECRUITING_AGENCY,
       TO_CHAR(CANDIDATE_STATUS) AS CANDIDATE_STATUS,
       TO_CHAR(LAST_RECRUITING_STAGE) AS LAST_RECRUITING_STAGE,
       TO_CHAR(JOB_APPLICATION_STEP) AS JOB_APPLICATION_STEP,
       TO_CHAR(LAST_RECRUITING_STAGE_NUMBER) AS LAST_RECRUITING_STAGE_NUMBER,
       TO_CHAR(FINAL_DISPOSITION_REASON) AS FINAL_DISPOSITION_REASON,
       TO_CHAR(OFFER_STATUS) AS OFFER_STATUS,
       TO_CHAR(HIRED) AS HIRED,
       TO_CHAR(TIME_TO_OFFER_ACCEPT_DAYS) AS TIME_TO_OFFER_ACCEPT_DAYS,
       TO_CHAR(TIME_TO_OFFER_REJECT_DAYS) AS TIME_TO_OFFER_REJECT_DAYS,
       TO_CHAR(CANDIDATE_START_DATE,'YYYY-MM-DD HH24:MI:SS') AS CANDIDATE_START_DATE,
       TO_CHAR(REFERRED_BY) AS REFERRED_BY,
       TO_CHAR(CREATED_DATE,'YYYY-MM-DD HH24:MI:SS') AS CREATED_DATE,
       TO_CHAR(DATE_TIME_COMPLETED,'YYYY-MM-DD HH24:MI:SS') AS DATE_TIME_COMPLETED,
       TO_CHAR(UPDATED_BY) AS UPDATED_BY,
       TO_CHAR(UPDATED_ON,'YYYY-MM-DD HH24:MI:SS') AS UPDATED_ON,
       TO_CHAR(RECRUITER) AS RECRUITER,
       TO_CHAR(CANDIDATE_TAGS) AS CANDIDATE_TAGS,
       TO_CHAR(CANDIDATE_POOL) AS CANDIDATE_POOL,
       TO_CHAR(ETL_BATCHID) AS ETL_BATCHID
FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP;


-- quick staging counts
SELECT 'STG_MAIN rows' label, COUNT(*) FROM STG_MAIN_VIEW
UNION ALL
SELECT 'STG_TEMP rows', COUNT(*) FROM STG_TEMP_VIEW;


-- 5) UNPIVOT both sides and compare
-- Create unpivot views (turn columns into (col_name, val) rows)
CREATE OR REPLACE VIEW UNPIVOT_MAIN AS
SELECT rn, col_name, val
FROM STG_MAIN_VIEW
UNPIVOT ( val FOR col_name IN (
  JOB_APPLICATION,
  CANDIDATE_ID,
  POSITION,
  EMPLOYEE_ID,
  SOEID,
  JOB_REQUISITION,
  ORIGINAL_JOB_REQUISITION,
  ADDED_DATE,
  SOURCE_CATEGORY,
  SOURCE,
  RECRUITING_AGENCY,
  CANDIDATE_STATUS,
  LAST_RECRUITING_STAGE,
  JOB_APPLICATION_STEP,
  LAST_RECRUITING_STAGE_NUMBER,
  FINAL_DISPOSITION_REASON,
  OFFER_STATUS,
  HIRED,
  TIME_TO_OFFER_ACCEPT_DAYS,
  TIME_TO_OFFER_REJECT_DAYS,
  CANDIDATE_START_DATE,
  REFERRED_BY,
  CREATED_DATE,
  DATE_TIME_COMPLETED,
  UPDATED_BY,
  UPDATED_ON,
  RECRUITER,
  CANDIDATE_TAGS,
  CANDIDATE_POOL,
  ETL_BATCHID
) );

CREATE OR REPLACE VIEW UNPIVOT_TEMP AS
SELECT rn, col_name, val
FROM STG_TEMP_VIEW
UNPIVOT ( val FOR col_name IN (
  JOB_APPLICATION,
  CANDIDATE_ID,
  POSITION,
  EMPLOYEE_ID,
  SOEID,
  JOB_REQUISITION,
  ORIGINAL_JOB_REQUISITION,
  ADDED_DATE,
  SOURCE_CATEGORY,
  SOURCE,
  RECRUITING_AGENCY,
  CANDIDATE_STATUS,
  LAST_RECRUITING_STAGE,
  JOB_APPLICATION_STEP,
  LAST_RECRUITING_STAGE_NUMBER,
  FINAL_DISPOSITION_REASON,
  OFFER_STATUS,
  HIRED,
  TIME_TO_OFFER_ACCEPT_DAYS,
  TIME_TO_OFFER_REJECT_DAYS,
  CANDIDATE_START_DATE,
  REFERRED_BY,
  CREATED_DATE,
  DATE_TIME_COMPLETED,
  UPDATED_BY,
  UPDATED_ON,
  RECRUITER,
  CANDIDATE_TAGS,
  CANDIDATE_POOL,
  ETL_BATCHID
) );

-- 6) create per-column differences by joining on rn + column name
DROP TABLE COL_DIFFS PURGE;

CREATE TABLE COL_DIFFS AS
SELECT m.rn,
       m.col_name,
       m.val AS main_val,
       t.val AS temp_val
FROM UNPIVOT_MAIN m
JOIN UNPIVOT_TEMP t
  ON m.rn = t.rn
 AND m.col_name = t.col_name
WHERE NVL(m.val,'<NULL>') <> NVL(t.val,'<NULL>');

-- 7) summary & examples
SELECT COUNT(*) AS total_column_differences FROM COL_DIFFS;
SELECT COUNT(DISTINCT rn) AS rows_with_differences FROM COL_DIFFS;

-- show sample differences (first 200)
SELECT * FROM COL_DIFFS ORDER BY rn, col_name FETCH FIRST 200 ROWS ONLY;































SET SERVEROUTPUT ON SIZE 2000000
DECLARE
  owner_name CONSTANT VARCHAR2(30) := 'WFA_APP_USR_TALD';
  main_table CONSTANT VARCHAR2(30) := 'WD_JOBAPPLICATION';
  temp_table CONSTANT VARCHAR2(30) := 'WD_JOBAPPLICATION_TEMP';

  l_col_list_quoted VARCHAR2(32767);
  l_col_list_order  VARCHAR2(32767);
  l_sql CLOB;
  v_count NUMBER;
  CURSOR c_cols IS
    SELECT column_name, data_type
    FROM all_tab_columns
    WHERE owner = owner_name
      AND table_name = main_table
      AND column_name IN (
        SELECT column_name FROM all_tab_columns
        WHERE owner = owner_name
          AND table_name = temp_table
      )
    ORDER BY column_id;
BEGIN
  -- Build list of common columns in MAIN table order (quoted, comma separated)
  SELECT LISTAGG('"' || column_name || '"', ', ') WITHIN GROUP (ORDER BY column_id)
    INTO l_col_list_quoted
  FROM all_tab_columns
  WHERE owner = owner_name
    AND table_name = main_table
    AND column_name IN (
      SELECT column_name FROM all_tab_columns
      WHERE owner = owner_name
        AND table_name = temp_table
    );

  IF l_col_list_quoted IS NULL THEN
    RAISE_APPLICATION_ERROR(-20001, 'No common columns found between '||main_table||' and '||temp_table);
  END IF;

  -- Use the same quoted list for ORDER BY building (it is safe as a list)
  l_col_list_order := l_col_list_quoted;

  DBMS_OUTPUT.PUT_LINE('Common columns to compare built.');

  -- 1) Create MATCHING_ROWS using INTERSECT (exact identical rows)
  BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE MATCHING_ROWS';
  EXCEPTION WHEN OTHERS THEN NULL;
  END;

  l_sql := 'CREATE TABLE MATCHING_ROWS AS ' ||
           'SELECT ' || l_col_list_quoted || ' FROM '||owner_name||'.' || main_table ||
           ' INTERSECT ' ||
           'SELECT ' || l_col_list_quoted || ' FROM '||owner_name||'.' || temp_table;
  DBMS_OUTPUT.PUT_LINE('Creating MATCHING_ROWS ...');
  EXECUTE IMMEDIATE l_sql;
  DBMS_OUTPUT.PUT_LINE('MATCHING_ROWS created.');

  -- 2) Create DIFF_MAIN_NOT_TEMP and DIFF_TEMP_NOT_MAIN using MINUS
  BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE DIFF_MAIN_NOT_TEMP';
  EXCEPTION WHEN OTHERS THEN NULL;
  END;
  l_sql := 'CREATE TABLE DIFF_MAIN_NOT_TEMP AS ' ||
           'SELECT ' || l_col_list_quoted || ' FROM '||owner_name||'.' || main_table ||
           ' MINUS ' ||
           'SELECT ' || l_col_list_quoted || ' FROM '||owner_name||'.' || temp_table;
  EXECUTE IMMEDIATE l_sql;
  DBMS_OUTPUT.PUT_LINE('DIFF_MAIN_NOT_TEMP created.');

  BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE DIFF_TEMP_NOT_MAIN';
  EXCEPTION WHEN OTHERS THEN NULL;
  END;
  l_sql := 'CREATE TABLE DIFF_TEMP_NOT_MAIN AS ' ||
           'SELECT ' || l_col_list_quoted || ' FROM '||owner_name||'.' || temp_table ||
           ' MINUS ' ||
           'SELECT ' || l_col_list_quoted || ' FROM '||owner_name||'.' || main_table;
  EXECUTE IMMEDIATE l_sql;
  DBMS_OUTPUT.PUT_LINE('DIFF_TEMP_NOT_MAIN created.');

  -- 3) Create staging tables with row numbers to align rows (RN)
  BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE STG_MAIN';
  EXCEPTION WHEN OTHERS THEN NULL;
  END;
  l_sql := 'CREATE TABLE STG_MAIN AS ' ||
           'SELECT ROW_NUMBER() OVER (ORDER BY '|| l_col_list_order ||') rn, ' || l_col_list_quoted ||
           ' FROM '||owner_name||'.' || main_table;
  EXECUTE IMMEDIATE l_sql;
  DBMS_OUTPUT.PUT_LINE('STG_MAIN created (with rn).');

  BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE STG_TEMP';
  EXCEPTION WHEN OTHERS THEN NULL;
  END;
  l_sql := 'CREATE TABLE STG_TEMP AS ' ||
           'SELECT ROW_NUMBER() OVER (ORDER BY '|| l_col_list_order ||') rn, ' || l_col_list_quoted ||
           ' FROM '||owner_name||'.' || temp_table;
  EXECUTE IMMEDIATE l_sql;
  DBMS_OUTPUT.PUT_LINE('STG_TEMP created (with rn).');

  -- 4) Generate per-column UNION ALL dynamic SQL to find differing columns for each aligned RN
  l_sql := NULL;
  FOR r IN c_cols LOOP
    -- skip LOB types which are hard to TO_CHAR
    IF r.data_type IN ('BLOB','CLOB','NCLOB','LONG') THEN
      DBMS_OUTPUT.PUT_LINE('Skipping LOB column '||r.column_name||' for per-column diff.');
      CONTINUE;
    END IF;

    IF l_sql IS NULL THEN
      l_sql := 'SELECT m.rn, ' ||
               '''' || r.column_name || ''' AS column_name, ' ||
               'CASE WHEN m."'|| r.column_name ||'" IS NULL THEN NULL ELSE TO_CHAR(m."'|| r.column_name ||'") END AS main_val, ' ||
               'CASE WHEN t."'|| r.column_name ||'" IS NULL THEN NULL ELSE TO_CHAR(t."'|| r.column_name ||'") END AS temp_val ' ||
               'FROM STG_MAIN m JOIN STG_TEMP t ON m.rn = t.rn ' ||
               'WHERE NOT ( (m."'|| r.column_name ||'" = t."'|| r.column_name ||'") OR (m."'|| r.column_name ||'" IS NULL AND t."'|| r.column_name ||'" IS NULL) )';
    ELSE
      l_sql := l_sql || CHR(10) || 'UNION ALL' || CHR(10) ||
               'SELECT m.rn, ' ||
               '''' || r.column_name || ''' AS column_name, ' ||
               'CASE WHEN m."'|| r.column_name ||'" IS NULL THEN NULL ELSE TO_CHAR(m."'|| r.column_name ||'") END AS main_val, ' ||
               'CASE WHEN t."'|| r.column_name ||'" IS NULL THEN NULL ELSE TO_CHAR(t."'|| r.column_name ||'") END AS temp_val ' ||
               'FROM STG_MAIN m JOIN STG_TEMP t ON m.rn = t.rn ' ||
               'WHERE NOT ( (m."'|| r.column_name ||'" = t."'|| r.column_name ||'") OR (m."'|| r.column_name ||'" IS NULL AND t."'|| r.column_name ||'" IS NULL) )';
    END IF;
  END LOOP;

  IF l_sql IS NULL THEN
    DBMS_OUTPUT.PUT_LINE('No non-LOB common columns to compare for per-column diff.');
  ELSE
    BEGIN
      EXECUTE IMMEDIATE 'DROP TABLE COL_DIFFS';
    EXCEPTION WHEN OTHERS THEN NULL;
    END;

    -- NOTE: do NOT append ORDER BY to CREATE TABLE AS SELECT
    l_sql := 'CREATE TABLE COL_DIFFS AS ' || CHR(10) || l_sql;

    DBMS_OUTPUT.PUT_LINE('Creating COL_DIFFS (per-column diffs) ...');
    EXECUTE IMMEDIATE l_sql;
    DBMS_OUTPUT.PUT_LINE('COL_DIFFS created. Columns: rn | column_name | main_val | temp_val');
  END IF;

  -- print counts using SELECT INTO (more robust)
  BEGIN
    SELECT COUNT(*) INTO v_count FROM MATCHING_ROWS;
    DBMS_OUTPUT.PUT_LINE('MATCHING_ROWS count: ' || v_count);
  EXCEPTION WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('MATCHING_ROWS count: unable to get count - '||SQLERRM);
  END;
  BEGIN
    SELECT COUNT(*) INTO v_count FROM DIFF_MAIN_NOT_TEMP;
    DBMS_OUTPUT.PUT_LINE('DIFF_MAIN_NOT_TEMP count: ' || v_count);
  EXCEPTION WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('DIFF_MAIN_NOT_TEMP count: unable to get count - '||SQLERRM);
  END;
  BEGIN
    SELECT COUNT(*) INTO v_count FROM DIFF_TEMP_NOT_MAIN;
    DBMS_OUTPUT.PUT_LINE('DIFF_TEMP_NOT_MAIN count: ' || v_count);
  EXCEPTION WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('DIFF_TEMP_NOT_MAIN count: unable to get count - '||SQLERRM);
  END;
  BEGIN
    SELECT COUNT(*) INTO v_count FROM COL_DIFFS;
    DBMS_OUTPUT.PUT_LINE('COL_DIFFS row count: ' || v_count);
  EXCEPTION WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('COL_DIFFS count: unable to get count - '||SQLERRM);
  END;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error: '||SQLERRM);
    RAISE;
END;
/









SET SERVEROUTPUT ON SIZE 2000000
DECLARE
  owner_name CONSTANT VARCHAR2(30) := 'WFA_APP_USR_TALD';
  main_table CONSTANT VARCHAR2(30) := 'WD_JOBAPPLICATION';
  temp_table CONSTANT VARCHAR2(30) := 'WD_JOBAPPLICATION_TEMP';

  l_common_cols   VARCHAR2(32767);
  l_col_list_quoted VARCHAR2(32767);
  l_col_list_order  VARCHAR2(32767);
  l_sql CLOB;
  CURSOR c_cols IS
    SELECT column_name, data_type
    FROM all_tab_columns
    WHERE owner = owner_name
      AND table_name = main_table
      AND column_name IN (
        SELECT column_name FROM all_tab_columns
        WHERE owner = owner_name
          AND table_name = temp_table
      )
    ORDER BY column_id;
BEGIN
  -- Build list of common columns in MAIN table order
  SELECT LISTAGG('"' || column_name || '"', ', ') WITHIN GROUP (ORDER BY column_id)
    INTO l_col_list_quoted
  FROM all_tab_columns
  WHERE owner = owner_name
    AND table_name = main_table
    AND column_name IN (
      SELECT column_name FROM all_tab_columns
      WHERE owner = owner_name
        AND table_name = temp_table
    );

  IF l_col_list_quoted IS NULL THEN
    RAISE_APPLICATION_ERROR(-20001, 'No common columns found between '||main_table||' and '||temp_table);
  END IF;

  -- same list but plain (used for ORDER BY building)
  l_col_list_order := l_col_list_quoted; -- will use quoted list for ORDER BY and SELECTs

  DBMS_OUTPUT.PUT_LINE('Common columns (count): ' ||
                       (SELECT COUNT(*) FROM all_tab_columns
                        WHERE owner = owner_name AND table_name = main_table
                          AND column_name IN (
                            SELECT column_name FROM all_tab_columns
                            WHERE owner = owner_name AND table_name = temp_table)));

  DBMS_OUTPUT.PUT_LINE('Columns to compare: ' || SUBSTR(l_col_list_quoted,1,1000));

  -- 1) Create MATCHING_ROWS using INTERSECT (exact identical rows)
  BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE MATCHING_ROWS';
  EXCEPTION WHEN OTHERS THEN NULL;
  END;

  l_sql := 'CREATE TABLE MATCHING_ROWS AS ' ||
           'SELECT ' || l_col_list_quoted || ' FROM '||owner_name||'.' || main_table ||
           ' INTERSECT ' ||
           'SELECT ' || l_col_list_quoted || ' FROM '||owner_name||'.' || temp_table;
  DBMS_OUTPUT.PUT_LINE('Creating MATCHING_ROWS ...');
  EXECUTE IMMEDIATE l_sql;
  DBMS_OUTPUT.PUT_LINE('MATCHING_ROWS created.');

  -- 2) Create DIFF_MAIN_NOT_TEMP and DIFF_TEMP_NOT_MAIN using MINUS
  BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE DIFF_MAIN_NOT_TEMP';
  EXCEPTION WHEN OTHERS THEN NULL;
  END;
  l_sql := 'CREATE TABLE DIFF_MAIN_NOT_TEMP AS ' ||
           'SELECT ' || l_col_list_quoted || ' FROM '||owner_name||'.' || main_table ||
           ' MINUS ' ||
           'SELECT ' || l_col_list_quoted || ' FROM '||owner_name||'.' || temp_table;
  EXECUTE IMMEDIATE l_sql;
  DBMS_OUTPUT.PUT_LINE('DIFF_MAIN_NOT_TEMP created.');

  BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE DIFF_TEMP_NOT_MAIN';
  EXCEPTION WHEN OTHERS THEN NULL;
  END;
  l_sql := 'CREATE TABLE DIFF_TEMP_NOT_MAIN AS ' ||
           'SELECT ' || l_col_list_quoted || ' FROM '||owner_name||'.' || temp_table ||
           ' MINUS ' ||
           'SELECT ' || l_col_list_quoted || ' FROM '||owner_name||'.' || main_table;
  EXECUTE IMMEDIATE l_sql;
  DBMS_OUTPUT.PUT_LINE('DIFF_TEMP_NOT_MAIN created.');

  -- 3) Create staging tables with row numbers to align rows (RN)
  BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE STG_MAIN';
  EXCEPTION WHEN OTHERS THEN NULL;
  END;
  l_sql := 'CREATE TABLE STG_MAIN AS ' ||
           'SELECT ROW_NUMBER() OVER (ORDER BY '|| l_col_list_order ||') rn, ' || l_col_list_quoted ||
           ' FROM '||owner_name||'.' || main_table;
  EXECUTE IMMEDIATE l_sql;
  DBMS_OUTPUT.PUT_LINE('STG_MAIN created (with rn).');

  BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE STG_TEMP';
  EXCEPTION WHEN OTHERS THEN NULL;
  END;
  l_sql := 'CREATE TABLE STG_TEMP AS ' ||
           'SELECT ROW_NUMBER() OVER (ORDER BY '|| l_col_list_order ||') rn, ' || l_col_list_quoted ||
           ' FROM '||owner_name||'.' || temp_table;
  EXECUTE IMMEDIATE l_sql;
  DBMS_OUTPUT.PUT_LINE('STG_TEMP created (with rn).');

  -- 4) Generate per-column UNION ALL dynamic SQL to find differing columns for each aligned RN
  -- Build the union SELECTs for each non-LOB common column
  l_sql := NULL;
  FOR r IN c_cols LOOP
    -- skip LOBs
    IF r.data_type IN ('BLOB','CLOB','NCLOB','LONG') THEN
      DBMS_OUTPUT.PUT_LINE('Skipping LOB column '||r.column_name||' for per-column diff.');
      CONTINUE;
    END IF;

    -- build a single SELECT that compares this column for all aligned rows
    IF l_sql IS NULL THEN
      l_sql := 'SELECT m.rn, ' ||
               '''' || r.column_name || ''' AS column_name, ' ||
               'CASE WHEN m."'|| r.column_name ||'" IS NULL THEN NULL ELSE TO_CHAR(m."'|| r.column_name ||'") END AS main_val, ' ||
               'CASE WHEN t."'|| r.column_name ||'" IS NULL THEN NULL ELSE TO_CHAR(t."'|| r.column_name ||'") END AS temp_val ' ||
               'FROM STG_MAIN m JOIN STG_TEMP t ON m.rn = t.rn ' ||
               'WHERE NOT ( (m."'|| r.column_name ||'" = t."'|| r.column_name ||'") OR (m."'|| r.column_name ||'" IS NULL AND t."'|| r.column_name ||'" IS NULL) )';
    ELSE
      l_sql := l_sql || CHR(10) || 'UNION ALL' || CHR(10) ||
               'SELECT m.rn, ' ||
               '''' || r.column_name || ''' AS column_name, ' ||
               'CASE WHEN m."'|| r.column_name ||'" IS NULL THEN NULL ELSE TO_CHAR(m."'|| r.column_name ||'") END AS main_val, ' ||
               'CASE WHEN t."'|| r.column_name ||'" IS NULL THEN NULL ELSE TO_CHAR(t."'|| r.column_name ||'") END AS temp_val ' ||
               'FROM STG_MAIN m JOIN STG_TEMP t ON m.rn = t.rn ' ||
               'WHERE NOT ( (m."'|| r.column_name ||'" = t."'|| r.column_name ||'") OR (m."'|| r.column_name ||'" IS NULL AND t."'|| r.column_name ||'" IS NULL) )';
    END IF;
  END LOOP;

  IF l_sql IS NULL THEN
    DBMS_OUTPUT.PUT_LINE('No non-LOB common columns to compare for per-column diff.');
  ELSE
    -- create COL_DIFFS table (drop if exists)
    BEGIN
      EXECUTE IMMEDIATE 'DROP TABLE COL_DIFFS';
    EXCEPTION WHEN OTHERS THEN NULL;
    END;

    l_sql := 'CREATE TABLE COL_DIFFS AS ' || CHR(10) || l_sql || CHR(10) || 'ORDER BY rn, column_name';

    DBMS_OUTPUT.PUT_LINE('Creating COL_DIFFS (per-column diffs) ...');
    -- Note: ORDER BY in CREATE TABLE AS SELECT may not be meaningful in all clients, but we keep for clarity
    EXECUTE IMMEDIATE l_sql;
    DBMS_OUTPUT.PUT_LINE('COL_DIFFS created. Columns: rn | column_name | main_val | temp_val');
  END IF;

  DBMS_OUTPUT.PUT_LINE('--- Summary ---');
  DBMS_OUTPUT.PUT_LINE('MATCHING_ROWS count: ' ||
    TO_CHAR(EXTRACTVALUE(XMLTYPE(DBMS_XMLGEN.GETXML('SELECT COUNT(*) c FROM MATCHING_ROWS')), '/ROWSET/ROW/C')));
  DBMS_OUTPUT.PUT_LINE('DIFF_MAIN_NOT_TEMP count: ' ||
    TO_CHAR(EXTRACTVALUE(XMLTYPE(DBMS_XMLGEN.GETXML('SELECT COUNT(*) c FROM DIFF_MAIN_NOT_TEMP')), '/ROWSET/ROW/C')));
  DBMS_OUTPUT.PUT_LINE('DIFF_TEMP_NOT_MAIN count: ' ||
    TO_CHAR(EXTRACTVALUE(XMLTYPE(DBMS_XMLGEN.GETXML('SELECT COUNT(*) c FROM DIFF_TEMP_NOT_MAIN')), '/ROWSET/ROW/C')));
  DBMS_OUTPUT.PUT_LINE('COL_DIFFS row count: ' ||
    TO_CHAR(EXTRACTVALUE(XMLTYPE(DBMS_XMLGEN.GETXML('SELECT COUNT(*) c FROM COL_DIFFS')), '/ROWSET/ROW/C')));

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error: '||SQLERRM);
    RAISE;
END;
/










How to use the results (quick commands)

Exact matching rows:


SELECT * FROM MATCHING_ROWS WHERE ROWNUM < 20;
SELECT COUNT(*) FROM MATCHING_ROWS;

Rows present in MAIN but absent in TEMP:


SELECT * FROM DIFF_MAIN_NOT_TEMP WHERE ROWNUM < 20;
SELECT COUNT(*) FROM DIFF_MAIN_NOT_TEMP;

Rows present in TEMP but absent in MAIN:


SELECT * FROM DIFF_TEMP_NOT_MAIN WHERE ROWNUM < 20;
SELECT COUNT(*) FROM DIFF_TEMP_NOT_MAIN;

Per-row per-column differences:


-- which rows (by RN) have differences and how many columns differ:
SELECT rn, COUNT(*) diff_col_count
FROM COL_DIFFS
GROUP BY rn
ORDER BY diff_col_count DESC;

-- example: see which columns differ for a specific aligned row (rn=123)
SELECT * FROM COL_DIFFS WHERE rn = 123 ORDER BY column_name;

-- see the first 100 differences overall
SELECT * FROM COL_DIFFS WHERE ROWNUM <= 100 ORDER BY rn, column_name;


































-- shows the ordered list of columns that are in both tables
SELECT LISTAGG(column_name, ', ') WITHIN GROUP (ORDER BY column_id) AS common_col_list
FROM all_tab_columns
WHERE owner = 'WFA_APP_USR_TALD'
  AND table_name IN ('WD_JOBAPPLICATION','WD_JOBAPPLICATION_TEMP')
GROUP BY column_name
HAVING COUNT(DISTINCT table_name) = 2
ORDER BY NULL;



SELECT column_name, MIN(table_name) as in_tables
FROM all_tab_columns
WHERE owner='WFA_APP_USR_TALD'
  AND table_name IN ('WD_JOBAPPLICATION','WD_JOBAPPLICATION_TEMP')
GROUP BY column_name
HAVING COUNT(DISTINCT table_name) = 2
ORDER BY MIN(column_id);




-- rows present in MAIN but not in TEMP
SELECT col_a, col_b, col_c, ... 
FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION
MINUS
SELECT col_a, col_b, col_c, ...
FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP;








-- count rows in the exact-minus sets
SELECT 'MAIN_NOT_TEMP' name, COUNT(*) cnt FROM (
  SELECT /*+ NO_MERGE */ * FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION
  MINUS
  SELECT /*+ NO_MERGE */ * FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP
)
UNION ALL
SELECT 'TEMP_NOT_MAIN', COUNT(*) FROM (
  SELECT /*+ NO_MERGE */ * FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP
  MINUS
  SELECT /*+ NO_MERGE */ * FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION
);















-- column count
SELECT table_name, COUNT(*) col_count
FROM all_tab_columns
WHERE owner = 'WFA_APP_USR_TALD'
  AND table_name IN ('WD_JOBAPPLICATION','WD_JOBAPPLICATION_TEMP')
GROUP BY table_name;

-- list columns with datatype and length for MAIN
SELECT column_id, column_name, data_type, data_length, data_precision, nullable
FROM all_tab_columns
WHERE owner = 'WFA_APP_USR_TALD' AND table_name = 'WD_JOBAPPLICATION'
ORDER BY column_id;

-- list columns for TEMP
SELECT column_id, column_name, data_type, data_length, data_precision, nullable
FROM all_tab_columns
WHERE owner = 'WFA_APP_USR_TALD' AND table_name = 'WD_JOBAPPLICATION_TEMP'
ORDER BY column_id;




-- columns present in MAIN but not in TEMP
SELECT a.column_name
FROM all_tab_columns a
LEFT JOIN all_tab_columns b
  ON a.owner = b.owner
 AND a.column_name = b.column_name
  AND b.table_name = 'WD_JOBAPPLICATION_TEMP'
WHERE a.owner = 'WFA_APP_USR_TALD'
  AND a.table_name = 'WD_JOBAPPLICATION'
  AND b.column_name IS NULL;

-- columns present in TEMP but not in MAIN
SELECT b.column_name
FROM all_tab_columns b
LEFT JOIN all_tab_columns a
  ON a.owner = b.owner
 AND a.column_name = b.column_name
  AND a.table_name = 'WD_JOBAPPLICATION'
WHERE b.owner = 'WFA_APP_USR_TALD'
  AND b.table_name = 'WD_JOBAPPLICATION_TEMP'
  AND a.column_name IS NULL;

-- columns present in both but with different datatypes/lengths
SELECT a.column_name,
       a.data_type  data_type_main,
       a.data_length data_len_main,
       b.data_type  data_type_temp,
       b.data_length data_len_temp
FROM all_tab_columns a
JOIN all_tab_columns b
  ON a.owner = b.owner AND a.column_name = b.column_name
WHERE a.owner = 'WFA_APP_USR_TALD'
  AND a.table_name = 'WD_JOBAPPLICATION'
  AND b.table_name = 'WD_JOBAPPLICATION_TEMP'
  AND (a.data_type <> b.data_type OR NVL(a.data_length,0) <> NVL(b.data_length,0));





-- rows in MAIN but NOT in TEMP
SELECT * FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION
MINUS
SELECT * FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP;

-- rows in TEMP but NOT in MAIN
SELECT * FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP
MINUS
SELECT * FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION;





SELECT COUNT(*) cnt FROM (
  SELECT * FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION
  MINUS
  SELECT * FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP
);

SELECT COUNT(*) cnt FROM (
  SELECT * FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP
  MINUS
  SELECT * FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION
);





















SELECT m.application_id,
       -- you can show columns from both sides to see differences
       m.col1 as m_col1, t.col1 as t_col1,
       m.col2 as m_col2, t.col2 as t_col2,
       -- add as many columns as needed
       CASE WHEN ( (m.col1 = t.col1 OR (m.col1 IS NULL AND t.col1 IS NULL))
                 AND (m.col2 = t.col2 OR (m.col2 IS NULL AND t.col2 IS NULL))
                 -- ... include all columns ...
                 )
            THEN 'ALL_MATCH'
            ELSE 'DIFF'
       END as row_cmp_flag
FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION m
JOIN WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP t
  ON m.application_id = t.application_id
WHERE NOT (
       (m.col1 = t.col1 OR (m.col1 IS NULL AND t.col1 IS NULL))
   AND (m.col2 = t.col2 OR (m.col2 IS NULL AND t.col2 IS NULL))
   -- AND ... repeat for every column you want to compare ...
);















-- produce rows of (pk, column_name, main_value, temp_value) where different
SELECT m.application_id as pk, 'COL1' as column_name, m.col1 as main_val, t.col1 as temp_val
FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION m
JOIN WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP t ON m.application_id = t.application_id
WHERE NOT (m.col1 = t.col1 OR (m.col1 IS NULL AND t.col1 IS NULL))

UNION ALL

SELECT m.application_id, 'COL2', m.col2, t.col2
FROM WFA_APP_USR_TALD.WD_JOBAPPLICATION m
JOIN WFA_APP_USR_TALD.WD_JOBAPPLICATION_TEMP t ON m.application_id = t.application_id
WHERE NOT (m.col2 = t.col2 OR (m.col2 IS NULL AND t.col2 IS NULL))

-- add one UNION ALL block per column
ORDER BY pk, column_name;





import pandas as pd
import numpy as np

# --------------------------------------------
# Weighted EMA and DEMA
# --------------------------------------------
def weighted_ema(values, alphas):
    ema = np.zeros_like(values, dtype=float)
    ema[0] = values[0]
    for t in range(1, len(values)):
        ema[t] = alphas[t] * values[t] + (1 - alphas[t]) * ema[t - 1]
    return ema

def weighted_dema(values, alphas):
    ema1 = weighted_ema(values, alphas)
    ema2 = weighted_ema(ema1, alphas)
    return 2 * ema1 - ema2


# ------------------------------------------------
# Step 1: Learn best alpha_base FOR EACH QUARTER
# ------------------------------------------------
def learn_quarter_alpha(df, value_col="VOLUNTARY_EXITS", hc_col="HEADCOUNT", date_col="MONTH"):
    df = df.copy()
    df[date_col] = pd.to_datetime(df[date_col])
    df = df.sort_values(date_col).reset_index(drop=True)
    df["Q"] = df[date_col].dt.quarter

    y = df[value_col].values.astype(float)
    hc = df[hc_col].values.astype(float)

    mean_hc = hc.mean()

    quarter_alpha = {}
    N_candidates = range(2, 10)  # means alpha_base = 2/(N+1)

    for q in [1,2,3,4]:
        # Extract rows only for this quarter (last 5 years ideally)
        idx = df[df["Q"] == q].index
        if len(idx) < 6:
            quarter_alpha[q] = 2/(5+1)  # default N=5
            continue

        best_err = 1e18
        best_alpha = None

        for N in N_candidates:
            alpha_base = 2/(N+1)

            # Compute alpha_t = alpha_base * (HC_t / mean(HC))
            alphas = alpha_base * (hc / mean_hc)
            alphas = np.clip(alphas, 0.02, 0.9)

            dema_vals = weighted_dema(y, alphas)

            # CV error only on months belonging to quarter q
            err = np.mean(np.abs(y[idx] - dema_vals[idx]))

            if err < best_err:
                best_err = err
                best_alpha = alpha_base

        quarter_alpha[q] = best_alpha

    return quarter_alpha


# --------------------------------------------------------
# Step 2: Forecast future months using quarter-specific 
# --------------------------------------------------------
def forecast_quarterwise(df, quarter_alpha_map, N_forecast=6):
    df = df.copy()
    df["MONTH"] = pd.to_datetime(df["MONTH"])
    df = df.sort_values("MONTH").reset_index(drop=True)

    y = df["VOLUNTARY_EXITS"].values.astype(float)
    hc = df["HEADCOUNT"].values.astype(float)
    mean_hc = hc.mean()

    last_date = df["MONTH"].iloc[-1]
    last_DEMA = None

    forecasts = []

    # Compute DEMA up to today for reference
    alphas_hist = np.zeros_like(y)
    for i in range(len(y)):
        q = df["MONTH"].dt.quarter.iloc[i]
        alpha_base = quarter_alpha_map[q]
        alphas_hist[i] = np.clip(alpha_base * (hc[i] / mean_hc), 0.02, 0.9)

    dema_hist = weighted_dema(y, alphas_hist)
    last_DEMA = dema_hist[-1]

    # Begin forecasting future months
    for k in range(1, N_forecast+1):
        future_month = last_date + pd.DateOffset(months=k)
        q = future_month.quarter

        # Use quarter-specific alpha_base (but DEMA forecast is flat)
        alpha_base = quarter_alpha_map[q]
        alpha_future = np.clip(alpha_base * (hc[-1] / mean_hc), 0.02, 0.9)

        # PURE DEMA LOGIC = flat forecast
        yhat = last_DEMA

        forecasts.append({
            "Forecast_Month": future_month,
            "Quarter": q,
            "Alpha_Base_Used": alpha_base,
            "Alpha_Final": alpha_future,
            "Forecast_Value": yhat
        })

    return pd.DataFrame(forecasts)




df = pd.read_excel("Projections Analysis Oct 2025.xlsx")

quarter_alpha = learn_quarter_alpha(df)
print("Quarter-wise learned alpha:", quarter_alpha)

forecast_df = forecast_quarterwise(df, quarter_alpha, N_forecast=12)
print(forecast_df)





















import numpy as np
import pandas as pd
from sklearn.metrics import mean_absolute_error

# -----------------------------
# Weighted alpha helper
# -----------------------------
def compute_weighted_alpha_from_base(headcount_array, alpha_base, alpha_min=0.02, alpha_max=0.9, power=1.0):
    hc = np.array(headcount_array, dtype=float)
    # protect zero mean
    mean_hc = hc.mean() if hc.mean() != 0 else 1.0
    hc_norm = (hc / mean_hc) ** power
    alphas = alpha_base * hc_norm
    return np.clip(alphas, alpha_min, alpha_max)

# -----------------------------
# EMA & DEMA (weighted alphas)
# -----------------------------
def weighted_ema(values, alphas):
    ema = np.zeros_like(values, dtype=float)
    ema[0] = values[0]
    for t in range(1, len(values)):
        a = alphas[t]
        ema[t] = a * values[t] + (1 - a) * ema[t-1]
    return ema

def weighted_dema(values, alphas):
    e1 = weighted_ema(values, alphas)
    e2 = weighted_ema(e1, alphas)
    return 2 * e1 - e2

# -----------------------------
# Quarter-wise alpha search
# -----------------------------
def find_best_alpha_per_quarter(df,
                                value_col='VOLUNTARY_EXITS',
                                hc_col='HEADCOUNT',
                                date_col='MONTH',
                                candidate_Ns=None,
                                alpha_min=0.02,
                                alpha_max=0.9,
                                power=1.0,
                                min_train_periods=24):
    """
    For each quarter (1..4), run expanding-window CV only on months that belong to that quarter
    and select the best alpha_base (mapped from N -> alpha_base = 2/(N+1)).
    Returns dict: quarter -> {best_N, best_alpha_base, error_by_N}
    """
    if candidate_Ns is None:
        candidate_Ns = list(range(2, 13))   # map to alpha_base = 2/(N+1) for N=2..12

    df = df.copy()
    df[date_col] = pd.to_datetime(df[date_col])
    df = df.sort_values(date_col).reset_index(drop=True)
    df['quarter'] = df[date_col].dt.quarter

    y = df[value_col].values.astype(float)
    hc = df[hc_col].values.astype(float)
    months = df[date_col]

    results = {}

    n = len(df)
    # We'll perform an expanding-window CV; for each test index t where t >= min_train_periods and we evaluate forecasting t
    test_indices = list(range(min_train_periods, n))

    for q in [1,2,3,4]:
        errors_by_candidate = {}
        # find all test indices that correspond to quarter q
        test_idx_q = [t for t in test_indices if months.iloc[t].quarter == q]
        if len(test_idx_q) == 0:
            # Not enough history for this quarter
            results[q] = {'best_N': None, 'best_alpha_base': None, 'errors': {}}
            continue

        for N in candidate_Ns:
            alpha_base = 2.0 / (N + 1.0)  # classic mapping
            errs = []
            for t in test_idx_q:
                # train on 0..t-1, predict t using flat DEMA forecast (last dema)
                train_slice = slice(0, t)
                y_train = y[train_slice]
                hc_train = hc[train_slice]

                # need at least 2 points for DEMA
                if len(y_train) < 3:
                    continue

                alphas_train = compute_weighted_alpha_from_base(hc_train, alpha_base,
                                                                alpha_min=alpha_min, alpha_max=alpha_max,
                                                                power=power)
                dema_train = weighted_dema(y_train, alphas_train)
                # forecast for t (flat DEMA forecast) = last dema value
                yhat = dema_train[-1]
                errs.append(abs(y[t] - yhat))

            if len(errs) == 0:
                # no folds for this candidate (rare)
                mean_err = np.nan
            else:
                mean_err = float(np.mean(errs))
            errors_by_candidate[N] = mean_err

        # pick best N (min error), ignore NaNs
        valid = {N: e for N, e in errors_by_candidate.items() if not np.isnan(e)}
        if len(valid) == 0:
            results[q] = {'best_N': None, 'best_alpha_base': None, 'errors': errors_by_candidate}
            continue

        best_N = min(valid.keys(), key=lambda k: valid[k])
        best_alpha = 2.0 / (best_N + 1.0)
        results[q] = {'best_N': best_N, 'best_alpha_base': best_alpha, 'errors': errors_by_candidate}

    return results

# -----------------------------
# Forecast using quarter-wise alpha_base
# -----------------------------
def forecast_with_quarter_alphas(df, quarter_alpha_map, N_forecast=3,
                                 alpha_min=0.02, alpha_max=0.9, power=1.0,
                                 trend_extension=False):
    """
    quarter_alpha_map: dict mapping quarter -> alpha_base (float)
    N_forecast: number of months to forecast out
    trend_extension: if True, use DEMA trend extension F_{t+k} = L + k*T (where T = last - prev)
    """
    df = df.copy()
    df['MONTH'] = pd.to_datetime(df['MONTH'])
    df = df.sort_values('MONTH').reset_index(drop=True)

    y = df['VOLUNTARY_EXITS'].values.astype(float)
    hc = df['HEADCOUNT'].values.astype(float)
    last_date = df['MONTH'].iloc[-1]

    # Build alphas for historical data using quarter-specific alpha_base
    quarters = df['MONTH'].dt.quarter.values
    alphas_hist = np.zeros_like(y, dtype=float)
    for i, q in enumerate(quarters):
        alpha_base = quarter_alpha_map.get(q, None)
        if alpha_base is None:
            # fall back to a reasonable default
            alpha_base = 2.0 / (5 + 1.0)  # equivalent to N=5
        # per-period alpha uses the historical HC array mean for stability
        # We'll compute normalization using whole-historical headcount mean
        # (this mirrors compute_weighted_alpha_from_base behavior)
        # compute per-row alpha after loop once mean is known
        alphas_hist[i] = alpha_base  # placeholder; we'll normalize below

    # Now compute normalized alpha using the same headcount normalization as function
    mean_hc = hc.mean() if hc.mean() != 0 else 1.0
    # compute per-row alpha = alpha_base * (hc/mean_hc)**power clipped
    for i in range(len(y)):
        base = alphas_hist[i]
        a = base * (hc[i] / mean_hc) ** power
        a = max(alpha_min, min(alpha_max, a))
        alphas_hist[i] = a

    # Compute W-DEMA on historical data
    dema_hist = weighted_dema(y, alphas_hist)

    # Forecast months one-by-one using quarter-wise alpha_base (for the future months we need to decide alpha per future month)
    forecasts = []
    forecast_months = []
    L = dema_hist[-1]
    T = dema_hist[-1] - dema_hist[-2] if len(dema_hist) >= 2 else 0.0

    # For future months we need a headcount input  we will use last known headcount as proxy,
    # or you can pass a headcount_forecast list to this function (extension).
    last_hc = hc[-1]
    for k in range(1, N_forecast + 1):
        f_month = last_date + pd.DateOffset(months=k)
        q = f_month.quarter
        alpha_base = quarter_alpha_map.get(q, 2.0 / (5 + 1.0))

        # compute alpha for the forecast period using last_hc (proxy)
        a_future = alpha_base * (last_hc / mean_hc) ** power
        a_future = max(alpha_min, min(alpha_max, a_future))

        if trend_extension:
            yhat = L + k * T
        else:
            # flat DEMA forecast (classic) -- though alpha is computed for future month, DEMA flat forecast equals last dema
            yhat = L

        # Optionally, you could apply a small adjustment if you want the alpha to affect multi-step forecast;
        # but classic DEMA-flat forecast is yhat = L. We'll keep that but return the alpha used for info.
        forecasts.append({'month': f_month, 'forecast': yhat, 'alpha_used': a_future, 'quarter': q})
        forecast_months.append(f_month)

    return pd.DataFrame(forecasts)


# -----------------------------
# Example usage
# -----------------------------
if __name__ == "__main__":
    # load your data
    df = pd.read_excel("Projections Analysis Oct 2025.xlsx")   # must have MONTH, HEADCOUNT, VOLUNTARY_EXITS

    # find best alpha per quarter
    res = find_best_alpha_per_quarter(df, candidate_Ns=range(2,13), alpha_min=0.02, alpha_max=0.9, power=1.0,
                                      min_train_periods=24)
    print("Quarter-wise alpha search results:")
    for q, info in res.items():
        print(q, info)

    # build a quarter -> alpha_base map from results (fallback to N=5 if missing)
    quarter_alpha_map = {}
    for q, info in res.items():
        if info['best_N'] is None:
            quarter_alpha_map[q] = 2.0 / (5 + 1.0)
        else:
            quarter_alpha_map[q] = info['best_alpha_base']

    # Forecast using quarter-wise alphas
    forecast_df = forecast_with_quarter_alphas(df, quarter_alpha_map, N_forecast=6, trend_extension=True)
    print("\nForecasts:")
    print(forecast_df)























import pandas as pd
import numpy as np

# ==========================================
#   CORE: EMA + DEMA
# ==========================================

def ema(values, alphas):
    ema_vals = np.zeros_like(values, dtype=float)
    ema_vals[0] = values[0]
    for t in range(1, len(values)):
        ema_vals[t] = alphas[t] * values[t] + (1 - alphas[t]) * ema_vals[t - 1]
    return ema_vals


def dema(values, alphas):
    ema1 = ema(values, alphas)
    ema2 = ema(ema1, alphas)
    return 2 * ema1 - ema2


# ==========================================
#   A. FIXED ALPHA DEMA
# ==========================================

def fixed_alpha_dema(values, alpha=0.5):
    alphas = np.full(len(values), alpha)
    return dema(values, alphas)


# ==========================================
#   B. WEIGHTED DEMA (HEADCOUNT)
# ==========================================

def weighted_alpha(headcount, alpha_base=0.3, alpha_min=0.05, alpha_max=0.8, power=1.0):
    hc = np.array(headcount, dtype=float)
    hc_norm = (hc / hc.mean()) ** power
    alphas = alpha_base * hc_norm
    return np.clip(alphas, alpha_min, alpha_max)


def weighted_dema(values, headcount, alpha_base=0.3, alpha_min=0.05, alpha_max=0.8, power=1.0):
    alphas = weighted_alpha(headcount, alpha_base, alpha_min, alpha_max, power)
    return dema(values, alphas)


# ==========================================
#   C. STRICT 3-PERIOD DEMA
# ==========================================
#  = 2 / (3 + 1) = 0.5

def dema_3period(values):
    alphas = np.full(len(values), 0.5)
    return dema(values, alphas)


# ==========================================
#   D. TREND-BASED FORECASTING
# ==========================================

def dema_forecast_trend(dema_series, N):
    L = dema_series[-1]          # Last level
    T = dema_series[-1] - dema_series[-2]   # Trend from last two values
    return np.array([L + k * T for k in range(1, N + 1)])


# ==========================================
#   E. SEASONALITY-ADJUSTED DEMA
# ==========================================

def compute_monthly_seasonality(df, actual_col, dema_col):
    df = df.copy()
    df["month"] = df["MONTH"].dt.month
    df["ratio"] = df[actual_col] / df[dema_col]

    season = df.groupby("month")["ratio"].mean().to_dict()

    # normalize to avoid level drifting
    avg = np.mean(list(season.values()))
    season = {m: v / avg for m, v in season.items()}
    return season


def dema_forecast_seasonal(dema_series, seasonality, last_date, N):
    forecasts = []
    months = []
    L = dema_series[-1]

    for k in range(1, N+1):
        next_month = last_date + pd.DateOffset(months=k)
        m = next_month.month
        S = seasonality.get(m, 1.0)
        forecasts.append(L * S)
        months.append(next_month)

    return months, forecasts


# ==========================================
# ALL-IN-ONE FORECAST WRAPPER
# ==========================================

def forecast_dema(df, method="weighted", N=3):
    """
    method options:
        'fixed'
        'weighted'
        '3period'
        'fixed_trend'
        'weighted_trend'
        '3period_trend'
        'seasonal_weighted'
    """

    df = df.copy()
    df["MONTH"] = pd.to_datetime(df["MONTH"])
    df = df.sort_values("MONTH")

    y = df["VOLUNTARY_EXITS"].astype(float).values
    hc = df["HEADCOUNT"].astype(float).values

    # --------------- Choose DEMA Method ---------------
    if method == "fixed":
        d = fixed_alpha_dema(y, alpha=0.3)

    elif method == "weighted":
        d = weighted_dema(y, hc)

    elif method == "3period":
        d = dema_3period(y)

    elif method.endswith("_trend"):
        if method.startswith("fixed"):
            d = fixed_alpha_dema(y, alpha=0.3)
        elif method.startswith("weighted"):
            d = weighted_dema(y, hc)
        elif method.startswith("3period"):
            d = dema_3period(y)
        forecast = dema_forecast_trend(d, N)
        return forecast, d

    elif method == "seasonal_weighted":
        d = weighted_dema(y, hc)
        season = compute_monthly_seasonality(df, "VOLUNTARY_EXITS", "DEMA_TMP" if "DEMA_TMP" in df else "VOLUNTARY_EXITS")
        months, f = dema_forecast_seasonal(d, season, df["MONTH"].iloc[-1], N)
        return f, months, d

    else:
        raise ValueError("Invalid method selected.")

    # --------------- Simple Flat Forecast ---------------
    forecast = np.full(N, d[-1])
    return forecast, d


# ==========================================
#           EXAMPLE USAGE
# ==========================================

if __name__ == "__main__":
    df = pd.read_excel("Projections Analysis Oct 2025.xlsx")

    # Try multiple methods
    methods = [
        "3period",
        "fixed",
        "weighted",
        "fixed_trend",
        "weighted_trend",
        "3period_trend",
    ]

    for m in methods:
        print(f"\n=== METHOD: {m} ===")
        f, d = forecast_dema(df, method=m, N=6)
        print("Forecast next 6 months:", f)

















# ===========================
# Trend-based DEMA Forecast
# ===========================

N = 6   # number of future months you want

wdema_last = df['WDEMA'].iloc[-1]
wdema_prev = df['WDEMA'].iloc[-2]

# Trend = difference of last two WDEMA values
trend = wdema_last - wdema_prev

# Forecast k steps ahead: WDEMA_t + k * trend
future_forecasts = [wdema_last + k * trend for k in range(1, N + 1)]

print(f"\nNext {N} Months Forecast (Weighted DEMA with Trend):")
for i, f in enumerate(future_forecasts, start=1):
    print(f"Month +{i}: {f}")








import pandas as pd
import numpy as np

def compute_weighted_alpha(headcount_series, alpha_base=0.3, alpha_min=0.05, alpha_max=0.8):
    hc = headcount_series.values.astype(float)
    hc_norm = hc / hc.mean()
    alphas = alpha_base * hc_norm
    return np.clip(alphas, alpha_min, alpha_max)

def weighted_ema(values, alphas):
    ema = np.zeros_like(values, dtype=float)
    ema[0] = values[0]
    for t in range(1, len(values)):
        ema[t] = alphas[t] * values[t] + (1 - alphas[t]) * ema[t - 1]
    return ema

def weighted_dema(values, alphas):
    ema1 = weighted_ema(values, alphas)
    ema2 = weighted_ema(ema1, alphas)
    return 2 * ema1 - ema2


# ============================
# Seasonal Index Computation
# ============================
def compute_monthly_seasonality(df, value_col, wdema_col):
    df['month_num'] = df['MONTH'].dt.month
    df['ratio'] = df[value_col] / df[wdema_col]

    # Seasonal index = avg(actual/WDEMA) per month
    seasonality = df.groupby('month_num')['ratio'].mean().to_dict()

    # Normalize to avoid drift
    mean_val = np.mean(list(seasonality.values()))
    seasonality = {m: v / mean_val for m, v in seasonality.items()}

    return seasonality


# ============================
# Forecast Next N Periods
# ============================
def forecast_wdema_next_n(df, N):
    df = df.copy()
    df['MONTH'] = pd.to_datetime(df['MONTH'])
    df = df.sort_values("MONTH")

    y = df['VOLUNTARY_EXITS'].values.astype(float)
    hc = df['HEADCOUNT']

    # Step 1  WDEMA
    alphas = compute_weighted_alpha(hc)
    wd = weighted_dema(y, alphas)
    df['WDEMA'] = wd

    # Step 2  Seasonal factors
    season = compute_monthly_seasonality(df, value_col='VOLUNTARY_EXITS', wdema_col='WDEMA')

    # Step 3  Trend
    L = wd[-1]
    T = wd[-1] - wd[-2]

    last_month = df['MONTH'].iloc[-1]

    forecasts = []
    months = []

    for k in range(1, N + 1):
        next_month = last_month + pd.DateOffset(months=k)
        m = next_month.month
        S = season.get(m, 1)

        # Final adjusted forecast
        f = (L + k * T) * S

        forecasts.append(f)
        months.append(next_month)

    result = pd.DataFrame({
        "Forecast_Month": months,
        "Forecast_Value": forecasts
    })

    return result, df


# ============================
# Example Usage
# ============================
df = pd.read_excel("Projections Analysis Oct 2025.xlsx")

forecast_df, full_df = forecast_wdema_next_n(df, N=6)

print(forecast_df)





















import pandas as pd
import numpy as np

# ===========================
# Weighted DEMA Implementation
# ===========================

def compute_weighted_alpha(headcount_series, alpha_base=0.3, alpha_min=0.05, alpha_max=0.8):
    hc = headcount_series.values.astype(float)
    hc_norm = hc / hc.mean()

    alphas = alpha_base * hc_norm
    alphas = np.clip(alphas, alpha_min, alpha_max)

    return alphas


def weighted_ema(values, alphas):
    ema = np.zeros_like(values, dtype=float)
    ema[0] = values[0]
    for t in range(1, len(values)):
        ema[t] = alphas[t] * values[t] + (1 - alphas[t]) * ema[t - 1]
    return ema


def weighted_dema(values, alphas):
    ema1 = weighted_ema(values, alphas)
    ema2 = weighted_ema(ema1, alphas)
    return 2 * ema1 - ema2


# ===========================
# Dynamic Forecast Function
# ===========================
def forecast_wdema_next_n(df, N):
    """
    df must contain columns: MONTH, HEADCOUNT, VOLUNTARY_EXITS
    Returns array of N-step ahead forecasts using WDEMA level + trend.
    """
    
    # Sort dataset
    df = df.copy()
    df['MONTH'] = pd.to_datetime(df['MONTH'])
    df = df.sort_values('MONTH').reset_index(drop=True)

    y = df['VOLUNTARY_EXITS'].values.astype(float)
    hc = df['HEADCOUNT']

    # Compute alphas and WDEMA
    alphas = compute_weighted_alpha(hc, alpha_base=0.3)
    wd = weighted_dema(y, alphas)

    # Last level
    L = wd[-1]

    # Trend estimated from last 2 values
    T = wd[-1] - wd[-2]

    # Dynamic next N predictions
    forecasts = np.array([L + k * T for k in range(1, N + 1)], dtype=float)

    return forecasts, wd


# ===========================
# Example Usage
# ===========================
if __name__ == "__main__":
    df = pd.read_excel("Projections Analysis Oct 2025.xlsx")

    N = 3   # you can change to any value: 1, 3, 6, 12

    next_forecasts, wdema_series = forecast_wdema_next_n(df, N)

    print(f"\nNext {N} Month Forecast:")
    for i, val in enumerate(next_forecasts, 1):
        print(f"Month +{i}: {val}")

    # optional: append to dataframe
    df['WDEMA'] = wdema_series
    print("\nWeighted DEMA (last few months):")
    print(df[['MONTH', 'VOLUNTARY_EXITS', 'HEADCOUNT', 'WDEMA']].tail())






























import pandas as pd
import numpy as np

# ===========================
# Weighted DEMA Implementation
# ===========================

def compute_weighted_alpha(headcount_series, alpha_base=0.3, alpha_min=0.05, alpha_max=0.8):
    hc = headcount_series.values.astype(float)
    hc_norm = hc / hc.mean()

    alphas = alpha_base * hc_norm
    alphas = np.clip(alphas, alpha_min, alpha_max)

    return alphas


def weighted_ema(values, alphas):
    ema = np.zeros_like(values, dtype=float)
    ema[0] = values[0]
    for t in range(1, len(values)):
        ema[t] = alphas[t] * values[t] + (1 - alphas[t]) * ema[t - 1]
    return ema


def weighted_dema(values, alphas):
    ema1 = weighted_ema(values, alphas)
    ema2 = weighted_ema(ema1, alphas)
    dema = 2 * ema1 - ema2
    return dema


# ================================
# Load and process your dataset
# ================================
# Your columns from screenshot:
# MONTH (YYYY-MM), HEADCOUNT, VOLUNTARY_EXITS, MONTHLY_ATTRITION_RATE

df = pd.read_excel("Projections Analysis Oct 2025.xlsx")

# Sort by month (required)
df['MONTH'] = pd.to_datetime(df['MONTH'])
df = df.sort_values('MONTH').reset_index(drop=True)

# Target series = VOLUNTARY_EXITS (counts)
y = df['VOLUNTARY_EXITS'].values.astype(float)

# Compute time-varying alphas via headcount weights
alphas = compute_weighted_alpha(df['HEADCOUNT'], alpha_base=0.3)

# Compute Weighted DEMA
df['WDEMA'] = weighted_dema(y, alphas)

print(df[['MONTH', 'VOLUNTARY_EXITS', 'HEADCOUNT', 'WDEMA']].tail(12))

# Next N months forecast (simple method = last WDEMA as forward projection)
next_month_forecast = df['WDEMA'].iloc[-1]
print("\nNext Month Forecast (Weighted DEMA):", next_month_forecast)




# Compute simple trend on last 12 months of WDEMA
last_12 = df['WDEMA'].tail(12).reset_index(drop=True)

x = np.arange(len(last_12))
coef = np.polyfit(x, last_12, 1)  # linear trend
slope = coef[0]
intercept = coef[1]

# Forecast next 3 months with trend
forecast_1 = intercept + slope * (len(last_12))
forecast_2 = intercept + slope * (len(last_12) + 1)
forecast_3 = intercept + slope * (len(last_12) + 2)

print("Next 3-month Forecast with Trend:")
print("Month +1:", forecast_1)
print("Month +2:", forecast_2)
print("Month +3:", forecast_3)



# True DEMA-based trend extension
# L_t is last WDEMA
L_t = df['WDEMA'].iloc[-1]

# Trend estimate = difference between last two WDEMA values
T_t = df['WDEMA'].iloc[-1] - df['WDEMA'].iloc[-2]

# Forecast k steps ahead
forecast_1 = L_t + 1 * T_t
forecast_2 = L_t + 2 * T_t
forecast_3 = L_t + 3 * T_t

print("Next 3-month Forecast (DEMA level + trend):")
print("Month +1:", forecast_1)
print("Month +2:", forecast_2)
print("Month +3:", forecast_3)


















import pandas as pd
from statsmodels.tsa.holtwinters import ExponentialSmoothing

# ============================
# STEP 1  Load Dataset
# ============================
# If reading from Excel:
# df = pd.read_excel("Projections Analysis Oct 2025.xlsx")

# For now using a dummy sample matching your screenshot:
data = {
    "MONTH": [
        "2020-12", "2021-01", "2021-02", "2021-03", "2021-04", "2021-05", "2021-06",
        "2021-07", "2021-08", "2021-09", "2021-10", "2021-11", "2021-12",
        "2022-01", "2022-02", "2022-03", "2022-04", "2022-05", "2022-06"
    ],
    "HEADCOUNT": [
        210007, 210404, 210198, 210660, 211687, 213377, 217431, 218203, 217892,
        218454, 221995, 222818, 223387, 225766, 226836, 228888, 229702, 230604,
        231349
    ],
    "MONTHLY_ATTRITION_RATE": [
        0.760927017,0.5755594,0.746430972,0.8570696,0.989196331,
        0.984202127,1.118049431,1.182780847,1.272007782,
        1.198398526,0.98745097,0.967157052,1.0666857,
        0.839807588,0.993225882,1.2254488,1.170898393,
        1.237158825,1.269078319
    ]
}

df = pd.DataFrame(data)
df["MONTH"] = pd.to_datetime(df["MONTH"])
df = df.set_index("MONTH")

# ============================
# STEP 2  Choose series for Holt-Winters
# ============================
ts = df["MONTHLY_ATTRITION_RATE"]

# ============================
# STEP 3  Build Holt-Winters Model
# ============================
# Monthly data  seasonal_periods = 12
model = ExponentialSmoothing(
    ts,
    trend="add",
    seasonal="add",
    seasonal_periods=12
)

fit_model = model.fit(optimized=True)

print("Model summary:")
print(fit_model.summary())

# ============================
# STEP 4  Forecast N months
# ============================
N = 6  # forecast next 6 months
forecast_attrition = fit_model.forecast(N)

# ============================
# STEP 5  Convert Attrition  Voluntary Exits
# ============================
# Define dynamic base headcount
BASE_HEADCOUNT = 232000    # You can change dynamically

forecast_vol_exits = forecast_attrition * BASE_HEADCOUNT

# ============================
# STEP 6  Prepare final output table
# ============================
future_dates = pd.date_range(df.index[-1] + pd.offsets.MonthBegin(),
                             periods=N, freq="MS")

forecast_df = pd.DataFrame({
    "FORECAST_MONTH": future_dates,
    "FORECAST_ATTRITION_RATE": forecast_attrition.values,
    "BASE_HEADCOUNT_USED": BASE_HEADCOUNT,
    "FORECAST_VOLUNTARY_EXITS": forecast_vol_exits.round(0).astype(int)
})

print("\n=== FINAL FORECAST OUTPUT ===")
print(forecast_df)





















import pandas as pd
from difflib import get_close_matches

# === Step 1. Read all sheets ===
file_path = "TopDataDict_WFA_APP_USR_TALD_test.xlsx"
xls = pd.ExcelFile(file_path)

# The first sheet is the main sheet
main_sheet_name = xls.sheet_names[0]
main_df = pd.read_excel(xls, main_sheet_name)

# === Step 2. Find tables assigned to 'Mayur' ===
mayur_tables = main_df.loc[main_df['Assigned to'] == 'Mayur', 'L4_TABLE_LIST'].dropna().tolist()
print("Tables assigned to Mayur:", mayur_tables)

# === Step 3. Build a global COLUMN_NAME  DESCRIPTION mapping ===
global_desc_map = {}

for sheet in xls.sheet_names[1:]:  # skip main sheet
    df = pd.read_excel(xls, sheet)
    if {'COLUMN_NAME', 'DESCRIPTION'}.issubset(df.columns):
        for _, row in df[['COLUMN_NAME', 'DESCRIPTION']].dropna().iterrows():
            col_name = str(row['COLUMN_NAME']).strip()
            desc = str(row['DESCRIPTION']).strip()
            if col_name and desc:
                global_desc_map.setdefault(col_name, desc)

print(f"Total unique columns found for mapping: {len(global_desc_map)}")

# === Step 4. Update missing descriptions + create AI-suggested column ===
updated_tables = {}

for table_name in mayur_tables:
    if table_name in xls.sheet_names:
        df = pd.read_excel(xls, table_name)

        if {'COLUMN_NAME', 'DESCRIPTION'}.issubset(df.columns):

            # Fill missing descriptions from global map
            df['DESCRIPTION'] = df.apply(
                lambda row: global_desc_map.get(str(row['COLUMN_NAME']).strip(), row['DESCRIPTION'])
                if pd.isna(row['DESCRIPTION']) or row['DESCRIPTION'] in [None, '', 'nan']
                else row['DESCRIPTION'],
                axis=1
            )

            # === Step 4a. Add AI-suggested descriptions for remaining missing ===
            suggested_descriptions = []
            all_known_columns = list(global_desc_map.keys())

            for _, row in df.iterrows():
                col = str(row['COLUMN_NAME']).strip()
                desc = str(row['DESCRIPTION']).strip() if not pd.isna(row['DESCRIPTION']) else ''
                
                if desc:  # Already has a description
                    suggested_descriptions.append('')
                else:
                    # Find similar column names
                    matches = get_close_matches(col, all_known_columns, n=1, cutoff=0.7)
                    if matches:
                        matched_col = matches[0]
                        suggested_desc = global_desc_map[matched_col]
                        suggested_descriptions.append(f"{suggested_desc} (suggested from {matched_col})")
                    else:
                        suggested_descriptions.append('')

            df['AI_SUGGESTED_DESCRIPTION'] = suggested_descriptions

            updated_tables[table_name] = df
            print(f" Updated {table_name} with filled and suggested descriptions.")

        else:
            print(f" Skipping {table_name}  required columns not found.")
    else:
        print(f" Sheet {table_name} not found in workbook.")

# === Step 5. Save only Mayurs updated tables ===
output_file = "Mayur_Tables_Updated_AI_Suggested.xlsx"
with pd.ExcelWriter(output_file, engine='xlsxwriter') as writer:
    for table_name, df in updated_tables.items():
        df.to_excel(writer, sheet_name=table_name, index=False)

print(f"\n Done! Output file created: {output_file}")




























import pandas as pd

# === Step 1. Read all sheets ===
file_path = "TopDataDict_WFA_APP_USR_TALD_test.xlsx"
xls = pd.ExcelFile(file_path)

# The first sheet is the main sheet
main_sheet_name = xls.sheet_names[0]
main_df = pd.read_excel(xls, main_sheet_name)

# === Step 2. Find tables assigned to 'Mayur' ===
mayur_tables = main_df.loc[main_df['Assigned to'] == 'Mayur', 'L4_TABLE_LIST'].dropna().tolist()
print("Tables assigned to Mayur:", mayur_tables)

# === Step 3. Build a global COLUMN_NAME  DESCRIPTION mapping from all other sheets ===
global_desc_map = {}

for sheet in xls.sheet_names[1:]:  # skip main sheet
    df = pd.read_excel(xls, sheet)
    # ensure relevant columns exist
    if {'COLUMN_NAME', 'DESCRIPTION'}.issubset(df.columns):
        for _, row in df[['COLUMN_NAME', 'DESCRIPTION']].dropna().iterrows():
            col_name = str(row['COLUMN_NAME']).strip()
            desc = str(row['DESCRIPTION']).strip()
            if col_name and desc:
                # Prefer first non-empty description encountered
                global_desc_map.setdefault(col_name, desc)

print(f"Total unique columns found for mapping: {len(global_desc_map)}")

# === Step 4. Update missing descriptions in Mayurs tables ===
updated_tables = {}

for table_name in mayur_tables:
    if table_name in xls.sheet_names:
        df = pd.read_excel(xls, table_name)

        if {'COLUMN_NAME', 'DESCRIPTION'}.issubset(df.columns):
            df['DESCRIPTION'] = df.apply(
                lambda row: global_desc_map.get(str(row['COLUMN_NAME']).strip(), row['DESCRIPTION'])
                if pd.isna(row['DESCRIPTION']) or row['DESCRIPTION'] in [None, '', 'nan']
                else row['DESCRIPTION'],
                axis=1
            )

            updated_tables[table_name] = df
            print(f" Updated {table_name} with descriptions from global map.")
        else:
            print(f" Skipping {table_name}  required columns not found.")
    else:
        print(f" Sheet {table_name} not found in workbook.")

# === Step 5. Create new Excel with only Mayurs updated tables ===
output_file = "Mayur_Tables_Updated.xlsx"
with pd.ExcelWriter(output_file, engine='xlsxwriter') as writer:
    for table_name, df in updated_tables.items():
        df.to_excel(writer, sheet_name=table_name, index=False)

print(f"\n Done! Output file created: {output_file}")


























# -----------------------
# PARAMETERS
# -----------------------
HC_REFERENCE_MONTH = "2024-12"  # <-- You can change this month as per your reference
# -----------------------

# Convert to datetime for comparison
hc_ref_dt = pd.to_datetime(HC_REFERENCE_MONTH + "-01")

# last known headcount from specific reference month (fallbacks handled)
pre_forecast_hc_series = grp[grp.index == hc_ref_dt]['HEADCOUNT']

if not pre_forecast_hc_series.empty:
    # Use HC from the reference month directly
    last_known_hc = pre_forecast_hc_series.iloc[-1]
else:
    # Fallback to last available before forecast start
    pre_forecast_hc_series = grp[grp.index < pd.to_datetime(FORECAST_START)]['HEADCOUNT']
    if not pre_forecast_hc_series.empty:
        last_known_hc = pre_forecast_hc_series.iloc[-1]
    else:
        # Final fallback to latest known in dataset
        last_known_hc = grp['HEADCOUNT'].iloc[-1] if (not grp['HEADCOUNT'].empty) else BASE_MONTH_HC


















import pandas as pd
import numpy as np

# Step 1: Replace None with NaN for consistency
df1 = df1.replace({None: np.nan})
df2 = df2.replace({None: np.nan})

# Step 2: Sort by all columns (so identical rows align)
df1_sorted = df1.sort_values(by=list(df1.columns)).reset_index(drop=True)
df2_sorted = df2.sort_values(by=list(df2.columns)).reset_index(drop=True)

# Step 3: Ensure same columns and shape
assert list(df1_sorted.columns) == list(df2_sorted.columns), " Column names differ!"
assert df1_sorted.shape == df2_sorted.shape, " Row counts differ!"

# Step 4: Normalize values  handle numeric equivalence (-64.0 == -64)
def normalize_value(v):
    if pd.isna(v):
        return np.nan
    # Convert strings that look numeric
    if isinstance(v, str):
        try:
            return float(v)
        except ValueError:
            return v.strip()
    # Convert ints to float for fair comparison
    if isinstance(v, (int, np.integer)):
        return float(v)
    return v

df1_sorted = df1_sorted.applymap(normalize_value)
df2_sorted = df2_sorted.applymap(normalize_value)

# Step 5: Compare DataFrames row by row
mismatch_records = []

for i in range(len(df1_sorted)):
    row1 = df1_sorted.iloc[i]
    row2 = df2_sorted.iloc[i]
    
    # Create a pseudo-row identifier (like hash of all values)
    row_identifier = f"ROW_{i+1}"
    
    for col in df1_sorted.columns:
        val1, val2 = row1[col], row2[col]
        
        # Skip if both NaN
        if pd.isna(val1) and pd.isna(val2):
            continue
        
        # Compare numeric types safely
        if isinstance(val1, (int, float)) and isinstance(val2, (int, float)):
            if not np.isclose(val1, val2, equal_nan=True):
                mismatch_records.append({'Row': row_identifier, 'Column': col, 'df1_Value': val1, 'df2_Value': val2})
        else:
            if val1 != val2:
                mismatch_records.append({'Row': row_identifier, 'Column': col, 'df1_Value': val1, 'df2_Value': val2})

# Step 6: Create final mismatch DataFrame
mismatch_df = pd.DataFrame(mismatch_records)

if mismatch_df.empty:
    print(" All rows and columns match perfectly!")
else:
    print(f" Found {len(mismatch_df)} mismatches:")
    display(mismatch_df)












df1_sorted['ROW_HASH'] = df1_sorted.astype(str).agg('|'.join, axis=1)
df2_sorted['ROW_HASH'] = df2_sorted.astype(str).agg('|'.join, axis=1)

common = set(df1_sorted['ROW_HASH']).intersection(set(df2_sorted['ROW_HASH']))
print(f" {len(common)} rows are exactly matching by all column values.")





















import pandas as pd
import numpy as np

# Step 1: Sort both DataFrames by SOEID
df1_sorted = df1.sort_values(by='SOEID').reset_index(drop=True)
df2_sorted = df2.sort_values(by='SOEID').reset_index(drop=True)

# Step 2: Replace None with NaN for consistency
df1_sorted = df1_sorted.replace({None: np.nan})
df2_sorted = df2_sorted.replace({None: np.nan})

# Step 3: Ensure both DataFrames have same columns
assert list(df1_sorted.columns) == list(df2_sorted.columns), " Column names differ!"
assert df1_sorted.shape == df2_sorted.shape, " Shapes differ!"

# Step 4: Normalize numeric types (so -64 and -64.0 are treated same)
def normalize_value(v):
    if pd.isna(v):
        return np.nan
    # Try converting numeric-like strings to float
    if isinstance(v, str) and v.replace('.', '', 1).replace('-', '', 1).isdigit():
        try:
            return float(v)
        except:
            return v
    # Convert ints to float (so types match)
    if isinstance(v, (int, np.integer)):
        return float(v)
    return v

df1_sorted = df1_sorted.applymap(normalize_value)
df2_sorted = df2_sorted.applymap(normalize_value)

# Step 5: Compare and collect mismatches
mismatch_records = []

for i in range(len(df1_sorted)):
    soe_id = df1_sorted.iloc[i]['SOEID']
    row1 = df1_sorted.iloc[i]
    row2 = df2_sorted.iloc[i]
    
    for col in df1_sorted.columns:
        val1, val2 = row1[col], row2[col]
        
        # Skip if both NaN
        if pd.isna(val1) and pd.isna(val2):
            continue
        
        # Numeric comparison tolerance (so -64.0 == -64)
        if isinstance(val1, (int, float)) and isinstance(val2, (int, float)):
            if not np.isclose(val1, val2, equal_nan=True):
                mismatch_records.append({'SOEID': soe_id, 'Column': col, 'df1_Value': val1, 'df2_Value': val2})
        else:
            if val1 != val2:
                mismatch_records.append({'SOEID': soe_id, 'Column': col, 'df1_Value': val1, 'df2_Value': val2})

# Step 6: Create final mismatch dataframe
mismatch_df = pd.DataFrame(mismatch_records)

if mismatch_df.empty:
    print(" All rows and columns match perfectly!")
else:
    print(f" Found {len(mismatch_df)} mismatches:")
    display(mismatch_df)

























import pandas as pd
import numpy as np

# Step 1: Sort both DataFrames by SOEID
df1_sorted = df1.sort_values(by='SOEID').reset_index(drop=True)
df2_sorted = df2.sort_values(by='SOEID').reset_index(drop=True)

# Step 2: Ensure NaN consistency (treat None as NaN)
df1_sorted = df1_sorted.replace({None: np.nan})
df2_sorted = df2_sorted.replace({None: np.nan})

# Step 3: Ensure both DataFrames have same columns and shape
assert list(df1_sorted.columns) == list(df2_sorted.columns), " Column names differ!"
assert df1_sorted.shape == df2_sorted.shape, " Shapes differ!"

# Step 4: Identify mismatched cells
mismatch_records = []

for i in range(len(df1_sorted)):
    soe_id = df1_sorted.iloc[i]['SOEID']
    row1 = df1_sorted.iloc[i]
    row2 = df2_sorted.iloc[i]
    
    for col in df1_sorted.columns:
        val1, val2 = row1[col], row2[col]
        
        # Compare NaN safely
        if (pd.isna(val1) and pd.isna(val2)):
            continue
        elif val1 != val2:
            mismatch_records.append({
                'SOEID': soe_id,
                'Column': col,
                'df1_Value': val1,
                'df2_Value': val2
            })

# Step 5: Create DataFrame of mismatches
mismatch_df = pd.DataFrame(mismatch_records)

if mismatch_df.empty:
    print(" All rows and columns match perfectly!")
else:
    print(" Found mismatches:")
    display(mismatch_df)






















import pandas as pd
import numpy as np

# Step 1: Sort both dataframes by SOE_ID
df1_sorted = df1.sort_values(by="SOE_ID").reset_index(drop=True)
df2_sorted = df2.sort_values(by="SOE_ID").reset_index(drop=True)

# Step 2: Replace None with np.nan so both are comparable
df1_sorted = df1_sorted.replace({None: np.nan})
df2_sorted = df2_sorted.replace({None: np.nan})

# Step 3: Check if both dataframes are exactly equal
are_equal = df1_sorted.equals(df2_sorted)

print(f" DataFrames Match: {are_equal}")

# Step 4: If not equal, find mismatched rows and columns
if not are_equal:
    # Create a mask of where values differ
    mismatch_mask = (df1_sorted != df2_sorted) & ~(df1_sorted.isna() & df2_sorted.isna())
    
    # Get rows with at least one mismatch
    mismatched_rows = df1_sorted[mismatch_mask.any(axis=1)].copy()
    mismatched_rows['SOE_ID'] = df1_sorted.loc[mismatch_mask.any(axis=1), 'SOE_ID']
    
    # For clarity, also show which columns differ
    mismatched_columns = mismatch_mask.any()
    diff_columns = mismatch_mask.columns[mismatched_columns].tolist()
    
    print("\n Mismatched Columns:")
    print(diff_columns)
    
    print("\n Mismatched Rows with Differences:")
    display(pd.concat([
        df1_sorted[mismatch_mask.any(axis=1)].add_suffix('_DF1'),
        df2_sorted[mismatch_mask.any(axis=1)].add_suffix('_DF2')
    ], axis=1))















import pandas as pd
import numpy as np

# Ensure same shape, column order, and reset index
df1 = df1.reset_index(drop=True)
df2 = df2.reset_index(drop=True)
df1 = df1[df2.columns]

# Compare while treating NaN/None as equal
comparison = (df1.eq(df2)) | (df1.isna() & df2.isna())

# Find rows with any mismatched column
diff_rows = ~comparison.all(axis=1)

records = []

# Loop through mismatched rows
for idx in df1.index[diff_rows]:
    mismatched_cols = df1.columns[~comparison.loc[idx]].tolist()
    row_data = {
        "Row_Index": idx,
        "Mismatched_Columns": mismatched_cols
    }
    
    # Add mismatched column values side-by-side
    for col in mismatched_cols:
        row_data[f"df1_{col}"] = df1.at[idx, col]
        row_data[f"df2_{col}"] = df2.at[idx, col]
    
    records.append(row_data)

# Create the mismatch summary dataframe
mismatch_df = pd.DataFrame(records)

print(f" Total mismatched rows: {len(mismatch_df)}")
display(mismatch_df)





















import pandas as pd

# Ensure same column order and length
df1 = df1.reset_index(drop=True)
df2 = df2.reset_index(drop=True)
df1 = df1[df2.columns]

# Identify mismatched rows
comparison = df1 == df2
diff_rows = ~comparison.all(axis=1)

# Collect mismatched info
records = []

for idx in df1.index[diff_rows]:
    mismatched_cols = df1.columns[df1.loc[idx] != df2.loc[idx]].tolist()
    row_data = {
        "Row_Index": idx,
        "Mismatched_Columns": mismatched_cols
    }
    
    # Add df1 and df2 values for mismatched columns only
    for col in mismatched_cols:
        row_data[f"df1_{col}"] = df1.at[idx, col]
        row_data[f"df2_{col}"] = df2.at[idx, col]
    
    records.append(row_data)

# Create the summary dataframe
mismatch_df = pd.DataFrame(records)

print(f"Total mismatched rows: {len(mismatch_df)}")
display(mismatch_df)





















import pandas as pd
import numpy as np

# Ensure same column order
df1 = df1[df2.columns]

# Compare element-wise
comparison = df1 == df2

# Rows where any column differs
diff_rows = ~comparison.all(axis=1)

# Show rows that differ
diff_report = pd.concat(
    [df1[diff_rows].add_prefix('df1_'), df2[diff_rows].add_prefix('df2_')],
    axis=1
)

print("Total rows mismatched:", diff_rows.sum())
display(diff_report)





mismatch_details = {}

for idx in df1.index:
    mismatched_cols = df1.columns[df1.loc[idx] != df2.loc[idx]].tolist()
    if mismatched_cols:
        mismatch_details[idx] = mismatched_cols

print("Mismatched rows and columns:")
for i, cols in mismatch_details.items():
    print(f"Row {i}: columns {cols}")















import pandas as pd

key = 'POSITION_ID'

# --- Step 1: Filter only duplicates
dupes = df[df.duplicated(subset=[key], keep=False)].copy()

# --- Step 2: Group and find differences
records = []

for pid, group in dupes.groupby(key):
    group = group.reset_index(drop=True)
    diff_cols = [col for col in group.columns if col != key and group[col].nunique(dropna=False) > 1]

    if diff_cols:
        diff_data = {}
        diff_data[key] = pid
        diff_data['Columns_Not_Matching'] = ', '.join(diff_cols)

        # Collect differing values for each mismatched column
        for col in diff_cols:
            diff_data[f'{col}_Values'] = group[col].astype(str).unique().tolist()

        records.append(diff_data)

# --- Step 3: Create result DataFrame
mismatch_report = pd.DataFrame(records)

print("\n Duplicate IDs with non-matching column values:")
print(mismatch_report)



















import pandas as pd

key = 'POSITION_ID'

# --- Find duplicates
dupes = df[df.duplicated(subset=[key], keep=False)].copy()

# --- Group by POSITION_ID and check if all rows within that group are identical
# We do this by comparing number of unique rows per group
def check_group_identical(group):
    return group.drop(columns=[key]).nunique(dropna=False).eq(1).all()

duplicate_summary = (
    dupes.groupby(key)
         .apply(check_group_identical)
         .reset_index(name='All_Columns_Same')
)

# --- Split into two categories
true_duplicates = duplicate_summary[duplicate_summary['All_Columns_Same']]
conflicting_duplicates = duplicate_summary[~duplicate_summary['All_Columns_Same']]

print("\n True duplicates (completely identical rows):")
print(true_duplicates)

print("\n Conflicting duplicates (same ID, but different column values):")
print(conflicting_duplicates)






















import pandas as pd
import numpy as np

# Example: df1 and df2 already loaded (from Excel or other sources)
# Common key column
key = 'POSITION_ID'

# Align on POSITION_ID to ensure same row order for comparison
df1 = df1.set_index(key).sort_index()
df2 = df2.set_index(key).sort_index()

# Ensure both have same columns
common_cols = df1.columns.intersection(df2.columns)

# Compare values treating NaN/None as equal
comparison = (df1[common_cols].fillna('__NULL__') == df2[common_cols].fillna('__NULL__'))

# Summary per column
summary = comparison.sum().to_frame(name='Matching_Count')
summary['Total_Rows'] = len(comparison)
summary['Match_%'] = (summary['Matching_Count'] / summary['Total_Rows'] * 100).round(2)

# Identify mismatched rows for detailed check
mismatch_details = (
    ~comparison
).any(axis=1)

mismatch_report = pd.DataFrame({
    key: df1.index[mismatch_details],
    'Columns_Not_Matching': comparison.columns[~comparison.loc[mismatch_details].all()].tolist()
})

# Final summary output
print("\n Column-wise match summary:")
print(summary)

print("\n Mismatch details (rows where at least one column differs):")
print(mismatch_report)



















import pandas as pd

# Example: assuming df1 and df2 have same columns including POSITION_ID

# Merge both dataframes on POSITION_ID
merged = df1.merge(df2, on='POSITION_ID', suffixes=('_df1', '_df2'))

# List of columns to compare (excluding POSITION_ID)
columns_to_compare = [col for col in df1.columns if col != 'POSITION_ID']

# For each column, check if they match
for col in columns_to_compare:
    merged[f'{col}_MATCH'] = merged[f'{col}_df1'] == merged[f'{col}_df2']

# Compute summary match status per POSITION_ID
summary = merged[['POSITION_ID'] + [f'{col}_MATCH' for col in columns_to_compare]]

# Add an overall flag if all columns matched
summary['ALL_COLUMNS_MATCH'] = summary[[f'{col}_MATCH' for col in columns_to_compare]].all(axis=1)

# Display result
print(summary)





mismatched = summary[~summary['ALL_COLUMNS_MATCH']]
print(mismatched)






















SET SERVEROUTPUT ON;

DECLARE
    v_sql CLOB := '';
BEGIN
    FOR rec IN (
        SELECT column_name
        FROM all_tab_columns
        WHERE owner = 'WFA_APP_USR_TALD'
          AND table_name = 'BASE_WD_REPORT_VIEW_POSITION'
          AND column_name <> 'PERIOD'  -- ignore period filter column
          AND column_name <> 'POSITION_ID'  -- key column
        ORDER BY column_id
    ) LOOP
        v_sql := v_sql || 'WHEN a.' || rec.column_name || ' <> b.' || rec.column_name ||
                 ' THEN ''' || rec.column_name || '''' || CHR(10);
    END LOOP;

    DBMS_OUTPUT.PUT_LINE('--- Generated Comparison Query ---');
    DBMS_OUTPUT.PUT_LINE('SELECT a.POSITION_ID, CASE ' || CHR(10) || v_sql || 
        ' END AS MISMATCH_COLUMN
FROM WFA_APP_USR_TALD.BASE_WD_REPORT_VIEW_POSITION a
JOIN WFA_APP_USR_TALD.BASE_WD_REPORT_VIEW_POSITION_PYTHON b
  ON a.POSITION_ID = b.POSITION_ID
WHERE a.PERIOD = ''10/27/2025''
  AND b.PERIOD = ''10/27/2025''
  AND ( ');

    FOR rec IN (
        SELECT column_name
        FROM all_tab_columns
        WHERE owner = 'WFA_APP_USR_TALD'
          AND table_name = 'BASE_WD_REPORT_VIEW_POSITION'
          AND column_name <> 'PERIOD'
          AND column_name <> 'POSITION_ID'
        ORDER BY column_id
    ) LOOP
        v_sql := v_sql || 'a.' || rec.column_name || ' <> b.' || rec.column_name || ' OR ';
    END LOOP;

    DBMS_OUTPUT.PUT_LINE(RTRIM(v_sql, ' OR ') || ' );');
END;
/






















SELECT
    a.POSITION_ID,
    CASE
        WHEN a.POSITION_NAME != b.POSITION_NAME THEN 'POSITION_NAME'
        WHEN a.MANAGER_NAME  != b.MANAGER_NAME  THEN 'MANAGER_NAME'
        WHEN a.COUNTRY       != b.COUNTRY       THEN 'COUNTRY'
        WHEN a.DEPARTMENT    != b.DEPARTMENT    THEN 'DEPARTMENT'
        WHEN a.LEVEL         != b.LEVEL         THEN 'LEVEL'
    END AS MISMATCH_COLUMN
FROM WFA_APP_USR_TALD.BASE_WD_REPORT_VIEW_POSITION a
JOIN WFA_APP_USR_TALD.BASE_WD_REPORT_VIEW_POSITION_PYTHON b
  ON a.POSITION_ID = b.POSITION_ID
WHERE a.PERIOD = '10/27/2025'
  AND b.PERIOD = '10/27/2025'
  AND (
        a.POSITION_NAME != b.POSITION_NAME OR
        a.MANAGER_NAME  != b.MANAGER_NAME OR
        a.COUNTRY       != b.COUNTRY OR
        a.DEPARTMENT    != b.DEPARTMENT OR
        a.LEVEL         != b.LEVEL
      );



























SELECT POSITION_ID, 'MISSING_IN_PYTHON' AS STATUS
FROM WFA_APP_USR_TALD_BASE_WD_REPORT_VIEW_POSITION
WHERE POSITION_ID NOT IN (
    SELECT POSITION_ID FROM WFA_APP_USR_TALD_BASE_WD_REPORT_VIEW_POSITION_PYTHON
)
UNION ALL
SELECT POSITION_ID, 'EXTRA_IN_PYTHON' AS STATUS
FROM WFA_APP_USR_TALD_BASE_WD_REPORT_VIEW_POSITION_PYTHON
WHERE POSITION_ID NOT IN (
    SELECT POSITION_ID FROM WFA_APP_USR_TALD_BASE_WD_REPORT_VIEW_POSITION
);











SET SERVEROUTPUT ON
DECLARE
    v_sql   CLOB;
BEGIN
    -- 1 Drop existing summary table if exists
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE POSITION_MISMATCH_SUMMARY';
    EXCEPTION
        WHEN OTHERS THEN
            NULL; -- ignore if table doesnt exist
    END;

    -- 2 Create new summary table
    EXECUTE IMMEDIATE '
        CREATE TABLE POSITION_MISMATCH_SUMMARY (
            POSITION_ID VARCHAR2(200),
            MISMATCHED_COLUMNS VARCHAR2(4000)
        )
    ';

    -- 3 Start building dynamic comparison SQL
    v_sql := 'INSERT INTO POSITION_MISMATCH_SUMMARY
              SELECT a.POSITION_ID, ';

    -- Generate CASE-based concatenation for mismatched columns
    FOR rec IN (
        SELECT COLUMN_NAME
        FROM USER_TAB_COLUMNS
        WHERE TABLE_NAME = 'WFA_APP_USR_TALD_BASE_WD_REPORT_VIEW_POSITION'
          AND COLUMN_NAME <> 'POSITION_ID'
        ORDER BY COLUMN_ID
    )
    LOOP
        v_sql := v_sql ||
            'CASE WHEN NVL(a.' || rec.COLUMN_NAME || ', ''X'') != NVL(b.' || rec.COLUMN_NAME || ', ''X'') 
                  THEN ''' || rec.COLUMN_NAME || ' '' ELSE '''' END || ';
    END LOOP;

    -- Remove trailing concatenation operator
    v_sql := RTRIM(v_sql, ' || ');

    -- Continue query body
    v_sql := v_sql || ' AS MISMATCHED_COLUMNS
        FROM WFA_APP_USR_TALD_BASE_WD_REPORT_VIEW_POSITION a
        JOIN WFA_APP_USR_TALD_BASE_WD_REPORT_VIEW_POSITION_PYTHON b
          ON a.POSITION_ID = b.POSITION_ID
        WHERE ';

    -- Generate WHERE clause dynamically
    FOR rec IN (
        SELECT COLUMN_NAME
        FROM USER_TAB_COLUMNS
        WHERE TABLE_NAME = 'WFA_APP_USR_TALD_BASE_WD_REPORT_VIEW_POSITION'
          AND COLUMN_NAME <> 'POSITION_ID'
        ORDER BY COLUMN_ID
    )
    LOOP
        v_sql := v_sql || 'NVL(a.' || rec.COLUMN_NAME || ', ''X'') != NVL(b.' || rec.COLUMN_NAME || ', ''X'') OR ';
    END LOOP;

    -- Remove trailing OR
    v_sql := RTRIM(v_sql, ' OR ');

    -- 4 Execute the dynamic SQL
    EXECUTE IMMEDIATE v_sql;

    DBMS_OUTPUT.PUT_LINE(' Comparison completed successfully.');
    DBMS_OUTPUT.PUT_LINE('  Use: SELECT * FROM POSITION_MISMATCH_SUMMARY;');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE(' Error: ' || SQLERRM);
END;
/



SELECT * FROM POSITION_MISMATCH_SUMMARY;











Here's a technical 2-liner description for each fraud detection feature based on the formulas:

1. high_dollar_velocity_3hr:
Ratio of high-value (300) txn count in 3hr to total txn count in 3hr. Captures rapid bursts of high-value activity.


2. high_dollar_ratio_24hr:
Ratio of high-value txn amount to total txn amount in 24hr. Highlights dominance of large-value txns in a short time.


3. exp_date_mismatch_ratio_7days:
Count of expiration date mismatches over total txn count in 7 days. Detects frequent CVV/expiry mismatches often tied to synthetic fraud.


4. zero_auth_mismatch_ratio_24hr:
Ratio of zero-auth mismatch count to zero-auth txn count in 24hr. Flags abnormal patterns in pre-auth probes.


5. foreign_high_dollar_ratio:
Ratio of high-value foreign txn amount to total txn amount in 24hr. Indicates risky cross-border high-value txns.


6. weekend_high_dollar_ratio:
Ratio of weekend high-value txn amount to total weekend txn amount in 24hr. Targets off-hour fraud attempts when oversight is low.


7. nighttime_high_dollar_velocity:
High-value txn velocity during 10pm6am, normalized by txn count. Tracks abnormal night-time high-value behavior.


8. high_dollar_swipe_ratio:
Proportion of swipe high-value txn amount to total amount. Flags high-value in-person swipes that deviate from profile.


9. ratio_avg_swipe_amt_24hr_by_60days:
Average swipe txn amount in 24hr normalized by 60-day average. Highlights short-term spending anomalies.


10. transaction_acceleration_24hr:
Ratio of 24hr txn amount to 48hr trailing window. Quantifies sharp spending increases.


11. avmismatch_ratio_30days:
Count of AV (address verification) mismatches to total txns over 30 days. Flags consistent identity verification failures.


12. zero_auth_high_dollar_ratio:
Ratio of high-value zero-auth txn amount to total zero-auth txn amount. Targets abnormal testing behaviors with large amounts.


13. high_val_tx_velocity:
Ratio of high-value txns to txn count at the same merchant in 24hr. Detects merchant-specific fraud bursts.


14. fraud_trx_drift:
Ratio of fraudulent txn amount to average txn amount at merchant over 60 days. Captures fraud drift toward certain merchants.


15. cnt_same_mid_termid_24hr:
Count of txns at same merchant-terminal combo in 24hr. Detects excessive usage of specific terminal for fraud.


16. cnt_for_swipe_24hr:
Count of swiped txns in 24hr window. Useful for card-present fraud detection.


17. velocity_merchant_risk:
Velocity feature capturing merchant-level txn acceleration. Quantifies merchant risk based on usage pattern deviation.


18. cnt_same_merc_id_24hr:
Count of txns at same merchant ID in 24hr. Flags repeated usage of a merchant which may be fraud hotspot.


19. cnt_same_merc_id_30min:
Same as above but in 30min interval. Captures short-burst fraud attempts.


20. hot_mer_mcc_bayesian_encoded_1/11/21/24hr:
Bayesian encoding of merchant MCC risk based on target leakage in various time windows. Encodes historical MCC fraud likelihood in rolling fashion.



Let me know if you want this exported to a table or file format for presentation.









Here is the feature-wise technical description with exact formula context from your image:


---

1. high_dollar_fraud_mer_ratio
Formula: (amt_same_mid_termid_30min) / (amt_same_mid_termid_24hr + 1)
Description: Ratio of high-value txn amount within 30min to total 24hr amount at the same MID-Terminal. Detects rapid high-value fraud bursts.


2. fraud_zero_auth_ratio
Formula: (cnt_za_ris_24hr * cnt_za_mis_7days) / (tot_zero_auth_cnt_24hr + 1)
Description: Product of recent risky zero-auth txn count and 7-day mismatch count, normalized by total 24hr zero-auth volume. Captures anomaly in zero-auth behavior.


3. high_risk_mer8_name_shift
Formula: new_merch_ind * hct_mer_mcc_bayesian_encoded_8
Description: Binary merchant shift indicator weighted by MCC Bayesian risk. Highlights movement toward historically risky MCCs.


4. swipe_anomaly_score
Formula: abs(amt_swipe_tdy - avg_swipe_amt_24hr) / (avg_swipe_amt_60days + epsilon1)
Description: Absolute swipe txn deviation from 24hr avg, scaled by long-term mean. Detects sudden abnormal swipe patterns.


5. time_since_last_high_dollar
Formula: amt_ge500_ind * time_since_last_trxn
Description: High-value txn flag weighted by time since last txn. Flags spacing between large amounts.


6. mcc_shift_30d_index
Formula: abs(new_mcc_ind - avg_same_mcc_amt_30days)
Description: Deviation of MCC switch from 30-day avg. Highlights abrupt merchant pattern changes.


7. mcc_shift_24hr_index
Formula: abs(new_mcc_ind - avg_same_mcc_amt_24hr)
Description: Captures short-term MCC pattern deviation. Flags recent merchant usage anomalies.


8. auth_decline_ratio
Formula: cnt_same_merc_id_6hr / (cnt_same_merc_id_6hr + 1)
Description: Simple ratio capturing dense merchant hits post-auth decline. Signifies retry patterns.


9. transaction_amt_drift
Formula: (amt_swipe_tdy * avg_trxn_amt_30days) / (avg_trxn_amt_60days + epsilon1)
Description: Recent swipe txn amount scaled by 30d avg, normalized by 60d avg. Detects shifts in txn amount profiles.


10. high_density_swipe_score
Formula: cnt_swipe_24hr / (cnt_swipe_60days + 1)
Description: Swipe txn density score across timeframes. Flags bursts of card-present activity.


11. zero_auth_high_risk_mer_score
Formula: zero_auth_diff_mer_nm_ind * hct_mer_mcc_bayesian_encoded_1
Description: Flags zero-auth attempts at new merchants with MCC-based risk weighting.


12. mcc_high_dollar_ratio
Formula: (amt_5310_5411_24hr * amt_ge500_ind) / (tot_amt_24hr + 1)
Description: Proportion of high-value txns at MCC 5310/5411 (grocery/retail) to total. Detects large-value retail spikes.


13. ratio_high_dollar_cnp_24hr
Formula: (amt_cnp_24hr * amt_ge500_ind) / (tot_amt_24hr + 1)
Description: High-value card-not-present txn ratio over total 24hr value. Flags e-comm fraud risk.


14. multi_window_zero_auth_velocity
Formula: tot_zero_auth_cnt_24hr * tot_zero_auth_cnt_48hr * tot_zero_auth_cnt_72hr
Description: Velocity of zero-auth transactions across 3 time windows. Captures bot-like probing.


15. trxn_hour_foreign_amt_ge500
Formula: trxn_hour * foreign_ind * amt_ge500_ind
Description: Time-weighted risk score for high-value foreign txns. Flags suspicious cross-border behavior.




---

Would you like this as a structured Excel or PDF for documentation?








import os
import xlsxwriter

# Define paths for PDP and Bivariate plots
pdp_folder = "pdp_plot"
bvp_folder = "bvp_plot"
output_excel = "Combined_Plots.xlsx"

# Get the list of feature names (assuming both folders have same naming convention)
feature_names = sorted([f.replace(".png", "") for f in os.listdir(pdp_folder) if f.endswith(".png")])

# Create an Excel workbook
workbook = xlsxwriter.Workbook(output_excel)

# Loop through each feature and add PDP + BVP to the sheet
for feature in feature_names:
    worksheet = workbook.add_worksheet(feature)  # Create a new sheet for each feature
    
    # Define image paths
    pdp_path = os.path.join(pdp_folder, feature + ".png")
    bvp_path = os.path.join(bvp_folder, feature + ".png")
    
    # Insert images into the worksheet
    worksheet.insert_image("A1", pdp_path, {'x_scale': 0.5, 'y_scale': 0.5})  # Adjust size if needed
    worksheet.insert_image("J1", bvp_path, {'x_scale': 0.5, 'y_scale': 0.5})  # Insert BVP next to PDP

# Close and save the Excel file
workbook.close()

print(f" Excel file '{output_excel}' created successfully with 36 sheets!")











import h2o
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from pdpbox import pdp
from h2o.estimators.gbm import H2OGradientBoostingEstimator

# Initialize H2O
h2o.init()

# Load H2O DataFrames (Replace with actual files)
train = h2o.import_file("train.csv")
train_rs = h2o.import_file("train_rs.csv")
test = h2o.import_file("test.csv")
oot = h2o.import_file("oot.csv")

# Convert to Pandas
train_df = train.as_data_frame()
train_rs_df = train_rs.as_data_frame()
test_df = test.as_data_frame()
oot_df = oot.as_data_frame()

# Define Target and Feature List
target = "fraud_label"  # Replace with your actual target column
features = ["feature_1", "feature_2", ..., "feature_30"]  # Replace with your selected variables

# Train H2O GBM Model
gbm_model = H2OGradientBoostingEstimator(ntrees=50, max_depth=5, learn_rate=0.1)
gbm_model.train(x=features, y=target, training_frame=train)

# Convert Data for PDPBox
train_df["dataset"] = "Train"
train_rs_df["dataset"] = "Train_RS"
test_df["dataset"] = "Test"
oot_df["dataset"] = "OOT"

# Combine All Datasets for Analysis
combined_df = pd.concat([train_df, train_rs_df, test_df, oot_df], axis=0)

###  Generate Plots for Each Feature ###
for feature in features:
    fig, ax1 = plt.subplots(figsize=(10, 5))

    # 1 PDP Plot
    pdp_goals = pdp.pdp_isolate(model=gbm_model, dataset=train_df, model_features=features, feature=feature)
    pdp.pdp_plot(pdp_goals, feature, plot_lines=False, ax=ax1)
    ax1.set_title(f"PDP & Fraud Rate Trend - {feature}")
    ax1.set_ylabel("Partial Dependence")
    
    # 2 Bivariate Plot (Fraud Rate per bin across datasets)
    ax2 = ax1.twinx()
    combined_df["bin"] = pd.qcut(combined_df[feature], q=10, duplicates="drop")  # Binning
    fraud_rates = combined_df.groupby(["bin", "dataset"])[target].mean().unstack()
    fraud_rates.plot(marker="o", ax=ax2)
    
    ax2.set_ylabel("Fraud Rate")
    ax2.legend(title="Dataset")

    plt.show()










import h2o
h2o.init()

# Load your dataset
df = h2o.import_file("path_to_your_dataset.csv")

# Create interaction features
df['trxn_freq_anomaly'] = df['tot_cnt_24hr'] / df['avg_trxn_cnt_30days']
df['time_since_last_trxn_anomaly'] = df['time_since_last_trxn'] / df['avg_time_between_trxns_30days']
df['wkend_wkday_ratio'] = df['tot_cnt_30days_wkend'] / df['tot_cnt_30days_wkday']
df['large_amt_anomaly'] = df['amt_swipe_ge_1000_24hr'] / df['avg_swipe_amt_24hr']
df['swipe_cnp_amt_ratio'] = df['amt_swipe_24hr'] / df['amt_cnp_24hr']
df['zero_auth_ratio'] = df['tot_zero_auth_cnt_24hr'] / df['tot_cnt_24hr']
df['dist_btw_swp_anomaly'] = df['dist_miles_btw_swp'] / df['avg_dist_btw_swp_30days']
df['foreign_trxn_ratio'] = df['cnt_fore_swipe_24hr'] / df['tot_cnt_24hr']
df['new_merch_ratio'] = df['new_merch_ind'] / df['tot_cnt_24hr']
df['mcc_anomaly_score'] = df['same_mcc_cnt_24hr'] / df['avg_same_mcc_cnt_30days']
df['cvv_mismatch_ratio'] = df['cnt_cvv2_mismatch_24hr'] / df['tot_cnt_24hr']
df['avs_mismatch_ratio'] = df['cnt_avs_mismatch_24hr'] / df['tot_cnt_24hr']
df['swipe_cnp_ratio'] = df['cnt_swipe_24hr'] / df['cnt_cnp_24hr']
df['visa_mastercard_ratio'] = df['visa_ind'] / df['mastercard_ind']
df['fraud_risk_score'] = df['cvv_mismatch_ratio'] * df['avs_mismatch_ratio'] * df['new_merch_ratio']
df['geo_temp_anomaly_score'] = df['dist_btw_swp_anomaly'] * df['time_since_last_trxn_anomaly']

# Save the updated dataset
df.save("path_to_updated_dataset.csv")






# Create interaction features
df['trxn_velocity_anomaly'] = df['tot_cnt_24hr'] / df['tot_cnt_30days']
df['zero_auth_time_gap_anomaly'] = df['mins_since_zero_auth'] / df['avg_mins_between_zero_auth_30days']
df['same_merc_cluster_score'] = df['same_merc_cnt_24hr'] / df['same_merc_cnt_30days']
df['cvv_mismatch_time_gap'] = df['time_since_cvv2_mismatch'] / df['avg_time_between_cvv_mismatch_30days']
df['avs_mismatch_time_gap'] = df['time_since_avs_mismatch'] / df['avg_time_between_avs_mismatch_30days']
df['exp_mismatch_ratio'] = df['cnt_exp_date_mismatch_24hr'] / df['tot_cnt_24hr']
df['high_risk_mcc_ratio'] = df['cnt_5310_5411_24hr'] / df['tot_cnt_24hr']
df['new_mcc_ratio'] = df['new_mcc_ind'] / df['tot_cnt_24hr']
df['merch_id_cluster_anomaly'] = df['same_merc_cnt_24hr'] / df['same_merc_cnt_30days']
df['cross_state_anomaly'] = df['diff_state_swp_24hr_ind'] / df['tot_cnt_24hr']
df['time_btw_swp_anomaly'] = df['time_btw_swp'] / df['avg_time_btw_swp_30days']
df['foreign_trxn_time_gap'] = df['time_since_last_foreign_cnp'] / df['avg_time_between_foreign_trxns_30days']
df['fraud_risk_score_2'] = df['cvv_mismatch_ratio'] * df['avs_mismatch_ratio'] * df['exp_mismatch_ratio'] * df['new_merch_ratio']
df['geo_mcc_anomaly_score'] = df['cross_state_anomaly'] * df['high_risk_mcc_ratio']

# Save the updated dataset
df.save("path_to_updated_dataset.csv")





# Create interaction features
df['zero_auth_to_auth_ratio'] = df['tot_zero_auth_cnt_24hr'] / df['tot_cnt_24hr']
df['small_amt_testing_score'] = df['cnt_sameamt_auth_6h'] / df['tot_cnt_24hr']
df['cvv_mismatch_after_zero_auth'] = df['cnt_cvv2_mismatch_24hr'] / df['tot_zero_auth_cnt_24hr']
df['trxn_burst_score'] = df['tot_cnt_30min'] / df['tot_cnt_24hr']
df['same_merc_velocity_anomaly'] = df['same_merc_cnt_30min'] / df['same_merc_cnt_24hr']
df['mcc_velocity_anomaly'] = df['same_mcc_cnt_30min'] / df['same_mcc_cnt_24hr']
df['dist_to_last_trxn_anomaly'] = df['dist_miles_btw_swp'] / df['avg_dist_btw_swp_30days']
df['cross_country_ratio'] = df['cnt_cntry_24hr'] / df['tot_cnt_24hr']
df['time_btw_geo_hops'] = df['time_btw_swp'] / df['dist_miles_btw_swp']
df['same_merc_to_term_ratio'] = df['cnt_same_mid_termid_24hr'] / df['same_merc_cnt_24hr']
df['new_merc_to_term_ratio'] = df['new_merch_id'] / df['cnt_same_mid_termid_24hr']
df['high_risk_merc_cluster'] = (df['same_merc_cnt_24hr'] / df['tot_cnt_24hr']) * df['high_risk_mcc_ratio']
df['fraud_risk_score_3'] = df['zero_auth_to_auth_ratio'] * df['small_amt_testing_score'] * df['cvv_mismatch_after_zero_auth'] * df['trxn_burst_score']
df['geo_velocity_anomaly_score'] = df['dist_to_last_trxn_anomaly'] * df['trxn_burst_score']

# Save the updated dataset
df.save("path_to_updated_dataset.csv")





# Create interaction features
df['swipe_amt_deviation'] = (df['amt_swipe_24hr'] - df['avg_swipe_amt_24hr']) / df['std_swipe_amt_24hr']
df['trxn_hour_anomaly'] = (df['trxn_hour'] - df['avg_trxn_hour_30days']) / df['std_trxn_hour_30days']
df['swipe_cnp_ratio_deviation'] = (df['swipe_cnp_ratio'] - df['avg_swipe_cnp_ratio_30days']) / df['std_swipe_cnp_ratio_30days']
df['high_risk_mcc_bayesian_interaction'] = df['hct_term_mcc_bayesian_encoded_5'] * df['hct_term_mcc_bayesian_encoded_7']
df['new_merch_risk_score'] = df['new_mech_ind'] * (1 + df['cnt_same_merc_id_24hr'] / df['tot_cnt_24hr'])
df['mcc_risk_weighted_cnt'] = df['same_mcc_cnt_24hr'] * df['hct_term_mcc_bayesian_encoded_5']
df['geo_dispersion_score'] = (df['cnt_dom_states_24hr'] / df['tot_cnt_24hr']) * df['dist_miles_btw_swp']
df['time_btw_swp_cvv_mismatch'] = df['time_since_last_swipe'] / df['time_since_cvv2_mismatch']
df['foreign_trxn_risk_score'] = df['foreign_ind'] * (1 + df['cnt_fore_swipe_24hr'] / df['tot_cnt_24hr'])
df['cvv_verf_magn_interaction'] = df['cvv_verf_magn_ind'] * (1 + df['cnt_cvv2_mismatch_24hr'] / df['tot_cnt_24hr'])
df['avs_mismatch_risk_score'] = df['avs_addr_mismatch_ind'] * (1 + df['cnt_avs_mismatch_24hr'] / df['tot_cnt_24hr'])
df['exp_mismatch_risk_score'] = df['exp_date_mismatch_ind'] * (1 + df['cnt_exp_date_mismatch_24hr'] / df['tot_cnt_24hr'])
df['fraud_risk_score_4'] = df['swipe_amt_deviation'] * df['trxn_hour_anomaly'] * df['high_risk_mcc_bayesian_interaction'] * df['new_merch_risk_score']
df['geo_temp_anomaly_score_2'] = df['geo_dispersion_score'] * df['time_btw_swp_cvv_mismatch']

# Save the updated dataset
df.save("path_to_updated_dataset.csv")










GPT


import h2o
import h2o.frame
from h2o.frame import H2OFrame

# Initialize H2O
h2o.init()

# Load dataset
df = h2o.import_file("your_fraud_data.csv")

# Creating advanced interaction features
df["risk_weighted_swipe_intensity"] = (df["cnt_swipe_24hr"] * (1 + df["cvv_verf_magn_ind"])) / (df["cnt_swipe_60days"] + 1)
df["mcc_velocity_risk"] = df["same_mcc_cnt_24hr"] / (df["same_mcc_cnt_60days"] + 1)
df["terminal_deviation"] = (df["cnt_same_mid_termid_24hr"] - df["cnt_same_mid_termid_60days"]) / (df["cnt_same_mid_termid_60days"] + 1)
df["swipe_dist_time_anomaly"] = df["dist_miles_btw_swp"] / (df["time_btw_swp"] + 1)
df["fraud_amt_scaling"] = (df["amt_swipe_24hr"] / (df["amt_swipe_60days"] + 1)) * (1 / (df["pct_swipe_amt_60days"] + 0.01))
df["avs_exp_mismatch_score"] = (df["cnt_avs_mismatch_24hr"] + df["cnt_exp_date_mismatch_24hr"]) / (df["cnt_avs_mismatch_60days"] + df["cnt_exp_date_mismatch_60days"] + 1)
df["card_testing_ratio"] = df["cnt_zero_auth_24hr"] / (df["cnt_zero_auth_60days"] + 1)
df["high_risk_merchant_score"] = df["cnt_5310_5411_24hr"] / (df["cnt_5310_5411_60days"] + 1)

# Save the enhanced dataset
h2o.export_file(df, "fraud_data_with_interaction_features.csv")











































